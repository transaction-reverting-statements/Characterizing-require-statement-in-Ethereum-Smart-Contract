{{
  "language": "Solidity",
  "sources": {
    "/Users/admin/GitHub/defi/linkswap-truffle/contracts/LinkswapPair.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./libraries/Math.sol\";\nimport \"./libraries/SafeMathLinkswap.sol\";\nimport \"./libraries/UQ112x112.sol\";\nimport \"./interfaces/ILinkswapCallee.sol\";\nimport \"./interfaces/ILinkswapFactory.sol\";\nimport \"./interfaces/ILinkswapPair.sol\";\n\ncontract LinkswapPair is ILinkswapPair, ReentrancyGuard {\n    using SafeMathLinkswap for uint256;\n    using UQ112x112 for uint224;\n\n    string public constant override name = \"LinkSwap LP Token\";\n    string public constant override symbol = \"LSLP\";\n    uint8 public constant override decimals = 18;\n    uint256 public override totalSupply;\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    bytes32 public override DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32\n        public constant\n        override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public override nonces;\n\n    uint256 public constant override MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    mapping(address => uint256) public override addressToLockupExpiry;\n    mapping(address => uint256) public override addressToLockupAmount;\n\n    address public override factory;\n    address public override token0;\n    address public override token1;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public override price0CumulativeLast;\n    uint256 public override price1CumulativeLast;\n    uint256 public override kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint256 public override tradingFeePercent; // need to divide by 1,000,000, e.g. 3000 = 0.3%\n    uint256 public override lastSlippageBlocks;\n    uint256 public override priceAtLastSlippageBlocks;\n    uint256 public override lastSwapPrice;\n\n    modifier onlyGovernance() {\n        require(msg.sender == ILinkswapFactory(factory).governance(), \"Pair: FORBIDDEN\");\n        _;\n    }\n\n    constructor() public {\n        factory = msg.sender;\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(\n        address _token0,\n        address _token1,\n        uint256 _tradingFeePercent\n    ) external override {\n        require(msg.sender == factory, \"Pair: FORBIDDEN\"); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n        tradingFeePercent = _tradingFeePercent;\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(deadline >= block.timestamp, \"Pair: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"Pair: INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n\n    function getReserves()\n        public\n        view\n        override\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"Pair: TRANSFER_FAILED\");\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private {\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), \"Pair: OVERFLOW\");\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n        uint256 protocolFeeFractionInverse = ILinkswapFactory(factory).protocolFeeFractionInverse();\n        feeOn = protocolFeeFractionInverse != 0;\n        uint256 _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));\n                uint256 rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint256 liquidity = totalSupply.mul(rootK.sub(rootKLast)).mul(1000) /\n                        ((rootK.mul(protocolFeeFractionInverse.sub(1000))).add(rootKLast.mul(1000)));\n                    if (liquidity > 0) {\n                        ILinkswapFactory linkswapFactory = ILinkswapFactory(factory);\n                        uint256 treasuryProtocolFeeShare = linkswapFactory.treasuryProtocolFeeShare();\n                        _mint(linkswapFactory.treasury(), liquidity.mul(treasuryProtocolFeeShare) / 1000000);\n                        _mint(\n                            linkswapFactory.governance(),\n                            liquidity.mul(uint256(1000000).sub(treasuryProtocolFeeShare)) / 1000000\n                        );\n                    }\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) public override nonReentrant returns (uint256 liquidity) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 amount0 = balance0.sub(_reserve0);\n        uint256 amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, \"Pair: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    function _lock(\n        address locker,\n        uint256 lockupPeriod,\n        uint256 liquidityLockupAmount\n    ) private {\n        if (lockupPeriod == 0 && liquidityLockupAmount == 0) return;\n        if (addressToLockupExpiry[locker] == 0) {\n            // not currently locked\n            require(lockupPeriod > 0, \"Pair: ZERO_LOCKUP_PERIOD\");\n            require(liquidityLockupAmount > 0, \"Pair: ZERO_LOCKUP_AMOUNT\");\n            addressToLockupExpiry[locker] = block.timestamp.add(lockupPeriod);\n        } else {\n            // locking when already locked will extend lockup period\n            addressToLockupExpiry[locker] = addressToLockupExpiry[locker].add(lockupPeriod);\n        }\n        addressToLockupAmount[locker] = addressToLockupAmount[locker].add(liquidityLockupAmount);\n        _transfer(locker, address(this), liquidityLockupAmount);\n        emit Lock(locker, lockupPeriod, liquidityLockupAmount);\n    }\n\n    // called once by the factory at time of deployment\n    function listingLock(\n        address lister,\n        uint256 lockupPeriod,\n        uint256 liquidityLockupAmount\n    ) external override {\n        require(msg.sender == factory, \"Pair: FORBIDDEN\");\n        _lock(lister, lockupPeriod, liquidityLockupAmount);\n    }\n\n    function lock(uint256 lockupPeriod, uint256 liquidityLockupAmount) external override {\n        _lock(msg.sender, lockupPeriod, liquidityLockupAmount);\n    }\n\n    function unlock() external override {\n        require(addressToLockupExpiry[msg.sender] <= block.timestamp, \"Pair: BEFORE_EXPIRY\");\n        _transfer(address(this), msg.sender, addressToLockupAmount[msg.sender]);\n        emit Unlock(msg.sender, addressToLockupAmount[msg.sender]);\n        addressToLockupAmount[msg.sender] = 0;\n        addressToLockupExpiry[msg.sender] = 0;\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external override nonReentrant returns (uint256 amount0, uint256 amount1) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, \"Pair: INSUFFICIENT_LIQUIDITY_BURNED\");\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external override nonReentrant {\n        require(amount0Out > 0 || amount1Out > 0, \"Pair: INSUFFICIENT_OUTPUT_AMOUNT\");\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"Pair: INSUFFICIENT_LIQUIDITY\");\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, \"Pair: INVALID_TO\");\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0) ILinkswapCallee(to).linkswapCall(msg.sender, amount0Out, amount1Out, data);\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n            if (ILinkswapFactory(factory).maxSlippagePercent() > 0) {\n                uint256 currentPrice = balance0.mul(1e18) / balance1;\n                if (priceAtLastSlippageBlocks == 0) {\n                    priceAtLastSlippageBlocks = currentPrice;\n                    lastSlippageBlocks = block.number;\n                } else {\n                    bool resetSlippage = lastSlippageBlocks.add(ILinkswapFactory(factory).maxSlippageBlocks()) =\n                            lastPrice.mul(uint256(100).sub(ILinkswapFactory(factory).maxSlippagePercent())) / 100 &&\n                            currentPrice <=\n                            lastPrice.mul(uint256(100).add(ILinkswapFactory(factory).maxSlippagePercent())) / 100,\n                        \"Pair: SlipLock\"\n                    );\n                    if (resetSlippage) {\n                        priceAtLastSlippageBlocks = currentPrice;\n                        lastSlippageBlocks = block.number;\n                    }\n                }\n                lastSwapPrice = currentPrice;\n            }\n        }\n        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, \"Pair: INSUFFICIENT_INPUT_AMOUNT\");\n        {\n            // scope for balance{0,1}Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = balance0.mul(1e6).sub(amount0In.mul(tradingFeePercent));\n            uint256 balance1Adjusted = balance1.mul(1e6).sub(amount1In.mul(tradingFeePercent));\n            require(balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(1e6**2), \"Pair: K\");\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external override nonReentrant {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external override nonReentrant {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n\n    function _setTradingFeePercent(uint256 _tradingFeePercent) private {\n        // max 1%\n        require(_tradingFeePercent <= 10000, \"Pair: INVALID_TRADING_FEE_PERCENT\");\n        tradingFeePercent = _tradingFeePercent;\n    }\n\n    function setTradingFeePercent(uint256 _tradingFeePercent) external override onlyGovernance {\n        _setTradingFeePercent(_tradingFeePercent);\n    }\n}\n"
    },
    "/Users/admin/GitHub/defi/linkswap-truffle/contracts/interfaces/ILinkswapCallee.sol": {
      "content": "pragma solidity 0.6.6;\n\ninterface ILinkswapCallee {\n    function linkswapCall(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "/Users/admin/GitHub/defi/linkswap-truffle/contracts/interfaces/ILinkswapERC20.sol": {
      "content": "pragma solidity 0.6.6;\n\ninterface ILinkswapERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "/Users/admin/GitHub/defi/linkswap-truffle/contracts/interfaces/ILinkswapFactory.sol": {
      "content": "pragma solidity 0.6.6;\n\ninterface ILinkswapFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256 pairNum);\n\n    function LINK() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function YFL() external view returns (address);\n\n    function governance() external view returns (address);\n\n    function treasury() external view returns (address);\n\n    function priceOracle() external view returns (address);\n\n    // USD amounts should be 8 dp precision\n    // frontend should approve transfer of higher amount (e.g. 1.1x) due to price fluctuations\n    function linkListingFeeInUsd() external view returns (uint256);\n\n    function wethListingFeeInUsd() external view returns (uint256);\n\n    function yflListingFeeInUsd() external view returns (uint256);\n\n    // need to divide share by 1,000,000 e.g. 100,000 is 10%\n    // the rest goes to governance\n    function treasuryListingFeeShare() external view returns (uint256);\n\n    function minListingLockupAmountInUsd() external view returns (uint256);\n\n    // if lockup amount is set to this or more, the lockup amount proportion of listing fee discount is fully unlocked\n    // if less than this amount, then lockup amount proportion of listing fee discount is linearly interpolated from the distance between min and target lockup amounts e.g. 60% towards target from min means 60% of lockup amount discount\n    function targetListingLockupAmountInUsd() external view returns (uint256);\n\n    // in seconds since unix epoch\n    // min lockup period for the listing lockup amount\n    function minListingLockupPeriod() external view returns (uint256);\n\n    // in seconds since unix epoch\n    // if lockup period is set to this or longer, the lockup time proportion of listing fee discount is fully unlocked\n    // if less than this period, then lockup time proportion of listing fee discount is linearly interpolated from the distance between min and target lockup times e.g. 60% towards target from min means 60% of lockup time discount\n    function targetListingLockupPeriod() external view returns (uint256);\n\n    // need to divide share by 1,000,000 e.g. 100,000 is 10%\n    // rest of listing fee discount is determined by lockup period\n    function lockupAmountListingFeeDiscountShare() external view returns (uint256);\n\n    // need to divide fee percents by 1,000,000 e.g. 3000 is 0.3000%\n    function defaultLinkTradingFeePercent() external view returns (uint256);\n\n    function defaultNonLinkTradingFeePercent() external view returns (uint256);\n\n    // need to divide share by 1,000,000 e.g. 100,000 is 10%\n    // the rest goes to governance\n    function treasuryProtocolFeeShare() external view returns (uint256);\n\n    // inverse of protocol fee fraction, then multiplied by 1000.\n    // e.g. if protocol fee is 3/7th of trading fee, then value = 7/3 * 1000 = 2333\n    // set to 0 to disable protocol fee\n    function protocolFeeFractionInverse() external view returns (uint256);\n\n    // need to divide by 100 e.g. 50 is 50%\n    function maxSlippagePercent() external view returns (uint256);\n\n    // max slippage resets after this many blocks\n    function maxSlippageBlocks() external view returns (uint256);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function approvedPair(address tokenA, address tokenB) external view returns (bool approved);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function approvePairViaGovernance(address tokenA, address tokenB) external;\n\n    function createPair(\n        address newToken,\n        uint256 newTokenAmount,\n        address lockupToken, // LINK or WETH\n        uint256 lockupTokenAmount,\n        uint256 lockupPeriod,\n        address listingFeeToken\n    ) external returns (address pair);\n\n    function setPriceOracle(address) external;\n\n    function setTreasury(address) external;\n\n    function setGovernance(address) external;\n\n    function setTreasuryProtocolFeeShare(uint256) external;\n\n    function setProtocolFeeFractionInverse(uint256) external;\n\n    function setLinkListingFeeInUsd(uint256) external;\n\n    function setWethListingFeeInUsd(uint256) external;\n\n    function setYflListingFeeInUsd(uint256) external;\n\n    function setTreasuryListingFeeShare(uint256) external;\n\n    function setMinListingLockupAmountInUsd(uint256) external;\n\n    function setTargetListingLockupAmountInUsd(uint256) external;\n\n    function setMinListingLockupPeriod(uint256) external;\n\n    function setTargetListingLockupPeriod(uint256) external;\n\n    function setLockupAmountListingFeeDiscountShare(uint256) external;\n\n    function setDefaultLinkTradingFeePercent(uint256) external;\n\n    function setDefaultNonLinkTradingFeePercent(uint256) external;\n\n    function setMaxSlippagePercent(uint256) external;\n\n    function setMaxSlippageBlocks(uint256) external;\n}\n"
    },
    "/Users/admin/GitHub/defi/linkswap-truffle/contracts/interfaces/ILinkswapPair.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"./ILinkswapERC20.sol\";\n\ninterface ILinkswapPair is ILinkswapERC20 {\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Lock(address indexed sender, uint256 lockupPeriod, uint256 liquidityLockupAmount);\n    event Unlock(address indexed sender, uint256 liquidityUnlocked);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function addressToLockupExpiry(address) external view returns (uint256);\n\n    function addressToLockupAmount(address) external view returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function tradingFeePercent() external view returns (uint256);\n\n    function lastSlippageBlocks() external view returns (uint256);\n\n    function priceAtLastSlippageBlocks() external view returns (uint256);\n\n    function lastSwapPrice() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function lock(uint256 lockupPeriod, uint256 liquidityLockupAmount) external;\n\n    function unlock() external;\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function setTradingFeePercent(uint256 _tradingFeePercent) external;\n\n    // functions only callable by LinkswapFactory\n    function initialize(\n        address _token0,\n        address _token1,\n        uint256 _tradingFeePercent\n    ) external;\n\n    function listingLock(\n        address lister,\n        uint256 lockupPeriod,\n        uint256 liquidityLockupAmount\n    ) external;\n}\n"
    },
    "/Users/admin/GitHub/defi/linkswap-truffle/contracts/libraries/Math.sol": {
      "content": "pragma solidity 0.6.6;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0\n    }\n}\n"
    },
    "/Users/admin/GitHub/defi/linkswap-truffle/contracts/libraries/SafeMathLinkswap.sol": {
      "content": "pragma solidity 0.6.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMathLinkswap {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n"
    },
    "/Users/admin/GitHub/defi/linkswap-truffle/contracts/libraries/UQ112x112.sol": {
      "content": "pragma solidity 0.6.6;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "libraries": {
      "": {}
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}
