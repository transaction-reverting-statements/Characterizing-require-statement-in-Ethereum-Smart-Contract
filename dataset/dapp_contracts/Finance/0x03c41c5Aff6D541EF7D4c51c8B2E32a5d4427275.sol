{"OwnedUpgradeabilityProxy.sol":{"content":"pragma solidity 0.5.7;\n\nimport \"./UpgradeabilityProxy.sol\";\n\n\n/**\n * @title OwnedUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n */\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\n    /**\n    * @dev Event to show ownership has been transferred\n    * @param previousOwner representing the address of the previous owner\n    * @param newOwner representing the address of the new owner\n    */\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n\n    // Storage position of the owner of the contract\n    bytes32 private constant PROXY_OWNER_POSITION = keccak256(\"org.govblocks.proxy.owner\");\n\n    /**\n    * @dev the constructor sets the original owner of the contract to the sender account.\n    */\n    constructor(address _implementation) public {\n        _setUpgradeabilityOwner(msg.sender);\n        _upgradeTo(_implementation);\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyProxyOwner() {\n        require(msg.sender == proxyOwner());\n        _;\n    }\n\n    /**\n    * @dev Tells the address of the owner\n    * @return the address of the owner\n    */\n    function proxyOwner() public view returns (address owner) {\n        bytes32 position = PROXY_OWNER_POSITION;\n        assembly {\n            owner := sload(position)\n        }\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\n        require(_newOwner != address(0));\n        _setUpgradeabilityOwner(_newOwner);\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\n    }\n\n    /**\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\n    * @param _implementation representing the address of the new implementation to be set.\n    */\n    function upgradeTo(address _implementation) public onlyProxyOwner {\n        _upgradeTo(_implementation);\n    }\n\n    /**\n     * @dev Sets the address of the owner\n    */\n    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\n        bytes32 position = PROXY_OWNER_POSITION;\n        assembly {\n            sstore(position, _newProxyOwner)\n        }\n    }\n}"},"Proxy.sol":{"content":"pragma solidity 0.5.7;\n\n\n/**\n * @title Proxy\n * @dev Gives the possibility to delegate any call to a foreign implementation.\n */\ncontract Proxy {\n    /**\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n    * This function will return whatever the implementation call returns\n    */\n    function () external payable {\n        address _impl = implementation();\n        require(_impl != address(0));\n\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize)\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n            let size := returndatasize\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n            }\n    }\n\n    /**\n    * @dev Tells the address of the implementation where every call will be delegated.\n    * @return address of the implementation to which it will be delegated\n    */\n    function implementation() public view returns (address);\n}"},"UpgradeabilityProxy.sol":{"content":"pragma solidity 0.5.7;\n\nimport \"./Proxy.sol\";\n\n\n/**\n * @title UpgradeabilityProxy\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n */\ncontract UpgradeabilityProxy is Proxy {\n    /**\n    * @dev This event will be emitted every time the implementation gets upgraded\n    * @param implementation representing the address of the upgraded implementation\n    */\n    event Upgraded(address indexed implementation);\n\n    // Storage position of the address of the current implementation\n    bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.govblocks.proxy.implementation\");\n\n    /**\n    * @dev Constructor function\n    */\n    constructor() public {}\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address impl) {\n        bytes32 position = IMPLEMENTATION_POSITION;\n        assembly {\n            impl := sload(position)\n        }\n    }\n\n    /**\n    * @dev Sets the address of the current implementation\n    * @param _newImplementation address representing the new implementation to be set\n    */\n    function _setImplementation(address _newImplementation) internal {\n        bytes32 position = IMPLEMENTATION_POSITION;\n        assembly {\n        sstore(position, _newImplementation)\n        }\n    }\n\n    /**\n    * @dev Upgrades the implementation address\n    * @param _newImplementation representing the address of the new implementation to be set\n    */\n    function _upgradeTo(address _newImplementation) internal {\n        address currentImplementation = implementation();\n        require(currentImplementation != _newImplementation);\n        _setImplementation(_newImplementation);\n        emit Upgraded(_newImplementation);\n    }\n}"}}
