{{
  "language": "Solidity",
  "sources": {
    "contracts/NestPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/AddressPayable.sol\";\nimport \"./lib/SafeERC20.sol\";\nimport './lib/TransferHelper.sol';\nimport \"./iface/INestPool.sol\";\nimport \"./iface/INestDAO.sol\";\nimport \"./iface/INestMining.sol\";\nimport \"./iface/INestQuery.sol\";\nimport \"./iface/INestStaking.sol\";\nimport \"./iface/INNRewardPool.sol\";\nimport \"./iface/INTokenController.sol\";\n\n/// @title NestPool\n/// @author Inf Loop - \n/// @author Paradox  - \n\n/// @dev The contract is for bookkeeping ETH, NEST and Tokens. It is served as a vault, such that \n///     assets are transferred internally to save GAS.\ncontract NestPool is INestPool {\n    \n    using address_make_payable for address;\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    uint8 private flag;  // 0: UNINITIALIZED  | 1: INITIALIZED\n    uint256 public minedNestAmount; \n\n    address override public governance;\n    address public addrOfNestBurning = address(0x1);\n\n    // Contracts \n    address public C_NestDAO;\n    address public C_NestMining;\n    ERC20   public C_NestToken;\n    address public C_NTokenController;\n    address public C_NNToken;\n    address public C_NNRewardPool;\n    address public C_NestStaking;\n    address public C_NestQuery;\n\n    // eth ledger for all miners\n    mapping(address => uint256) _eth_ledger;\n    // token => miner => amount \n    mapping(address => mapping(address => uint256)) _token_ledger;\n\n    // mapping(address => uint256) _nest_ledger;\n\n    mapping(address => address) _token_ntoken_mapping;\n\n    // parameters \n\n    constructor() public \n    {\n        governance = msg.sender;\n    }\n\n    receive() external payable { }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyGovernance() \n    {\n        require(msg.sender == governance, \"Nest:Pool:!governance\");\n        _;\n    }\n\n    modifier onlyBy(address _contract) \n    {\n        require(msg.sender == _contract, \"Nest:Pool:!Auth\");\n        _;\n    }\n\n    modifier onlyGovOrBy(address _contract) \n    {\n        require(msg.sender == governance || msg.sender == _contract, \"Nest:Pool:!Auth\");\n        _;\n    }\n\n    /*\n    modifier onlyGovOrBy2(address _contract, address _contract2)\n    {\n        require(msg.sender == governance || msg.sender == _contract || msg.sender == _contract2, \"Nest:Pool:!Auth\");\n        _;\n    }\n\n    modifier onlyGovOrBy3(address _contract1, address _contract2, address _contract3)\n    {\n        require(msg.sender == governance\n            || msg.sender == _contract1\n            || msg.sender == _contract2\n            || msg.sender == _contract3, \"Nest:Pool:!Auth\");\n        _;\n    }\n    */\n    modifier onlyByNest()\n    {\n        require(msg.sender == C_NestMining\n            || msg.sender == C_NTokenController \n            || msg.sender == C_NestDAO \n            || msg.sender == C_NestStaking \n            || msg.sender == C_NNRewardPool \n            || msg.sender == C_NestQuery, \"Nest:Pool:!Auth\");\n        _;\n    }\n\n    modifier onlyMiningContract()\n    {\n        require(address(msg.sender) == C_NestMining, \"Nest:Pool:onlyMining\");\n        _;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    function setGovernance(address _gov) \n        override external onlyGovernance \n    { \n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n        _nest_ledger[_gov] = _nest_ledger[governance];  \n        _nest_ledger[governance] = 0;\n        governance = _gov;\n    }\n\n    function setContracts(\n            address NestToken, address NestMining, \n            address NestStaking, address NTokenController, \n            address NNToken, address NNRewardPool, \n            address NestQuery, address NestDAO\n        ) \n        external onlyGovernance\n    {\n        if (NestToken != address(0)) {\n            C_NestToken = ERC20(NestToken);\n        }\n        if (NestMining != address(0)) {\n            C_NestMining = NestMining;\n        }\n        if (NTokenController != address(0)) {\n            C_NTokenController = NTokenController;\n        }\n        if (NNToken != address(0)) {\n            C_NNToken = NNToken;\n        }\n        if (NNRewardPool != address(0)) {\n            C_NNRewardPool = NNRewardPool;\n        }\n        if (NestStaking != address(0)) {\n            C_NestStaking = NestStaking;\n        }\n        if (NestQuery != address(0)) {\n            C_NestQuery = NestQuery;\n        }\n        if (NestDAO != address(0)) {\n            C_NestDAO = NestDAO;\n        }\n    }\n\n    /// @dev Set the total amount of NEST in the pool. After Nest v3.5 upgrading, all \n    ///    of the unmined NEST will be transferred by the governer to this pool. \n    function initNestLedger(uint256 amount) \n        override external onlyGovernance \n    {\n        require(_token_ledger[address(C_NestToken)][address(governance)] == 0, \"Nest:Pool:!init\"); \n        _token_ledger[address(C_NestToken)][address(governance)] = amount;\n    }\n\n    function getNTokenFromToken(address token) \n        override view public returns (address) \n    {\n        return _token_ntoken_mapping[token];\n    }\n\n    function setNTokenToToken(address token, address ntoken) \n        override \n        public\n        onlyGovOrBy(C_NTokenController) \n    {\n        _token_ntoken_mapping[token] = ntoken;\n        _token_ntoken_mapping[ntoken] = ntoken;\n    }\n\n    /* ========== ONLY FOR EMERGENCY ========== */\n\n    // function drainEth(address to, uint256 amount) \n    //     external onlyGovernance\n    // {\n    //     TransferHelper.safeTransferETH(to, amount);\n    // }\n\n    function drainNest(address to, uint256 amount, address gov) \n         override external onlyGovernance\n    {\n         require(_token_ledger[address(C_NestToken)][gov] >= amount, \"Nest:Pool:!amount\");\n         C_NestToken.transfer(to, amount);\n    }\n\n    function transferNestInPool(address from, address to, uint256 amount) \n        external onlyByNest\n    {\n        if (amount == 0) {\n            return;\n        }\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n        uint256 blnc = _nest_ledger[from];\n        require (blnc >= amount, \"Nest:Pool:!amount\");\n        _nest_ledger[from] = blnc.sub(amount);\n        _nest_ledger[to] = _nest_ledger[to].add(amount);\n    }\n\n    function transferTokenInPool(address token, address from, address to, uint256 amount) \n        external onlyByNest\n    {\n        if (amount == 0) {\n            return;\n        }\n        uint256 blnc = _token_ledger[token][from];\n        require (blnc >= amount, \"Nest:Pool:!amount\");\n        _token_ledger[token][from] = blnc.sub(amount);\n        _token_ledger[token][to] = _token_ledger[token][to].add(amount);\n    }\n\n    function transferEthInPool(address from, address to, uint256 amount) \n        external onlyByNest\n    {\n        if (amount == 0) {\n            return;\n        }\n        uint256 blnc = _eth_ledger[from];\n        require (blnc >= amount, \"Nest:Pool:!amount\");\n        _eth_ledger[from] = blnc.sub(amount);\n        _eth_ledger[to] = _eth_ledger[to].add(amount);\n    }\n\n\n    /* ========== FREEZING/UNFREEZING ========== */\n\n    // NOTE: Guarded by onlyMiningContract\n\n    function freezeEth(address miner, uint256 ethAmount) \n        override public onlyBy(C_NestMining) \n    {\n        // emit LogAddress(\"freezeEthAndToken> miner\", miner);\n        // emit LogAddress(\"freezeEthAndToken> token\", token);\n        uint256 blncs = _eth_ledger[miner];\n        require(blncs >= ethAmount, \"Nest:Pool:BAL(eth)<0\");\n        _eth_ledger[miner] = blncs - ethAmount;  //safe_math: checked before\n        _eth_ledger[address(this)] =  _eth_ledger[address(this)].add(ethAmount);\n    }\n\n    function unfreezeEth(address miner, uint256 ethAmount) \n        override public onlyBy(C_NestMining)  \n    {\n        if (ethAmount > 0) {\n            // LogUint(\"unfreezeEthAndToken> _eth_ledger[address(0x0)]\", _eth_ledger[address(0x0)]);\n            // LogUint(\"unfreezeEthAndToken> _eth_ledger[miner]\", _eth_ledger[miner]);\n            // LogUint(\"unfreezeEthAndToken> ethAmount\", ethAmount);\n            _eth_ledger[address(this)] =  _eth_ledger[address(this)].sub(ethAmount);\n            _eth_ledger[miner] = _eth_ledger[miner].add(ethAmount);\n        } \n    }\n\n    function freezeNest(address miner, uint256 nestAmount) \n        override public onlyBy(C_NestMining)  \n    {\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n\n        uint256 blncs = _nest_ledger[miner];\n        \n        _nest_ledger[address(this)] =  _nest_ledger[address(this)].add(nestAmount);\n\n        if (blncs < nestAmount) {\n            _nest_ledger[miner] = 0; \n            require(C_NestToken.transferFrom(miner,  address(this), nestAmount - blncs), \"Nest:Pool:!transfer\"); //safe math\n        } else {\n            _nest_ledger[miner] = blncs - nestAmount;  //safe math\n        }\n    }\n\n    function unfreezeNest(address miner, uint256 nestAmount) \n        override public onlyBy(C_NestMining)  \n    {\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n\n        if (nestAmount > 0) {\n            _nest_ledger[address(this)] =  _nest_ledger[address(this)].sub(nestAmount);\n            _nest_ledger[miner] = _nest_ledger[miner].add(nestAmount); \n        }\n    }\n\n    function freezeToken(address miner, address token, uint256 tokenAmount) \n        override external onlyBy(C_NestMining)  \n    {\n        uint256 blncs = _token_ledger[token][miner];\n        _token_ledger[token][address(this)] =  _token_ledger[token][address(this)].add(tokenAmount);\n        if (blncs < tokenAmount) {\n            _token_ledger[token][miner] = 0; \n            ERC20(token).safeTransferFrom(address(miner),  address(this), tokenAmount - blncs); //safe math\n        } else {\n            _token_ledger[token][miner] = blncs - tokenAmount;  //safe math\n        }\n    }\n\n    function unfreezeToken(address miner, address token, uint256 tokenAmount) \n        override external onlyBy(C_NestMining)  \n    {\n        if (tokenAmount > 0) {\n            _token_ledger[token][address(this)] =  _token_ledger[token][address(this)].sub(tokenAmount);\n            _token_ledger[token][miner] = _token_ledger[token][miner].add(tokenAmount); \n        }\n    }\n\n    function freezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) \n        override external onlyBy(C_NestMining)  \n    {\n        uint256 blncs = _eth_ledger[miner];\n        require(blncs >= ethAmount, \"Nest:Pool:!eth\");\n        _eth_ledger[miner] = blncs - ethAmount;  //safe_math: checked before\n        _eth_ledger[address(this)] =  _eth_ledger[address(this)].add(ethAmount);\n\n        blncs = _token_ledger[token][miner];\n        _token_ledger[token][address(this)] =  _token_ledger[token][address(this)].add(tokenAmount);\n        if (blncs < tokenAmount) {\n            _token_ledger[token][miner] = 0;\n            ERC20(token).safeTransferFrom(address(miner),  address(this), tokenAmount - blncs); //safe math\n        } else {\n            _token_ledger[token][miner] = blncs - tokenAmount;  //safe math\n        }\n    }\n\n    function unfreezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) \n        override external onlyBy(C_NestMining)  \n    {\n        if (ethAmount > 0) {\n            _eth_ledger[address(this)] =  _eth_ledger[address(this)].sub(ethAmount);\n            _eth_ledger[miner] = _eth_ledger[miner].add(ethAmount);\n        } \n\n        if (tokenAmount > 0) {\n            _token_ledger[token][address(this)] =  _token_ledger[token][address(this)].sub(tokenAmount);\n            _token_ledger[token][miner] = _token_ledger[token][miner].add(tokenAmount); \n        }\n    }\n\n    /* ========== BALANCE ========== */\n\n\n    function balanceOfNestInPool(address miner) \n        override public view returns (uint256)\n    {\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n\n        return _nest_ledger[miner];\n    }\n\n    function balanceOfEthInPool(address miner) \n        override public view returns (uint256)\n    {\n        return _eth_ledger[miner];\n    }\n\n    function balanceOfTokenInPool(address miner, address token) \n        override public view returns (uint256)\n    {\n        return _token_ledger[token][miner];\n    }\n\n    function balanceOfEthFreezed() public view returns (uint256)\n    {\n        return _eth_ledger[address(this)];\n    }\n\n    function balanceOfTokenFreezed(address token) public view returns (uint256)\n    {\n        return _token_ledger[token][address(this)];\n    }\n\n    /* ========== DISTRIBUTING ========== */\n\n    function addNest(address miner, uint256 amount) \n        override public onlyBy(C_NestMining)\n    {\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n        _nest_ledger[governance] = _nest_ledger[governance].sub(amount);\n        _nest_ledger[miner] = _nest_ledger[miner].add(amount);\n        minedNestAmount = minedNestAmount.add(amount);\n    }\n\n    function addNToken(address miner, address ntoken, uint256 amount) \n        override public onlyBy(C_NestMining)\n    {\n        _token_ledger[ntoken][miner] = _token_ledger[ntoken][miner].add(amount);\n    }\n\n    /* ========== DEPOSIT ========== */\n\n    // NOTE: Guarded by onlyMiningContract\n\n    function depositEth(address miner) \n        override payable external onlyGovOrBy(C_NestMining) \n    {\n        _eth_ledger[miner] =  _eth_ledger[miner].add(msg.value);\n    }\n\n    function depositNToken(address miner, address from, address ntoken, uint256 amount) \n        override external onlyGovOrBy(C_NestMining) \n    {\n        ERC20(ntoken).transferFrom(from, address(this), amount);\n        _token_ledger[ntoken][miner] =  _token_ledger[ntoken][miner].add(amount);\n    }\n\n    /* ========== WITHDRAW ========== */\n\n    // NOTE: Guarded by onlyGovOrBy(C_NestMining), onlyGovOrBy(C_NestStaking)\n    \n    /// @dev If amount == 0, it won't go stuck\n    function withdrawEth(address miner, uint256 ethAmount) \n        override public onlyByNest\n    {\n        uint256 blncs = _eth_ledger[miner];\n        require(ethAmount <= blncs, \"Nest:Pool:!blncs\");\n        if (ethAmount > 0) {\n            _eth_ledger[miner] = blncs - ethAmount; // safe math\n            TransferHelper.safeTransferETH(miner, ethAmount);\n        }\n    }\n\n    /// @dev If amount == 0, it won't go stuck\n    function withdrawToken(address miner, address token, uint256 tokenAmount) \n        override public onlyByNest\n    {\n        uint256 blncs = _token_ledger[token][miner];\n        require(tokenAmount <= blncs, \"Nest:Pool:!blncs\");\n        if (tokenAmount > 0) {\n            _token_ledger[token][miner] = blncs - tokenAmount; // safe math\n            ERC20(token).safeTransfer(miner, tokenAmount);\n        }\n    }\n\n\n    /// @dev If amount == 0, it won't go stuck\n    function withdrawNest(address miner, uint256 amount) \n        override public onlyByNest\n    {\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n\n        uint256 blncs = _nest_ledger[miner];\n        require(amount <= blncs, \"Nest:Pool:!blncs\");\n        if (amount > 0) {\n            _nest_ledger[miner] = blncs - amount;  // safe math\n            require(C_NestToken.transfer(miner, amount),\"Nest:Pool:!TRANS\");\n        }\n    }\n\n\n    /// @dev If amount == 0, it won't go stuck\n    function withdrawEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) \n        override public onlyBy(C_NestMining)\n    {\n        uint256 blncs = _eth_ledger[miner];\n        if (ethAmount <= blncs && ethAmount > 0) {\n            _eth_ledger[miner] = blncs - ethAmount;  // safe math\n            TransferHelper.safeTransferETH(miner, ethAmount);\n        }\n\n        blncs = _token_ledger[token][miner];\n        if (tokenAmount <= blncs && tokenAmount > 0) {\n            _token_ledger[token][miner] = blncs - tokenAmount;  // safe math\n            ERC20(token).safeTransfer(miner, tokenAmount);\n        }\n    }\n\n    /// @dev If amount == 0, it won't go stuck\n    function withdrawNTokenAndTransfer(address miner, address ntoken, uint256 amount, address to) \n        override public onlyBy(C_NestStaking)\n    {\n        uint256 blncs = _token_ledger[ntoken][miner];\n        require(amount <= blncs, \"Nest:Pool:!blncs\");\n        if (amount > 0) {\n            _token_ledger[ntoken][miner] = blncs - amount;  // safe math\n            require(ERC20(ntoken).transfer(to, amount),\"Nest:Pool:!TRANS\");\n        }\n    }\n\n    /* ========== HELPERS (VIEWS) ========== */\n    // the user needs to be reminded of the parameter settings    \n    function assetsList(uint256 len, address[] memory tokenList) \n        public view returns (uint256[] memory) \n    {\n        // len < = length(tokenList) + 1\n        require(len == tokenList.length + 1, \"Nest: Pool: !assetsList\");\n        uint256[] memory list = new uint256[](len);\n        list[0] = _eth_ledger[address(msg.sender)];\n        for (uint i = 0; i < len - 1; i++) {\n            address _token = tokenList[i];\n            list[i+1] = _token_ledger[_token][address(msg.sender)];\n        }\n        return list;\n    }\n\n    function addrOfNestMining() override public view returns (address) \n    {\n        return C_NestMining;\n    }\n\n    function addrOfNestToken() override public view returns (address) \n    {\n        return address(C_NestToken);\n    }\n\n    function addrOfNTokenController() override public view returns (address) \n    {\n        return C_NTokenController;\n    }\n    \n    function addrOfNNRewardPool() override public view returns (address) \n    {\n        return C_NNRewardPool;\n    }\n\n    function addrOfNNToken() override public view returns (address) \n    {\n        return C_NNToken;\n    }\n\n    function addrOfNestStaking() override public view returns (address) \n    {\n        return C_NestStaking;\n    }\n\n    function addrOfNestQuery() override public view returns (address) \n    {\n        return C_NestQuery;\n    }\n\n    function addrOfNestDAO() override public view returns (address) \n    {\n        return C_NestDAO;\n    }\n\n    function addressOfBurnedNest() override public view returns (address) \n    {\n        return addrOfNestBurning;\n    }\n\n    // function getMinerNToken(address miner, address token) public view returns (uint256 tokenAmount) \n    // {\n    //     if (token != address(0x0)) {\n    //         tokenAmount = _token_ledger[token][miner];\n    //     }\n    // } \n        \n    function getMinerEthAndToken(address miner, address token) \n        public view returns (uint256 ethAmount, uint256 tokenAmount) \n    {\n        ethAmount = _eth_ledger[miner];\n        if (token != address(0x0)) {\n            tokenAmount = _token_ledger[token][miner];\n        }\n    } \n\n    function getMinerNest(address miner) public view returns (uint256 nestAmount) \n    {\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n\n        nestAmount = _nest_ledger[miner];\n    } \n\n}\n"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n\n    function div(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"ds-math-div-zero\");\n        z = x / y;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    }\n}"
    },
    "contracts/lib/AddressPayable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nlibrary address_make_payable {\n   function make_payable(address x) internal pure returns (address payable) {\n      return address(uint160(x));\n   }\n}"
    },
    "contracts/lib/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.6.12;\n\nimport \"./Address.sol\";\nimport \"./SafeMath.sol\";\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/lib/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/iface/INestPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport \"../lib/SafeERC20.sol\";\n\ninterface INestPool {\n\n    // function getNTokenFromToken(address token) view external returns (address);\n    // function setNTokenToToken(address token, address ntoken) external; \n\n    function addNest(address miner, uint256 amount) external;\n    function addNToken(address contributor, address ntoken, uint256 amount) external;\n\n    function depositEth(address miner) external payable;\n    function depositNToken(address miner,  address from, address ntoken, uint256 amount) external;\n\n    function freezeEth(address miner, uint256 ethAmount) external; \n    function unfreezeEth(address miner, uint256 ethAmount) external;\n\n    function freezeNest(address miner, uint256 nestAmount) external;\n    function unfreezeNest(address miner, uint256 nestAmount) external;\n\n    function freezeToken(address miner, address token, uint256 tokenAmount) external; \n    function unfreezeToken(address miner, address token, uint256 tokenAmount) external;\n\n    function freezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\n    function unfreezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\n\n    function getNTokenFromToken(address token) external view returns (address); \n    function setNTokenToToken(address token, address ntoken) external; \n\n    function withdrawEth(address miner, uint256 ethAmount) external;\n    function withdrawToken(address miner, address token, uint256 tokenAmount) external;\n\n    function withdrawNest(address miner, uint256 amount) external;\n    function withdrawEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\n    // function withdrawNToken(address miner, address ntoken, uint256 amount) external;\n    function withdrawNTokenAndTransfer(address miner, address ntoken, uint256 amount, address to) external;\n\n\n    function balanceOfNestInPool(address miner) external view returns (uint256);\n    function balanceOfEthInPool(address miner) external view returns (uint256);\n    function balanceOfTokenInPool(address miner, address token)  external view returns (uint256);\n\n    function addrOfNestToken() external view returns (address);\n    function addrOfNestMining() external view returns (address);\n    function addrOfNTokenController() external view returns (address);\n    function addrOfNNRewardPool() external view returns (address);\n    function addrOfNNToken() external view returns (address);\n    function addrOfNestStaking() external view returns (address);\n    function addrOfNestQuery() external view returns (address);\n    function addrOfNestDAO() external view returns (address);\n\n    function addressOfBurnedNest() external view returns (address);\n\n    function setGovernance(address _gov) external; \n    function governance() external view returns(address);\n    function initNestLedger(uint256 amount) external;\n    function drainNest(address to, uint256 amount, address gov) external;\n\n}"
    },
    "contracts/iface/INestDAO.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\ninterface INestDAO {\n\n    function addETHReward(address ntoken) external payable; \n\n    function addNestReward(uint256 amount) external;\n\n    /// @dev Only for governance\n    function loadContracts() external; \n\n    /// @dev Only for governance\n    function loadGovernance() external;\n    \n    /// @dev Only for governance\n    function start() external; \n\n    function initEthLedger(address ntoken, uint256 amount) external;\n\n    event NTokenRedeemed(address ntoken, address user, uint256 amount);\n\n    event AssetsCollected(address user, uint256 ethAmount, uint256 nestAmount);\n\n    event ParamsSetup(address gov, uint256 oldParam, uint256 newParam);\n\n    event FlagSet(address gov, uint256 flag);\n\n}"
    },
    "contracts/iface/INestMining.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/SafeERC20.sol\";\n\n\ninterface INestMining {\n    \n    struct Params {\n        uint8    miningEthUnit;     // = 10;\n        uint32   nestStakedNum1k;   // = 1;\n        uint8    biteFeeRate;       // = 1; \n        uint8    miningFeeRate;     // = 10;\n        uint8    priceDurationBlock; \n        uint8    maxBiteNestedLevel; // = 3;\n        uint8    biteInflateFactor;\n        uint8    biteNestInflateFactor;\n    }\n\n    function priceOf(address token) external view returns(uint256 ethAmount, uint256 tokenAmount, uint256 bn);\n    \n    function priceListOfToken(address token, uint8 num) external view returns(uint128[] memory data, uint256 bn);\n\n    // function priceOfTokenAtHeight(address token, uint64 atHeight) external view returns(uint256 ethAmount, uint256 tokenAmount, uint64 bn);\n\n    function latestPriceOf(address token) external view returns (uint256 ethAmount, uint256 tokenAmount, uint256 bn);\n\n    function priceAvgAndSigmaOf(address token) \n        external view returns (uint128, uint128, int128, uint32);\n\n    function minedNestAmount() external view returns (uint256);\n\n    /// @dev Only for governance\n    function loadContracts() external; \n    \n    function loadGovernance() external;\n\n    function upgrade() external;\n\n    function setup(uint32   genesisBlockNumber, uint128  latestMiningHeight, uint128  minedNestTotalAmount, Params calldata initParams) external;\n\n    function setParams1(uint128  latestMiningHeight, uint128  minedNestTotalAmount) external;\n}"
    },
    "contracts/iface/INestQuery.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n/// @title The interface of NestQuery\n/// @author Inf Loop - \n/// @author Paradox  - \ninterface INestQuery {\n\n    /// @notice Activate a pay-per-query defi client with NEST tokens\n    /// @dev No contract is allowed to call it\n    /// @param defi The addres of client (DeFi DApp)\n    function activate(address defi) external;\n\n    /// @notice Deactivate a pay-per-query defi client\n    /// @param defi The address of a client (DeFi DApp)\n    function deactivate(address defi) external;\n\n    /// @notice Query for PPQ (pay-per-query) clients\n    /// @dev Consider that if a user call a DeFi that queries NestQuery, DeFi should\n    ///     pass the user's wallet address to query() as `payback`.\n    /// @param token The address of token contract\n    /// @param payback The address of change\n    function query(address token, address payback) \n        external payable returns (uint256, uint256, uint256);\n\n    /// @notice Query for PPQ (pay-per-query) clients\n    /// @param token The address of token contract\n    /// @param payback The address of change\n    /// @return ethAmount The amount of ETH in pair (ETH, TOKEN)\n    /// @return tokenAmount The amount of TOKEN in pair (ETH, TOKEN)\n    /// @return avgPrice The average of last 50 prices \n    /// @return vola The volatility of prices \n    /// @return bn The block number when (ETH, TOKEN) takes into effective\n    function queryPriceAvgVola(address token, address payback) \n        external payable returns (uint256, uint256, uint128, int128, uint256);\n\n    /// @notice The main function called by DeFi clients, compatible to Nest Protocol v3.0 \n    /// @dev  The payback address is ZERO, so the changes are kept in this contract\n    ///         The ABI keeps consist with Nest v3.0\n    /// @param tokenAddress The address of token contract address\n    /// @return ethAmount The amount of ETH in price pair (ETH, ERC20)\n    /// @return erc20Amount The amount of ERC20 in price pair (ETH, ERC20)\n    /// @return blockNum The block.number where the price is being in effect\n    function updateAndCheckPriceNow(address tokenAddress) \n        external payable returns (uint256, uint256, uint256);\n\n    /// @notice A non-free function for querying price \n    /// @param token  The address of the token contract\n    /// @param num    The number of price sheets in the list\n    /// @param payback The address for change\n    /// @return The array of prices, each of which is (blockNnumber, ethAmount, tokenAmount)\n    function queryPriceList(address token, uint8 num, address payback) \n        external payable returns (uint128[] memory);\n\n    /// @notice A view function returning the historical price list from the current block\n    /// @param token  The address of the token contract\n    /// @param num    The number of price sheets in the list\n    /// @return The array of prices, each of which is (blockNnumber, ethAmount, tokenAmount)\n    function priceList(address token, uint8 num) \n        external view returns (uint128[] memory);\n\n    /// @notice A view function returning the latestPrice\n    /// @param token  The address of the token contract\n    function latestPrice(address token)\n    external view returns (uint256 ethAmount, uint256 tokenAmount, uint128 avgPrice, int128 vola, uint256 bn) ;\n\n    /// @dev Only for governance\n    function loadContracts() external; \n\n    /// @dev Only for governance\n    function loadGovernance() external; \n\n\n    event ClientActivated(address, uint256, uint256);\n    // event ClientRenewed(address, uint256, uint256, uint256);\n    event PriceQueried(address client, address token, uint256 ethAmount, uint256 tokenAmount, uint256 bn);\n    event PriceAvgVolaQueried(address client, address token, uint256 bn, uint128 avgPrice, int128 vola);\n\n    event PriceListQueried(address client, address token, uint256 bn, uint8 num);\n\n    // governance events\n    event ParamsSetup(address gov, uint256 oldParams, uint256 newParams);\n    event FlagSet(address gov, uint256 flag);\n}"
    },
    "contracts/iface/INestStaking.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n\ninterface INestStaking {\n    // Views\n\n    /// @dev How many stakingToken (XToken) deposited into to this reward pool (staking pool)\n    /// @param  ntoken The address of NToken\n    /// @return The total amount of XTokens deposited in this staking pool\n    function totalStaked(address ntoken) external view returns (uint256);\n\n    /// @dev How many stakingToken (XToken) deposited by the target account\n    /// @param  ntoken The address of NToken\n    /// @param  account The target account\n    /// @return The total amount of XToken deposited in this staking pool\n    function stakedBalanceOf(address ntoken, address account) external view returns (uint256);\n\n\n    // Mutative\n    /// @dev Stake/Deposit into the reward pool (staking pool)\n    /// @param  ntoken The address of NToken\n    /// @param  amount The target amount\n    function stake(address ntoken, uint256 amount) external;\n\n    function stakeFromNestPool(address ntoken, uint256 amount) external;\n\n    /// @dev Withdraw from the reward pool (staking pool), get the original tokens back\n    /// @param  ntoken The address of NToken\n    /// @param  amount The target amount\n    function unstake(address ntoken, uint256 amount) external;\n\n    /// @dev Claim the reward the user earned\n    /// @param ntoken The address of NToken\n    /// @return The amount of ethers as rewards\n    function claim(address ntoken) external returns (uint256);\n\n    /// @dev Add ETH reward to the staking pool\n    /// @param ntoken The address of NToken\n    function addETHReward(address ntoken) external payable;\n\n    /// @dev Only for governance\n    function loadContracts() external; \n\n    /// @dev Only for governance\n    function loadGovernance() external; \n\n    function pause() external;\n\n    function resume() external;\n\n    //function setParams(uint8 dividendShareRate) external;\n\n    /* ========== EVENTS ========== */\n\n    // Events\n    event RewardAdded(address ntoken, address sender, uint256 reward);\n    event NTokenStaked(address ntoken, address indexed user, uint256 amount);\n    event NTokenUnstaked(address ntoken, address indexed user, uint256 amount);\n    event SavingWithdrawn(address ntoken, address indexed to, uint256 amount);\n    event RewardClaimed(address ntoken, address indexed user, uint256 reward);\n\n    event FlagSet(address gov, uint256 flag);\n}"
    },
    "contracts/iface/INNRewardPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n/// @title NNRewardPool\n/// @author Inf Loop - \n/// @author Paradox  - \n\ninterface INNRewardPool {\n    \n    /* [DEPRECATED]\n        uint256 constant DEV_REWARD_PERCENTAGE   = 5;\n        uint256 constant NN_REWARD_PERCENTAGE    = 15;\n        uint256 constant MINER_REWARD_PERCENTAGE = 80;\n    */\n\n    /// @notice Add rewards for Nest-Nodes, only governance or NestMining (contract) are allowed\n    /// @dev  The rewards need to pull from NestPool\n    /// @param _amount The amount of Nest token as the rewards to each nest-node\n    function addNNReward(uint256 _amount) external;\n\n    /// @notice Claim rewards by Nest-Nodes\n    /// @dev The rewards need to pull from NestPool\n    function claimNNReward() external ;  \n\n    /// @dev The callback function called by NNToken.transfer()\n    /// @param fromAdd The address of 'from' to transfer\n    /// @param toAdd The address of 'to' to transfer\n    function nodeCount(address fromAdd, address toAdd) external;\n\n    /// @notice Show the amount of rewards unclaimed\n    /// @return reward The reward of a NN holder\n    function unclaimedNNReward() external view returns (uint256 reward);\n\n    /// @dev Only for governance\n    function loadContracts() external; \n\n    /// @dev Only for governance\n    function loadGovernance() external; \n\n    /* ========== EVENTS ============== */\n\n    /// @notice When rewards are added to the pool\n    /// @param reward The amount of Nest Token\n    /// @param allRewards The snapshot of all rewards accumulated\n    event NNRewardAdded(uint256 reward, uint256 allRewards);\n\n    /// @notice When rewards are claimed by nodes \n    /// @param nnode The address of the nest node\n    /// @param share The amount of Nest Token claimed by the nest node\n    event NNRewardClaimed(address nnode, uint256 share);\n\n    /// @notice When flag of state is set by governance \n    /// @param gov The address of the governance\n    /// @param flag The value of the new flag\n    event FlagSet(address gov, uint256 flag);\n}"
    },
    "contracts/iface/INTokenController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface INTokenController {\n\n    /// @dev A struct for an ntoken\n    ///     size: 2 x 256bit\n    struct NTokenTag {\n        address owner;          // the owner with the highest bid\n        uint128 nestFee;        // NEST amount staked for opening a NToken\n        uint64  startTime;      // the start time of service\n        uint8   state;          // =0: normal | =1 disabled\n        uint56  _reserved;      // padding space\n    }\n\n    function open(address token) external;\n    \n    function NTokenTagOf(address token) external view returns (NTokenTag memory);\n\n    /// @dev Only for governance\n    function loadContracts() external; \n\n    function loadGovernance() external;\n\n    function setParams(uint256 _openFeeNestAmount) external;\n\n    event ParamsSetup(address gov, uint256 oldParam, uint256 newParam);\n\n    event FlagSet(address gov, uint256 flag);\n\n}\n"
    },
    "contracts/lib/Address.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.6.12;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{value:amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}
