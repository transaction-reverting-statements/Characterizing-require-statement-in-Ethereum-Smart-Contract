{"ClaimsData.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./Iupgradable.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n\r\ncontract ClaimsData is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    struct Claim {\r\n        uint coverId;\r\n        uint dateUpd;\r\n    }\r\n\r\n    struct Vote {\r\n        address voter;\r\n        uint tokens;\r\n        uint claimId;\r\n        int8 verdict;\r\n        bool rewardClaimed;\r\n    }\r\n\r\n    struct ClaimsPause {\r\n        uint coverid;\r\n        uint dateUpd;\r\n        bool submit;\r\n    }\r\n\r\n    struct ClaimPauseVoting {\r\n        uint claimid;\r\n        uint pendingTime;\r\n        bool voting;\r\n    }\r\n\r\n    struct RewardDistributed {\r\n        uint lastCAvoteIndex;\r\n        uint lastMVvoteIndex;\r\n\r\n    }\r\n\r\n    struct ClaimRewardDetails {\r\n        uint percCA;\r\n        uint percMV;\r\n        uint tokenToBeDist;\r\n\r\n    }\r\n\r\n    struct ClaimTotalTokens {\r\n        uint accept;\r\n        uint deny;\r\n    }\r\n\r\n    struct ClaimRewardStatus {\r\n        uint percCA;\r\n        uint percMV;\r\n    }\r\n\r\n    ClaimRewardStatus[] internal rewardStatus;\r\n\r\n    Claim[] internal allClaims;\r\n    Vote[] internal allvotes;\r\n    ClaimsPause[] internal claimPause;\r\n    ClaimPauseVoting[] internal claimPauseVotingEP;\r\n\r\n    mapping(address =\u003e RewardDistributed) internal voterVoteRewardReceived;\r\n    mapping(uint =\u003e ClaimRewardDetails) internal claimRewardDetail;\r\n    mapping(uint =\u003e ClaimTotalTokens) internal claimTokensCA;\r\n    mapping(uint =\u003e ClaimTotalTokens) internal claimTokensMV;\r\n    mapping(uint =\u003e int8) internal claimVote;\r\n    mapping(uint =\u003e uint) internal claimsStatus;\r\n    mapping(uint =\u003e uint) internal claimState12Count;\r\n    mapping(uint =\u003e uint[]) internal claimVoteCA;\r\n    mapping(uint =\u003e uint[]) internal claimVoteMember;\r\n    mapping(address =\u003e uint[]) internal voteAddressCA;\r\n    mapping(address =\u003e uint[]) internal voteAddressMember;\r\n    mapping(address =\u003e uint[]) internal allClaimsByAddress;\r\n    mapping(address =\u003e mapping(uint =\u003e uint)) internal userClaimVoteCA;\r\n    mapping(address =\u003e mapping(uint =\u003e uint)) internal userClaimVoteMember;\r\n    mapping(address =\u003e uint) public userClaimVotePausedOn;\r\n\r\n    uint internal claimPauseLastsubmit;\r\n    uint internal claimStartVotingFirstIndex;\r\n    uint public pendingClaimStart;\r\n    uint public claimDepositTime;\r\n    uint public maxVotingTime;\r\n    uint public minVotingTime;\r\n    uint public payoutRetryTime;\r\n    uint public claimRewardPerc;\r\n    uint public minVoteThreshold;\r\n    uint public maxVoteThreshold;\r\n    uint public majorityConsensus;\r\n    uint public pauseDaysCA;\r\n   \r\n    event ClaimRaise(\r\n        uint indexed coverId,\r\n        address indexed userAddress,\r\n        uint claimId,\r\n        uint dateSubmit\r\n    );\r\n\r\n    event VoteCast(\r\n        address indexed userAddress,\r\n        uint indexed claimId,\r\n        bytes4 indexed typeOf,\r\n        uint tokens,\r\n        uint submitDate,\r\n        int8 verdict\r\n    );\r\n\r\n    constructor() public {\r\n        pendingClaimStart = 1;\r\n        maxVotingTime = 48 * 1 hours;\r\n        minVotingTime = 12 * 1 hours;\r\n        payoutRetryTime = 24 * 1 hours;\r\n        allvotes.push(Vote(address(0), 0, 0, 0, false));\r\n        allClaims.push(Claim(0, 0));\r\n        claimDepositTime = 7 days;\r\n        claimRewardPerc = 20;\r\n        minVoteThreshold = 5;\r\n        maxVoteThreshold = 10;\r\n        majorityConsensus = 70;\r\n        pauseDaysCA = 3 days;\r\n        _addRewardIncentive();\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the pending claim start variable, \r\n     * the lowest claim id with a pending decision/payout.\r\n     */ \r\n    function setpendingClaimStart(uint _start) external onlyInternal {\r\n        require(pendingClaimStart \u003c= _start);\r\n        pendingClaimStart = _start;\r\n    }\r\n\r\n    /** \r\n     * @dev Updates the max vote index for which claim assessor has received reward \r\n     * @param _voter address of the voter.\r\n     * @param caIndex last index till which reward was distributed for CA\r\n     */ \r\n    function setRewardDistributedIndexCA(address _voter, uint caIndex) external onlyInternal {\r\n        voterVoteRewardReceived[_voter].lastCAvoteIndex = caIndex;\r\n\r\n    }\r\n\r\n    /** \r\n     * @dev Used to pause claim assessor activity for 3 days \r\n     * @param user Member address whose claim voting ability needs to be paused\r\n     */ \r\n    function setUserClaimVotePausedOn(address user) external {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        userClaimVotePausedOn[user] = now;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the max vote index for which member has received reward \r\n     * @param _voter address of the voter.\r\n     * @param mvIndex last index till which reward was distributed for member \r\n     */ \r\n    function setRewardDistributedIndexMV(address _voter, uint mvIndex) external onlyInternal {\r\n\r\n        voterVoteRewardReceived[_voter].lastMVvoteIndex = mvIndex;\r\n    }\r\n\r\n    /**\r\n     * @param claimid claim id.\r\n     * @param percCA reward Percentage reward for claim assessor\r\n     * @param percMV reward Percentage reward for members\r\n     * @param tokens total tokens to be rewarded\r\n     */ \r\n    function setClaimRewardDetail(\r\n        uint claimid,\r\n        uint percCA,\r\n        uint percMV,\r\n        uint tokens\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimRewardDetail[claimid].percCA = percCA;\r\n        claimRewardDetail[claimid].percMV = percMV;\r\n        claimRewardDetail[claimid].tokenToBeDist = tokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the reward claim status against a vote id.\r\n     * @param _voteid vote Id.\r\n     * @param claimed true if reward for vote is claimed, else false.\r\n     */ \r\n    function setRewardClaimed(uint _voteid, bool claimed) external onlyInternal {\r\n        allvotes[_voteid].rewardClaimed = claimed;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the final vote\u0027s result(either accepted or declined)of a claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _verdict 1 if claim is accepted,-1 if declined.\r\n     */ \r\n    function changeFinalVerdict(uint _claimId, int8 _verdict) external onlyInternal {\r\n        claimVote[_claimId] = _verdict;\r\n    }\r\n    \r\n    /**\r\n     * @dev Creates a new claim.\r\n     */ \r\n    function addClaim(\r\n        uint _claimId,\r\n        uint _coverId,\r\n        address _from,\r\n        uint _nowtime\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        allClaims.push(Claim(_coverId, _nowtime));\r\n        allClaimsByAddress[_from].push(_claimId);\r\n    }\r\n\r\n    /**\r\n     * @dev Add Vote\u0027s details of a given claim.\r\n     */ \r\n    function addVote(\r\n        address _voter,\r\n        uint _tokens,\r\n        uint claimId,\r\n        int8 _verdict\r\n    ) \r\n        external\r\n        onlyInternal\r\n    {\r\n        allvotes.push(Vote(_voter, _tokens, claimId, _verdict, false));\r\n    }\r\n\r\n    /** \r\n     * @dev Stores the id of the claim assessor vote given to a claim.\r\n     * Maintains record of all votes given by all the CA to a claim.\r\n     * @param _claimId Claim Id to which vote has given by the CA.\r\n     * @param _voteid Vote Id.\r\n     */\r\n    function addClaimVoteCA(uint _claimId, uint _voteid) external onlyInternal {\r\n        claimVoteCA[_claimId].push(_voteid);\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the id of the vote.\r\n     * @param _from Claim assessor\u0027s address who has given the vote.\r\n     * @param _claimId Claim Id for which vote has been given by the CA.\r\n     * @param _voteid Vote Id which will be stored against the given _from and claimid.\r\n     */ \r\n    function setUserClaimVoteCA(\r\n        address _from,\r\n        uint _claimId,\r\n        uint _voteid\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        userClaimVoteCA[_from][_claimId] = _voteid;\r\n        voteAddressCA[_from].push(_voteid);\r\n    }\r\n\r\n    /**\r\n     * @dev Stores the tokens locked by the Claim Assessors during voting of a given claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _vote 1 for accept and increases the tokens of claim as accept,\r\n     * -1 for deny and increases the tokens of claim as deny.\r\n     * @param _tokens Number of tokens.\r\n     */ \r\n    function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\r\n        if (_vote == 1)\r\n            claimTokensCA[_claimId].accept = claimTokensCA[_claimId].accept.add(_tokens);\r\n        if (_vote == -1)\r\n            claimTokensCA[_claimId].deny = claimTokensCA[_claimId].deny.add(_tokens);\r\n    }\r\n\r\n    /** \r\n     * @dev Stores the tokens locked by the Members during voting of a given claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _vote 1 for accept and increases the tokens of claim as accept,\r\n     * -1 for deny and increases the tokens of claim as deny.\r\n     * @param _tokens Number of tokens.\r\n     */ \r\n    function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\r\n        if (_vote == 1)\r\n            claimTokensMV[_claimId].accept = claimTokensMV[_claimId].accept.add(_tokens);\r\n        if (_vote == -1)\r\n            claimTokensMV[_claimId].deny = claimTokensMV[_claimId].deny.add(_tokens);\r\n    }\r\n\r\n    /** \r\n     * @dev Stores the id of the member vote given to a claim.\r\n     * Maintains record of all votes given by all the Members to a claim.\r\n     * @param _claimId Claim Id to which vote has been given by the Member.\r\n     * @param _voteid Vote Id.\r\n     */ \r\n    function addClaimVotemember(uint _claimId, uint _voteid) external onlyInternal {\r\n        claimVoteMember[_claimId].push(_voteid);\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the id of the vote.\r\n     * @param _from Member\u0027s address who has given the vote.\r\n     * @param _claimId Claim Id for which vote has been given by the Member.\r\n     * @param _voteid Vote Id which will be stored against the given _from and claimid.\r\n     */ \r\n    function setUserClaimVoteMember(\r\n        address _from,\r\n        uint _claimId,\r\n        uint _voteid\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        userClaimVoteMember[_from][_claimId] = _voteid;\r\n        voteAddressMember[_from].push(_voteid);\r\n\r\n    }\r\n\r\n    /** \r\n     * @dev Increases the count of failure until payout of a claim is successful.\r\n     */ \r\n    function updateState12Count(uint _claimId, uint _cnt) external onlyInternal {\r\n        claimState12Count[_claimId] = claimState12Count[_claimId].add(_cnt);\r\n    }\r\n\r\n    /** \r\n     * @dev Sets status of a claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _stat Status number.\r\n     */\r\n    function setClaimStatus(uint _claimId, uint _stat) external onlyInternal {\r\n        claimsStatus[_claimId] = _stat;\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the timestamp of a given claim at which the Claim\u0027s details has been updated.\r\n     * @param _claimId Claim Id of claim which has been changed.\r\n     * @param _dateUpd timestamp at which claim is updated.\r\n     */ \r\n    function setClaimdateUpd(uint _claimId, uint _dateUpd) external onlyInternal {\r\n        allClaims[_claimId].dateUpd = _dateUpd;\r\n    }\r\n\r\n    /** \r\n     @dev Queues Claims during Emergency Pause.\r\n     */ \r\n    function setClaimAtEmergencyPause(\r\n        uint _coverId,\r\n        uint _dateUpd,\r\n        bool _submit\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimPause.push(ClaimsPause(_coverId, _dateUpd, _submit));\r\n    }\r\n\r\n    /** \r\n     * @dev Set submission flag for Claims queued during emergency pause.\r\n     * Set to true after EP is turned off and the claim is submitted .\r\n     */ \r\n    function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external onlyInternal {\r\n        claimPause[_index].submit = _submit;\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the index from which claim needs to be \r\n     * submitted when emergency pause is swithched off.\r\n     */ \r\n    function setFirstClaimIndexToSubmitAfterEP(\r\n        uint _firstClaimIndexToSubmit\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimPauseLastsubmit = _firstClaimIndexToSubmit;\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the pending vote duration for a claim in case of emergency pause.\r\n     */ \r\n    function setPendingClaimDetails(\r\n        uint _claimId,\r\n        uint _pendingTime,\r\n        bool _voting\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimPauseVotingEP.push(ClaimPauseVoting(_claimId, _pendingTime, _voting));\r\n    }\r\n\r\n    /** \r\n     * @dev Sets voting flag true after claim is reopened for voting after emergency pause.\r\n     */ \r\n    function setPendingClaimVoteStatus(uint _claimId, bool _vote) external onlyInternal {\r\n        claimPauseVotingEP[_claimId].voting = _vote;\r\n    }\r\n    \r\n    /** \r\n     * @dev Sets the index from which claim needs to be \r\n     * reopened when emergency pause is swithched off. \r\n     */ \r\n    function setFirstClaimIndexToStartVotingAfterEP(\r\n        uint _claimStartVotingFirstIndex\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimStartVotingFirstIndex = _claimStartVotingFirstIndex;\r\n    }\r\n\r\n    /** \r\n     * @dev Calls Vote Event.\r\n     */ \r\n    function callVoteEvent(\r\n        address _userAddress,\r\n        uint _claimId,\r\n        bytes4 _typeOf,\r\n        uint _tokens,\r\n        uint _submitDate,\r\n        int8 _verdict\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        emit VoteCast(\r\n            _userAddress,\r\n            _claimId,\r\n            _typeOf,\r\n            _tokens,\r\n            _submitDate,\r\n            _verdict\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Calls Claim Event. \r\n     */ \r\n    function callClaimEvent(\r\n        uint _coverId,\r\n        address _userAddress,\r\n        uint _claimId,\r\n        uint _datesubmit\r\n    ) \r\n        external\r\n        onlyInternal\r\n    {\r\n        emit ClaimRaise(_coverId, _userAddress, _claimId, _datesubmit);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters by parameter code\r\n     * @param code whose details we want\r\n     * @return string value of the parameter\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\r\n        codeVal = code;\r\n        if (code == \"CAMAXVT\") {\r\n            val = maxVotingTime / (1 hours);\r\n\r\n        } else if (code == \"CAMINVT\") {\r\n\r\n            val = minVotingTime / (1 hours);\r\n\r\n        } else if (code == \"CAPRETRY\") {\r\n\r\n            val = payoutRetryTime / (1 hours);\r\n\r\n        } else if (code == \"CADEPT\") {\r\n\r\n            val = claimDepositTime / (1 days);\r\n\r\n        } else if (code == \"CAREWPER\") {\r\n\r\n            val = claimRewardPerc;\r\n\r\n        } else if (code == \"CAMINTH\") {\r\n\r\n            val = minVoteThreshold;\r\n\r\n        } else if (code == \"CAMAXTH\") {\r\n\r\n            val = maxVoteThreshold;\r\n\r\n        } else if (code == \"CACONPER\") {\r\n\r\n            val = majorityConsensus;\r\n\r\n        } else if (code == \"CAPAUSET\") {\r\n            val = pauseDaysCA / (1 days);\r\n        }\r\n    \r\n    }\r\n\r\n    /**\r\n     * @dev Get claim queued during emergency pause by index.\r\n     */ \r\n    function getClaimOfEmergencyPauseByIndex(\r\n        uint _index\r\n    ) \r\n        external\r\n        view\r\n        returns(\r\n            uint coverId,\r\n            uint dateUpd,\r\n            bool submit\r\n        )\r\n    {\r\n        coverId = claimPause[_index].coverid;\r\n        dateUpd = claimPause[_index].dateUpd;\r\n        submit = claimPause[_index].submit;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Claim\u0027s details of given claimid.   \r\n     */ \r\n    function getAllClaimsByIndex(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint coverId,\r\n            int8 vote,\r\n            uint status,\r\n            uint dateUpd,\r\n            uint state12Count\r\n        )\r\n    {\r\n        return(\r\n            allClaims[_claimId].coverId,\r\n            claimVote[_claimId],\r\n            claimsStatus[_claimId],\r\n            allClaims[_claimId].dateUpd,\r\n            claimState12Count[_claimId]\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the vote id of a given claim of a given Claim Assessor.\r\n     */ \r\n    function getUserClaimVoteCA(\r\n        address _add,\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(uint idVote)\r\n    {\r\n        return userClaimVoteCA[_add][_claimId];\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the vote id of a given claim of a given member.\r\n     */\r\n    function getUserClaimVoteMember(\r\n        address _add,\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(uint idVote)\r\n    {\r\n        return userClaimVoteMember[_add][_claimId];\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the count of all votes.\r\n     */ \r\n    function getAllVoteLength() external view returns(uint voteCount) {\r\n        return allvotes.length.sub(1); //Start Index always from 1.\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the status number of a given claim.\r\n     * @param _claimId Claim id.\r\n     * @return statno Status Number. \r\n     */ \r\n    function getClaimStatusNumber(uint _claimId) external view returns(uint claimId, uint statno) {\r\n        return (_claimId, claimsStatus[_claimId]);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the reward percentage to be distributed for a given status id\r\n     * @param statusNumber the number of type of status\r\n     * @return percCA reward Percentage for claim assessor\r\n     * @return percMV reward Percentage for members\r\n     */\r\n    function getRewardStatus(uint statusNumber) external view returns(uint percCA, uint percMV) {\r\n        return (rewardStatus[statusNumber].percCA, rewardStatus[statusNumber].percMV);\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the number of tries that have been made for a successful payout of a Claim.\r\n     */ \r\n    function getClaimState12Count(uint _claimId) external view returns(uint num) {\r\n        num = claimState12Count[_claimId];\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the last update date of a claim.\r\n     */ \r\n    function getClaimDateUpd(uint _claimId) external view returns(uint dateupd) {\r\n        dateupd = allClaims[_claimId].dateUpd;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets all Claims created by a user till date.\r\n     * @param _member user\u0027s address.\r\n     * @return claimarr List of Claims id.\r\n     */ \r\n    function getAllClaimsByAddress(address _member) external view returns(uint[] memory claimarr) {\r\n        return allClaimsByAddress[_member];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the number of tokens that has been locked \r\n     * while giving vote to a claim by  Claim Assessors.\r\n     * @param _claimId Claim Id.\r\n     * @return accept Total number of tokens when CA accepts the claim.\r\n     * @return deny Total number of tokens when CA declines the claim.\r\n     */ \r\n    function getClaimsTokenCA(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint accept,\r\n            uint deny\r\n        )\r\n    {\r\n        return (\r\n            _claimId,\r\n            claimTokensCA[_claimId].accept,\r\n            claimTokensCA[_claimId].deny\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the number of tokens that have been\r\n     * locked while assessing a claim as a member.\r\n     * @param _claimId Claim Id.\r\n     * @return accept Total number of tokens in acceptance of the claim.\r\n     * @return deny Total number of tokens against the claim.\r\n     */ \r\n    function getClaimsTokenMV(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint accept,\r\n            uint deny\r\n        )\r\n    {\r\n        return (\r\n            _claimId,\r\n            claimTokensMV[_claimId].accept,\r\n            claimTokensMV[_claimId].deny\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total number of votes cast as Claims assessor for/against a given claim\r\n     */ \r\n    function getCaClaimVotesToken(uint _claimId) external view returns(uint claimId, uint cnt) {\r\n        claimId = _claimId;\r\n        cnt = 0;\r\n        for (uint i = 0; i \u003c claimVoteCA[_claimId].length; i++) {\r\n            cnt = cnt.add(allvotes[claimVoteCA[_claimId][i]].tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total number of tokens cast as a member for/against a given claim  \r\n     */ \r\n    function getMemberClaimVotesToken(\r\n        uint _claimId\r\n    )   \r\n        external\r\n        view\r\n        returns(uint claimId, uint cnt)\r\n    {\r\n        claimId = _claimId;\r\n        cnt = 0;\r\n        for (uint i = 0; i \u003c claimVoteMember[_claimId].length; i++) {\r\n            cnt = cnt.add(allvotes[claimVoteMember[_claimId][i]].tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Provides information of a vote when given its vote id.\r\n     * @param _voteid Vote Id.\r\n     */\r\n    function getVoteDetails(uint _voteid)\r\n    external view\r\n    returns(\r\n        uint tokens,\r\n        uint claimId,\r\n        int8 verdict,\r\n        bool rewardClaimed\r\n        )\r\n    {\r\n        return (\r\n            allvotes[_voteid].tokens,\r\n            allvotes[_voteid].claimId,\r\n            allvotes[_voteid].verdict,\r\n            allvotes[_voteid].rewardClaimed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the voter\u0027s address of a given vote id.\r\n     */ \r\n    function getVoterVote(uint _voteid) external view returns(address voter) {\r\n        return allvotes[_voteid].voter;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides information of a Claim when given its claim id.\r\n     * @param _claimId Claim Id.\r\n     */ \r\n    function getClaim(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint coverId,\r\n            int8 vote,\r\n            uint status,\r\n            uint dateUpd,\r\n            uint state12Count\r\n        )\r\n    {\r\n        return (\r\n            _claimId,\r\n            allClaims[_claimId].coverId,\r\n            claimVote[_claimId],\r\n            claimsStatus[_claimId],\r\n            allClaims[_claimId].dateUpd,\r\n            claimState12Count[_claimId]\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total number of votes of a given claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _ca if 1: votes given by Claim Assessors to a claim,\r\n     * else returns the number of votes of given by Members to a claim.\r\n     * @return len total number of votes for/against a given claim.\r\n     */ \r\n    function getClaimVoteLength(\r\n        uint _claimId,\r\n        uint8 _ca\r\n    )\r\n        external\r\n        view\r\n        returns(uint claimId, uint len)\r\n    {\r\n        claimId = _claimId;\r\n        if (_ca == 1)\r\n            len = claimVoteCA[_claimId].length;\r\n        else\r\n            len = claimVoteMember[_claimId].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the verdict of a vote using claim id and index.\r\n     * @param _ca 1 for vote given as a CA, else for vote given as a member.\r\n     * @return ver 1 if vote was given in favour,-1 if given in against.\r\n     */ \r\n    function getVoteVerdict(\r\n        uint _claimId,\r\n        uint _index,\r\n        uint8 _ca\r\n    )\r\n        external\r\n        view\r\n        returns(int8 ver)\r\n    {\r\n        if (_ca == 1)\r\n            ver = allvotes[claimVoteCA[_claimId][_index]].verdict;\r\n        else\r\n            ver = allvotes[claimVoteMember[_claimId][_index]].verdict;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Number of tokens of a vote using claim id and index.\r\n     * @param _ca 1 for vote given as a CA, else for vote given as a member.\r\n     * @return tok Number of tokens.\r\n     */ \r\n    function getVoteToken(\r\n        uint _claimId,\r\n        uint _index,\r\n        uint8 _ca\r\n    )   \r\n        external\r\n        view\r\n        returns(uint tok)\r\n    {\r\n        if (_ca == 1)\r\n            tok = allvotes[claimVoteCA[_claimId][_index]].tokens;\r\n        else\r\n            tok = allvotes[claimVoteMember[_claimId][_index]].tokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Voter\u0027s address of a vote using claim id and index.\r\n     * @param _ca 1 for vote given as a CA, else for vote given as a member.\r\n     * @return voter Voter\u0027s address.\r\n     */ \r\n    function getVoteVoter(\r\n        uint _claimId,\r\n        uint _index,\r\n        uint8 _ca\r\n    )\r\n        external\r\n        view\r\n        returns(address voter)\r\n    {\r\n        if (_ca == 1)\r\n            voter = allvotes[claimVoteCA[_claimId][_index]].voter;\r\n        else\r\n            voter = allvotes[claimVoteMember[_claimId][_index]].voter;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets total number of Claims created by a user till date.\r\n     * @param _add User\u0027s address.\r\n     */ \r\n    function getUserClaimCount(address _add) external view returns(uint len) {\r\n        len = allClaimsByAddress[_add].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates number of Claims that are in pending state.\r\n     */ \r\n    function getClaimLength() external view returns(uint len) {\r\n        len = allClaims.length.sub(pendingClaimStart);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Number of all the Claims created till date.\r\n     */ \r\n    function actualClaimLength() external view returns(uint len) {\r\n        len = allClaims.length;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets details of a claim.\r\n     * @param _index claim id = pending claim start + given index\r\n     * @param _add User\u0027s address.\r\n     * @return coverid cover against which claim has been submitted.\r\n     * @return claimId Claim  Id.\r\n     * @return voteCA verdict of vote given as a Claim Assessor.  \r\n     * @return voteMV verdict of vote given as a Member.\r\n     * @return statusnumber Status of claim.\r\n     */ \r\n    function getClaimFromNewStart(\r\n        uint _index,\r\n        address _add\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint coverid,\r\n            uint claimId,\r\n            int8 voteCA,\r\n            int8 voteMV,\r\n            uint statusnumber\r\n        )\r\n    {\r\n        uint i = pendingClaimStart.add(_index);\r\n        coverid = allClaims[i].coverId;\r\n        claimId = i;\r\n        if (userClaimVoteCA[_add][i] \u003e 0)\r\n            voteCA = allvotes[userClaimVoteCA[_add][i]].verdict;\r\n        else\r\n            voteCA = 0;\r\n\r\n        if (userClaimVoteMember[_add][i] \u003e 0)\r\n            voteMV = allvotes[userClaimVoteMember[_add][i]].verdict;\r\n        else\r\n            voteMV = 0;\r\n\r\n        statusnumber = claimsStatus[i];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets details of a claim of a user at a given index.  \r\n     */ \r\n    function getUserClaimByIndex(\r\n        uint _index,\r\n        address _add\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint status,\r\n            uint coverid,\r\n            uint claimId\r\n        )\r\n    {\r\n        claimId = allClaimsByAddress[_add][_index];\r\n        status = claimsStatus[claimId];\r\n        coverid = allClaims[claimId].coverId;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Id of all the votes given to a claim.\r\n     * @param _claimId Claim Id.\r\n     * @return ca id of all the votes given by Claim assessors to a claim.\r\n     * @return mv id of all the votes given by members to a claim.\r\n     */ \r\n    function getAllVotesForClaim(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint[] memory ca,\r\n            uint[] memory mv\r\n        )\r\n    {\r\n        return (_claimId, claimVoteCA[_claimId], claimVoteMember[_claimId]);\r\n    }\r\n\r\n    /** \r\n     * @dev Gets Number of tokens deposit in a vote using\r\n     * Claim assessor\u0027s address and claim id.\r\n     * @return tokens Number of deposited tokens.\r\n     */ \r\n    function getTokensClaim(\r\n        address _of,\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint tokens\r\n        )\r\n    {\r\n        return (_claimId, allvotes[userClaimVoteCA[_of][_claimId]].tokens);\r\n    }\r\n\r\n    /**\r\n     * @param _voter address of the voter.\r\n     * @return lastCAvoteIndex last index till which reward was distributed for CA\r\n     * @return lastMVvoteIndex last index till which reward was distributed for member\r\n     */ \r\n    function getRewardDistributedIndex(\r\n        address _voter\r\n    ) \r\n        external\r\n        view\r\n        returns(\r\n            uint lastCAvoteIndex,\r\n            uint lastMVvoteIndex\r\n        )\r\n    {\r\n        return (\r\n            voterVoteRewardReceived[_voter].lastCAvoteIndex,\r\n            voterVoteRewardReceived[_voter].lastMVvoteIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @param claimid claim id.\r\n     * @return perc_CA reward Percentage for claim assessor\r\n     * @return perc_MV reward Percentage for members\r\n     * @return tokens total tokens to be rewarded \r\n     */ \r\n    function getClaimRewardDetail(\r\n        uint claimid\r\n    ) \r\n        external\r\n        view\r\n        returns(\r\n            uint percCA,\r\n            uint percMV,\r\n            uint tokens\r\n        )\r\n    {\r\n        return (\r\n            claimRewardDetail[claimid].percCA,\r\n            claimRewardDetail[claimid].percMV,\r\n            claimRewardDetail[claimid].tokenToBeDist\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets cover id of a claim.\r\n     */ \r\n    function getClaimCoverId(uint _claimId) external view returns(uint claimId, uint coverid) {\r\n        return (_claimId, allClaims[_claimId].coverId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets total number of tokens staked during voting by Claim Assessors.\r\n     * @param _claimId Claim Id.\r\n     * @param _verdict 1 to get total number of accept tokens, -1 to get total number of deny tokens.\r\n     * @return token token Number of tokens(either accept or deny on the basis of verdict given as parameter).\r\n     */ \r\n    function getClaimVote(uint _claimId, int8 _verdict) external view returns(uint claimId, uint token) {\r\n        claimId = _claimId;\r\n        token = 0;\r\n        for (uint i = 0; i \u003c claimVoteCA[_claimId].length; i++) {\r\n            if (allvotes[claimVoteCA[_claimId][i]].verdict == _verdict)\r\n                token = token.add(allvotes[claimVoteCA[_claimId][i]].tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets total number of tokens staked during voting by Members.\r\n     * @param _claimId Claim Id.\r\n     * @param _verdict 1 to get total number of accept tokens,\r\n     *  -1 to get total number of deny tokens.\r\n     * @return token token Number of tokens(either accept or \r\n     * deny on the basis of verdict given as parameter).\r\n     */ \r\n    function getClaimMVote(uint _claimId, int8 _verdict) external view returns(uint claimId, uint token) {\r\n        claimId = _claimId;\r\n        token = 0;\r\n        for (uint i = 0; i \u003c claimVoteMember[_claimId].length; i++) {\r\n            if (allvotes[claimVoteMember[_claimId][i]].verdict == _verdict)\r\n                token = token.add(allvotes[claimVoteMember[_claimId][i]].tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param _voter address  of voteid\r\n     * @param index index to get voteid in CA\r\n     */ \r\n    function getVoteAddressCA(address _voter, uint index) external view returns(uint) {\r\n        return voteAddressCA[_voter][index];\r\n    }\r\n\r\n    /**\r\n     * @param _voter address  of voter\r\n     * @param index index to get voteid in member vote\r\n     */ \r\n    function getVoteAddressMember(address _voter, uint index) external view returns(uint) {\r\n        return voteAddressMember[_voter][index];\r\n    }\r\n\r\n    /**\r\n     * @param _voter address  of voter   \r\n     */ \r\n    function getVoteAddressCALength(address _voter) external view returns(uint) {\r\n        return voteAddressCA[_voter].length;\r\n    }\r\n\r\n    /**\r\n     * @param _voter address  of voter   \r\n     */ \r\n    function getVoteAddressMemberLength(address _voter) external view returns(uint) {\r\n        return voteAddressMember[_voter].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Final result of voting of a claim.\r\n     * @param _claimId Claim id.\r\n     * @return verdict 1 if claim is accepted, -1 if declined.\r\n     */ \r\n    function getFinalVerdict(uint _claimId) external view returns(int8 verdict) {\r\n        return claimVote[_claimId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get number of Claims queued for submission during emergency pause.\r\n     */ \r\n    function getLengthOfClaimSubmittedAtEP() external view returns(uint len) {\r\n        len = claimPause.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the index from which claim needs to be \r\n     * submitted when emergency pause is swithched off.\r\n     */ \r\n    function getFirstClaimIndexToSubmitAfterEP() external view returns(uint indexToSubmit) {\r\n        indexToSubmit = claimPauseLastsubmit;\r\n    }\r\n    \r\n    /**\r\n     * @dev Gets number of Claims to be reopened for voting post emergency pause period.\r\n     */ \r\n    function getLengthOfClaimVotingPause() external view returns(uint len) {\r\n        len = claimPauseVotingEP.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets claim details to be reopened for voting after emergency pause.\r\n     */ \r\n    function getPendingClaimDetailsByIndex(\r\n        uint _index\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint pendingTime,\r\n            bool voting\r\n        )\r\n    {\r\n        claimId = claimPauseVotingEP[_index].claimid;\r\n        pendingTime = claimPauseVotingEP[_index].pendingTime;\r\n        voting = claimPauseVotingEP[_index].voting;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the index from which claim needs to be reopened when emergency pause is swithched off.\r\n     */ \r\n    function getFirstClaimIndexToStartVotingAfterEP() external view returns(uint firstindex) {\r\n        firstindex = claimStartVotingFirstIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"CAMAXVT\") {\r\n            _setMaxVotingTime(val * 1 hours);\r\n\r\n        } else if (code == \"CAMINVT\") {\r\n\r\n            _setMinVotingTime(val * 1 hours);\r\n\r\n        } else if (code == \"CAPRETRY\") {\r\n\r\n            _setPayoutRetryTime(val * 1 hours);\r\n\r\n        } else if (code == \"CADEPT\") {\r\n\r\n            _setClaimDepositTime(val * 1 days);\r\n\r\n        } else if (code == \"CAREWPER\") {\r\n\r\n            _setClaimRewardPerc(val);\r\n\r\n        } else if (code == \"CAMINTH\") {\r\n\r\n            _setMinVoteThreshold(val);\r\n\r\n        } else if (code == \"CAMAXTH\") {\r\n\r\n            _setMaxVoteThreshold(val);\r\n\r\n        } else if (code == \"CACONPER\") {\r\n\r\n            _setMajorityConsensus(val);\r\n\r\n        } else if (code == \"CAPAUSET\") {\r\n            _setPauseDaysCA(val * 1 days);\r\n        } else {\r\n\r\n            revert(\"Invalid param code\");\r\n        }\r\n    \r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public onlyInternal {}\r\n\r\n    /**\r\n     * @dev Adds status under which a claim can lie.\r\n     * @param percCA reward percentage for claim assessor\r\n     * @param percMV reward percentage for members\r\n     */\r\n    function _pushStatus(uint percCA, uint percMV) internal {\r\n        rewardStatus.push(ClaimRewardStatus(percCA, percMV));\r\n    }\r\n\r\n    /**\r\n     * @dev adds reward incentive for all possible claim status for Claim assessors and members\r\n     */\r\n    function _addRewardIncentive() internal {\r\n        _pushStatus(0, 0); //0  Pending-Claim Assessor Vote\r\n        _pushStatus(0, 0); //1 Pending-Claim Assessor Vote Denied, Pending Member Vote\r\n        _pushStatus(0, 0); //2 Pending-CA Vote Threshold not Reached Accept, Pending Member Vote\r\n        _pushStatus(0, 0); //3 Pending-CA Vote Threshold not Reached Deny, Pending Member Vote\r\n        _pushStatus(0, 0); //4 Pending-CA Consensus not reached Accept, Pending Member Vote\r\n        _pushStatus(0, 0); //5 Pending-CA Consensus not reached Deny, Pending Member Vote\r\n        _pushStatus(100, 0); //6 Final-Claim Assessor Vote Denied\r\n        _pushStatus(100, 0); //7 Final-Claim Assessor Vote Accepted\r\n        _pushStatus(0, 100); //8 Final-Claim Assessor Vote Denied, MV Accepted\r\n        _pushStatus(0, 100); //9 Final-Claim Assessor Vote Denied, MV Denied\r\n        _pushStatus(0, 0); //10 Final-Claim Assessor Vote Accept, MV Nodecision\r\n        _pushStatus(0, 0); //11 Final-Claim Assessor Vote Denied, MV Nodecision\r\n        _pushStatus(0, 0); //12 Claim Accepted Payout Pending\r\n        _pushStatus(0, 0); //13 Claim Accepted No Payout \r\n        _pushStatus(0, 0); //14 Claim Accepted Payout Done\r\n    }\r\n\r\n    /**\r\n     * @dev Sets Maximum time(in seconds) for which claim assessment voting is open\r\n     */ \r\n    function _setMaxVotingTime(uint _time) internal {\r\n        maxVotingTime = _time;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets Minimum time(in seconds) for which claim assessment voting is open\r\n     */ \r\n    function _setMinVotingTime(uint _time) internal {\r\n        minVotingTime = _time;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets Minimum vote threshold required\r\n     */ \r\n    function _setMinVoteThreshold(uint val) internal {\r\n        minVoteThreshold = val;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets Maximum vote threshold required\r\n     */ \r\n    function _setMaxVoteThreshold(uint val) internal {\r\n        maxVoteThreshold = val;\r\n    }\r\n    \r\n    /**\r\n     *  @dev Sets the value considered as Majority Consenus in voting\r\n     */ \r\n    function _setMajorityConsensus(uint val) internal {\r\n        majorityConsensus = val;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the payout retry time\r\n     */ \r\n    function _setPayoutRetryTime(uint _time) internal {\r\n        payoutRetryTime = _time;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets percentage of reward given for claim assessment\r\n     */ \r\n    function _setClaimRewardPerc(uint _val) internal {\r\n\r\n        claimRewardPerc = _val;\r\n    }\r\n  \r\n    /** \r\n     * @dev Sets the time for which claim is deposited.\r\n     */ \r\n    function _setClaimDepositTime(uint _time) internal {\r\n\r\n        claimDepositTime = _time;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets number of days claim assessment will be paused\r\n     */ \r\n    function _setPauseDaysCA(uint val) internal {\r\n        pauseDaysCA = val;\r\n    }\r\n}\r\n"},"INXMMaster.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract INXMMaster {\r\n\r\n    address public tokenAddress;\r\n\r\n    address public owner;\r\n\r\n\r\n    uint public pauseTime;\r\n\r\n    function delegateCallBack(bytes32 myid) external;\r\n\r\n    function masterInitialized() public view returns(bool);\r\n    \r\n    function isInternal(address _add) public view returns(bool);\r\n\r\n    function isPause() public view returns(bool check);\r\n\r\n    function isOwner(address _add) public view returns(bool);\r\n\r\n    function isMember(address _add) public view returns(bool);\r\n    \r\n    function checkIsAuthToGoverned(address _add) public view returns(bool);\r\n\r\n    function updatePauseTime(uint _time) public;\r\n\r\n    function dAppLocker() public view returns(address _add);\r\n\r\n    function dAppToken() public view returns(address _add);\r\n\r\n    function getLatestAddress(bytes2 _contractName) public view returns(address payable contractAddress);\r\n}"},"Iupgradable.sol":{"content":"pragma solidity 0.5.7;\r\n\r\nimport \"./INXMMaster.sol\";\r\n\r\n\r\ncontract Iupgradable {\r\n\r\n    INXMMaster public ms;\r\n    address public nxMasterAddress;\r\n\r\n    modifier onlyInternal {\r\n        require(ms.isInternal(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier isMemberAndcheckPause {\r\n        require(ms.isPause() == false \u0026\u0026 ms.isMember(msg.sender) == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(ms.isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier checkPause {\r\n        require(ms.isPause() == false);\r\n        _;\r\n    }\r\n\r\n    modifier isMember {\r\n        require(ms.isMember(msg.sender), \"Not member\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function  changeDependentContractAddress() public;\r\n\r\n    /**\r\n     * @dev change master address\r\n     * @param _masterAddress is the new address\r\n     */\r\n    function changeMasterAddress(address _masterAddress) public {\r\n        if (address(ms) != address(0)) {\r\n            require(address(ms) == msg.sender, \"Not master\");\r\n        }\r\n        ms = INXMMaster(_masterAddress);\r\n        nxMasterAddress = _masterAddress;\r\n    }\r\n\r\n}\r\n"},"SafeMath.sol":{"content":"pragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n"}}
