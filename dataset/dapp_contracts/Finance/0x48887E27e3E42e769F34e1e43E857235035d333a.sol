{{
  "language": "Solidity",
  "sources": {
    "temp-contracts/distribution/StakingRewardsFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/* ==========  External Interfaces  ========== */\nimport \"@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* ==========  External Libraries  ========== */\nimport \"@indexed-finance/proxies/contracts/SaltyLib.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/* ==========  External Inheritance  ========== */\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/* ==========  Internal Inheritance  ========== */\nimport \"../interfaces/IStakingRewardsFactory.sol\";\n\n\ncontract StakingRewardsFactory is Ownable, IStakingRewardsFactory {\n  using SafeMath for uint256;\n\n/* ==========  Constants  ========== */\n\n  /**\n   * @dev Used to identify the implementation for staking rewards proxies.\n   */\n  bytes32 public override constant STAKING_REWARDS_IMPLEMENTATION_ID = keccak256(\n    \"StakingRewards.sol\"\n  );\n\n/* ==========  Immutables  ========== */\n\n  /**\n   * @dev Address of the pool factory - used to verify staking token eligibility.\n   */\n  address public override immutable poolFactory;\n\n  /**\n   * @dev The address of the proxy manager - used to deploy staking pools.\n   */\n  address public override immutable proxyManager;\n\n  /**\n   * @dev The address of the token to distribute.\n   */\n  address public override immutable rewardsToken;\n\n  /**\n   * @dev The address of the Uniswap factory - used to compute the addresses\n   * of Uniswap pairs eligible for distribution.\n   */\n  address public override immutable uniswapFactory;\n\n  /**\n   * @dev The address of the wrapped ether token - used to identify\n   * Uniswap pairs eligible for distribution.\n   */\n  address public override immutable weth;\n\n  /**\n   * @dev Timestamp at which staking begins.\n   */\n  uint256 public override immutable stakingRewardsGenesis;\n\n/* ==========  Events  ========== */\n\n  event UniswapStakingRewardsAdded(\n    address indexPool,\n    address stakingToken,\n    address stakingRewards\n  );\n\n  event IndexPoolStakingRewardsAdded(\n    address stakingToken,\n    address stakingRewards\n  );\n\n/* ==========  Structs  ========== */\n\n  enum StakingTokenType { NDX_POOL, NDX_POOL_UNISWAP_PAIR }\n\n  struct StakingRewardsInfo {\n    StakingTokenType tokenType;\n    address stakingRewards;\n    uint88 rewardAmount;\n  }\n\n/* ==========  Storage  ========== */\n\n  /**\n   * @dev The staking tokens for which a rewards contract has been deployed.\n   */\n  address[] public override stakingTokens;\n\n  /**\n   * @dev Rewards info by staking token.\n   */\n  mapping(address => StakingRewardsInfo) public stakingRewardsInfoByStakingToken;\n\n/* ==========  Constructor  ========== */\n\n  constructor(\n    address rewardsToken_,\n    uint256 stakingRewardsGenesis_,\n    address proxyManager_,\n    address poolFactory_,\n    address uniswapFactory_,\n    address weth_\n  ) public Ownable() {\n    rewardsToken = rewardsToken_;\n    require(\n      stakingRewardsGenesis_ >= block.timestamp,\n      \"StakingRewardsFactory::constructor: genesis too soon\"\n    );\n    stakingRewardsGenesis = stakingRewardsGenesis_;\n    proxyManager = proxyManager_;\n    poolFactory = poolFactory_;\n    uniswapFactory = uniswapFactory_;\n    weth = weth_;\n  }\n\n/* ==========  Pool Deployment (Permissioned)  ========== */\n\n  /**\n   * @dev Deploys a staking pool for the LP token of an index pool.\n   *\n   * Verifies that the staking token is the address of a pool deployed by the\n   * Indexed pool factory.\n   */\n  function deployStakingRewardsForPool(\n    address indexPool,\n    uint88 rewardAmount,\n    uint256 rewardsDuration\n  )\n    external\n    override\n    onlyOwner\n    returns (address)\n  {\n\n    StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[indexPool];\n    require(\n      info.stakingRewards == address(0),\n      \"StakingRewardsFactory::deployStakingRewardsForPool: Already deployed\"\n    );\n    require(\n      IPoolFactory(poolFactory).isRecognizedPool(indexPool),\n      \"StakingRewardsFactory::deployStakingRewardsForPool: Not an index pool.\"\n    );\n    bytes32 stakingRewardsSalt = keccak256(abi.encodePacked(indexPool));\n    address stakingRewards = IDelegateCallProxyManager(proxyManager).deployProxyManyToOne(\n      STAKING_REWARDS_IMPLEMENTATION_ID,\n      stakingRewardsSalt\n    );\n    IStakingRewards(stakingRewards).initialize(indexPool, rewardsDuration);\n    info.stakingRewards = stakingRewards;\n    info.rewardAmount = rewardAmount;\n    info.tokenType = StakingTokenType.NDX_POOL;\n    stakingTokens.push(indexPool);\n    emit IndexPoolStakingRewardsAdded(indexPool, stakingRewards);\n    return stakingRewards;\n  }\n\n  /**\n   * @dev Deploys staking rewards for the LP token of the Uniswap pair between an\n   * index pool token and WETH.\n   *\n   * Verifies that the LP token is the address of a pool deployed by the\n   * Indexed pool factory, then uses the address of the Uniswap pair between\n   * it and WETH as the staking token.\n   */\n  function deployStakingRewardsForPoolUniswapPair(\n    address indexPool,\n    uint88 rewardAmount,\n    uint256 rewardsDuration\n  )\n    external\n    override\n    onlyOwner\n  {\n    require(\n      IPoolFactory(poolFactory).isRecognizedPool(indexPool),\n      \"StakingRewardsFactory::deployStakingRewardsForPoolUniswapPair: Not an index pool.\"\n    );\n\n    address pairAddress = UniswapV2AddressLibrary.pairFor(\n      address(uniswapFactory),\n      indexPool,\n      weth\n    );\n\n    StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[pairAddress];\n    require(\n      info.stakingRewards == address(0),\n      \"StakingRewardsFactory::deployStakingRewardsForPoolUniswapPair: Already deployed\"\n    );\n\n    bytes32 stakingRewardsSalt = keccak256(abi.encodePacked(pairAddress));\n    address stakingRewards = IDelegateCallProxyManager(proxyManager).deployProxyManyToOne(\n      STAKING_REWARDS_IMPLEMENTATION_ID,\n      stakingRewardsSalt\n    );\n\n    IStakingRewards(stakingRewards).initialize(pairAddress, rewardsDuration);\n    info.stakingRewards = stakingRewards;\n    info.rewardAmount = rewardAmount;\n    info.tokenType = StakingTokenType.NDX_POOL_UNISWAP_PAIR;\n    stakingTokens.push(pairAddress);\n    emit UniswapStakingRewardsAdded(indexPool, pairAddress, stakingRewards);\n  }\n\n/* ==========  Rewards Distribution  ========== */\n\n  /**\n   * @dev Notifies all tokens of their pending rewards.\n   */\n  function notifyRewardAmounts() public override {\n    require(\n      stakingTokens.length > 0,\n      \"StakingRewardsFactory::notifyRewardAmounts: called before any deploys\"\n    );\n    for (uint i = 0; i < stakingTokens.length; i++) {\n      notifyRewardAmount(stakingTokens[i]);\n    }\n  }\n\n  /**\n   * @dev Notifies the staking pool for the token `stakingToken` of its pending rewards.\n   */\n  function notifyRewardAmount(address stakingToken) public override {\n    require(\n      block.timestamp >= stakingRewardsGenesis,\n      \"StakingRewardsFactory::notifyRewardAmount: Not ready\"\n    );\n\n    StakingRewardsInfo storage info = _getRewards(stakingToken);\n\n    if (info.rewardAmount > 0) {\n      uint256 rewardAmount = info.rewardAmount;\n      info.rewardAmount = 0;\n\n      require(\n        IERC20(rewardsToken).transfer(info.stakingRewards, rewardAmount),\n        \"StakingRewardsFactory::notifyRewardAmount: Transfer failed\"\n      );\n      IStakingRewards(info.stakingRewards).notifyRewardAmount(rewardAmount);\n    }\n  }\n\n  /**\n   * @dev Increases the staking rewards on the staking pool for `stakingToken`\n   * and notify the pool of the new rewards.\n   * Only allowed when the current rewards are zero and the staking pool has\n   * finished its last rewards period.\n   */\n  function increaseStakingRewards(address stakingToken, uint88 rewardAmount) external override onlyOwner {\n    require(rewardAmount > 0, \"StakingRewardsFactory::increaseStakingRewards: Can not add 0 rewards.\");\n    StakingRewardsInfo storage info = _getRewards(stakingToken);\n    require(\n      info.rewardAmount == 0,\n      \"StakingRewardsFactory::increaseStakingRewards: Can not add rewards while pool still has pending rewards.\"\n    );\n    IStakingRewards pool = IStakingRewards(info.stakingRewards);\n    require(\n      block.timestamp >= pool.periodFinish(),\n      \"StakingRewardsFactory::increaseStakingRewards: Previous rewards period must be complete to add rewards.\"\n    );\n    require(\n      IERC20(rewardsToken).transfer(address(pool), rewardAmount),\n      \"StakingRewardsFactory::increaseStakingRewards: Transfer failed\"\n    );\n    pool.notifyRewardAmount(rewardAmount);\n  }\n\n  /**\n   * @dev Updates the rewards duration on the staking pool for the token `stakingToken`.\n   */\n  function setRewardsDuration(address stakingToken, uint256 newDuration) external override onlyOwner {\n    StakingRewardsInfo storage info = _getRewards(stakingToken);\n    IStakingRewards(info.stakingRewards).setRewardsDuration(newDuration);\n  }\n\n/* ==========  Token Recovery  ========== */\n\n  /**\n   * @dev Recovers the balance of `tokenAddress` on the staking pool for the token `stakingToken`.\n   * The token to recover must not be the staking token or the rewards token for that pool.\n   * The balance in `tokenAddress` owned by the pool will be sent to the owner of the rewards factory.\n   * @param stakingToken Address of the staking token whose staking pool the tokens will be recovered from.\n   * @param tokenAddress Address of the token to recover from the staking pool.\n   */\n  function recoverERC20(address stakingToken, address tokenAddress) external override {\n    StakingRewardsInfo storage info = _getRewards(stakingToken);\n    IStakingRewards(info.stakingRewards).recoverERC20(tokenAddress, owner());\n  }\n\n/* ==========  Queries  ========== */\n\n  function getStakingTokens() external override view returns (address[] memory) {\n    return stakingTokens;\n  }\n\n  function getStakingRewards(address stakingToken) external override view returns (address) {\n    StakingRewardsInfo storage info = _getRewards(stakingToken);\n    return info.stakingRewards;\n  }\n\n  function computeStakingRewardsAddress(address stakingToken) external override view returns (address) {\n    bytes32 stakingRewardsSalt = keccak256(abi.encodePacked(stakingToken));\n    return SaltyLib.computeProxyAddressManyToOne(\n      proxyManager,\n      address(this),\n      STAKING_REWARDS_IMPLEMENTATION_ID,\n      stakingRewardsSalt\n    );\n  }\n\n  /* ==========  Internal  ========== */\n  function _getRewards(address stakingToken) internal view returns (StakingRewardsInfo storage) {\n    StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[stakingToken];\n    require(\n      info.stakingRewards != address(0),\n      \"StakingRewardsFactory::_getRewards: Not deployed\"\n    );\n    return info;\n  }\n}\n\n\nlibrary UniswapV2AddressLibrary {\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  function calculatePair(\n    address factory,\n    address token0,\n    address token1\n  ) internal pure returns (address pair) {\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n          )\n        )\n      )\n    );\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = calculatePair(factory, token0, token1);\n  }\n}\n\n\ninterface IPoolFactory {\n  function isRecognizedPool(address pool) external view returns (bool);\n}\n\n\ninterface IStakingRewards {\n  function initialize(address stakingToken, uint256 rewardsDuration) external;\n\n  function recoverERC20(address tokenAddress, address recipient) external;\n\n  function notifyRewardAmount(uint256 reward) external;\n\n  function setRewardsDuration(uint256 rewardsDuration) external;\n\n  function periodFinish() external view returns (uint256);\n}"
    },
    "@indexed-finance/proxies/contracts/interfaces/IDelegateCallProxyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Contract that manages deployment and upgrades of delegatecall proxies.\n *\n * An implementation identifier can be created on the proxy manager which is\n * used to specify the logic address for a particular contract type, and to\n * upgrade the implementation as needed.\n *\n * A one-to-one proxy is a single proxy contract with an upgradeable implementation\n * address.\n *\n * A many-to-one proxy is a single upgradeable implementation address that may be\n * used by many proxy contracts.\n */\ninterface IDelegateCallProxyManager {\n/* ==========  Events  ========== */\n\n  event DeploymentApprovalGranted(address deployer);\n  event DeploymentApprovalRevoked(address deployer);\n\n  event ManyToOne_ImplementationCreated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ImplementationUpdated(\n    bytes32 implementationID,\n    address implementationAddress\n  );\n\n  event ManyToOne_ProxyDeployed(\n    bytes32 implementationID,\n    address proxyAddress\n  );\n\n  event OneToOne_ProxyDeployed(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n  event OneToOne_ImplementationUpdated(\n    address proxyAddress,\n    address implementationAddress\n  );\n\n/* ==========  Controls  ========== */\n\n  /**\n   * @dev Allows `deployer` to deploy many-to-one proxies.\n   */\n  function approveDeployer(address deployer) external;\n\n  /**\n   * @dev Prevents `deployer` from deploying many-to-one proxies.\n   */\n  function revokeDeployerApproval(address deployer) external;\n\n/* ==========  Implementation Management  ========== */\n\n  /**\n   * @dev Creates a many-to-one proxy relationship.\n   *\n   * Deploys an implementation holder contract which stores the\n   * implementation address for many proxies. The implementation\n   * address can be updated on the holder to change the runtime\n   * code used by all its proxies.\n   *\n   * @param implementationID ID for the implementation, used to identify the\n   * proxies that use it. Also used as the salt in the create2 call when\n   * deploying the implementation holder contract.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function createManyToOneProxyRelationship(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Lock the current implementation for `proxyAddress` so that it can never be upgraded again.\n   */\n  function lockImplementationManyToOne(bytes32 implementationID) external;\n\n  /**\n   * @dev Lock the current implementation for `proxyAddress` so that it can never be upgraded again.\n   */\n  function lockImplementationOneToOne(address proxyAddress) external;\n\n  /**\n   * @dev Updates the implementation address for a many-to-one\n   * proxy relationship.\n   *\n   * @param implementationID Identifier for the implementation.\n   * @param implementation Address with the runtime code the proxies\n   * should use.\n   */\n  function setImplementationAddressManyToOne(\n    bytes32 implementationID,\n    address implementation\n  ) external;\n\n  /**\n   * @dev Updates the implementation address for a one-to-one proxy.\n   *\n   * Note: This could work for many-to-one as well if the caller\n   * provides the implementation holder address in place of the\n   * proxy address, as they use the same access control and update\n   * mechanism.\n   *\n   * @param proxyAddress Address of the deployed proxy\n   * @param implementation Address with the runtime code for\n   * the proxy to use.\n   */\n  function setImplementationAddressOneToOne(\n    address proxyAddress,\n    address implementation\n  ) external;\n\n/* ==========  Proxy Deployment  ========== */\n\n  /**\n   * @dev Deploy a proxy contract with a one-to-one relationship\n   * with its implementation.\n   *\n   * The proxy will have its own implementation address which can\n   * be updated by the proxy manager.\n   *\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   * @param implementation Address of the contract with the runtime\n   * code that the proxy should use.\n   */\n  function deployProxyOneToOne(\n    bytes32 suppliedSalt,\n    address implementation\n  ) external returns(address proxyAddress);\n\n  /**\n   * @dev Deploy a proxy with a many-to-one relationship with its implemenation.\n   *\n   * The proxy will call the implementation holder for every transaction to\n   * determine the address to use in calls.\n   *\n   * @param implementationID Identifier for the proxy's implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deployProxyManyToOne(\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external returns(address proxyAddress);\n\n/* ==========  Queries  ========== */\n\n  /**\n   * @dev Returns a boolean stating whether `implementationID` is locked.\n   */\n  function isImplementationLocked(bytes32 implementationID) external view returns (bool);\n\n  /**\n   * @dev Returns a boolean stating whether `proxyAddress` is locked.\n   */\n  function isImplementationLocked(address proxyAddress) external view returns (bool);\n\n  /**\n   * @dev Returns a boolean stating whether `deployer` is allowed to deploy many-to-one\n   * proxies.\n   */\n  function isApprovedDeployer(address deployer) external view returns (bool);\n\n  /**\n   * @dev Queries the temporary storage value `_implementationHolder`.\n   * This is used in the constructor of the many-to-one proxy contract\n   * so that the create2 address is static (adding constructor arguments\n   * would change the codehash) and the implementation holder can be\n   * stored as a constant.\n   */\n  function getImplementationHolder() external view returns (address);\n\n  /**\n   * @dev Returns the address of the implementation holder contract\n   * for `implementationID`.\n   */\n  function getImplementationHolder(bytes32 implementationID) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy requested\n   * by `originator` using `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address originator,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(bytes32 implementationID) external view returns (address);\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@indexed-finance/proxies/contracts/SaltyLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n/* ---  External Libraries  --- */\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\n\n/* ---  Proxy Contracts  --- */\nimport { CodeHashes } from \"./CodeHashes.sol\";\n\n\n/**\n * @dev Library for computing create2 salts and addresses for proxies\n * deployed by `DelegateCallProxyManager`.\n *\n * Because the proxy factory is meant to be used by multiple contracts,\n * we use a salt derivation pattern that includes the address of the\n * contract that requested the proxy deployment, a salt provided by that\n * contract and the implementation ID used (for many-to-one proxies only).\n */\nlibrary SaltyLib {\n/* ---  Salt Derivation  --- */\n\n  /**\n   * @dev Derives the create2 salt for a many-to-one proxy.\n   *\n   * Many different contracts in the Indexed framework may use the\n   * same implementation contract, and they all use the same init\n   * code, so we derive the actual create2 salt from a combination\n   * of the implementation ID, the address of the account requesting\n   * deployment and the user-supplied salt.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deriveManyToOneSalt(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(\n      abi.encodePacked(\n        originator,\n        implementationID,\n        suppliedSalt\n      )\n    );\n  }\n\n  /**\n   * @dev Derives the create2 salt for a one-to-one proxy.\n   *\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function deriveOneToOneSalt(\n    address originator,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(originator, suppliedSalt));\n  }\n\n/* ---  Address Derivation  --- */\n\n  /**\n   * @dev Computes the create2 address for a one-to-one proxy deployed\n   * by `deployer` (the factory) when requested by `originator` using\n   * `suppliedSalt`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param originator Address of the account requesting deployment.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n   */\n  function computeProxyAddressOneToOne(\n    address deployer,\n    address originator,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 salt = deriveOneToOneSalt(originator, suppliedSalt);\n    return Create2.computeAddress(salt, CodeHashes.ONE_TO_ONE_CODEHASH, deployer);\n  }\n\n  /**\n   * @dev Computes the create2 address for a many-to-one proxy for the\n   * implementation `implementationID` deployed by `deployer` (the factory)\n   * when requested by `originator` using `suppliedSalt`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param originator Address of the account requesting deployment.\n   * @param implementationID The identifier for the contract implementation.\n   * @param suppliedSalt Salt provided by the account requesting deployment.\n  */\n  function computeProxyAddressManyToOne(\n    address deployer,\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  )\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 salt = deriveManyToOneSalt(\n      originator,\n      implementationID,\n      suppliedSalt\n    );\n    return Create2.computeAddress(salt, CodeHashes.MANY_TO_ONE_CODEHASH, deployer);\n  }\n\n  /**\n   * @dev Computes the create2 address of the implementation holder\n   * for `implementationID`.\n   *\n   * @param deployer Address of the proxy factory.\n   * @param implementationID The identifier for the contract implementation.\n  */\n  function computeHolderAddressManyToOne(\n    address deployer,\n    bytes32 implementationID\n  )\n    internal\n    pure\n    returns (address)\n  {\n    return Create2.computeAddress(\n      implementationID,\n      CodeHashes.IMPLEMENTATION_HOLDER_CODEHASH,\n      deployer\n    );\n  }\n}"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint256(_data));\n    }\n}\n"
    },
    "@indexed-finance/proxies/contracts/CodeHashes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Because we use the code hashes of the proxy contracts for proxy address\n * derivation, it is important that other packages have access to the correct\n * values when they import the salt library.\n */\nlibrary CodeHashes {\n  bytes32 internal constant ONE_TO_ONE_CODEHASH = 0x63d9f7b5931b69188c8f6b806606f25892f1bb17b7f7e966fe3a32c04493aee4;\n  bytes32 internal constant MANY_TO_ONE_CODEHASH = 0xa035ad05a1663db5bfd455b99cd7c6ac6bd49269738458eda140e0b78ed53f79;\n  bytes32 internal constant IMPLEMENTATION_HOLDER_CODEHASH = 0x11c370493a726a0ffa93d42b399ad046f1b5a543b6e72f1a64f1488dc1c58f2c;\n}"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "temp-contracts/interfaces/IStakingRewardsFactory.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ninterface IStakingRewardsFactory {\n/* ==========  Constants  ========== */\n\n  function STAKING_REWARDS_IMPLEMENTATION_ID() external pure returns (bytes32);\n\n/* ==========  Immutables  ========== */\n\n  function poolFactory() external view returns (address);\n\n  function proxyManager() external view returns (address);\n\n  function rewardsToken() external view returns (address);\n\n  function uniswapFactory() external view returns (address);\n\n  function weth() external view returns (address);\n\n  function stakingRewardsGenesis() external view returns (uint256);\n\n/* ==========  Storage  ========== */\n\n  function stakingTokens(uint256) external view returns (address);\n\n/* ==========  Pool Deployment (Permissioned)  ==========  */\n\n  function deployStakingRewardsForPool(address indexPool, uint88 rewardAmount, uint256 rewardsDuration) external returns (address);\n\n  function deployStakingRewardsForPoolUniswapPair(address indexPool, uint88 rewardAmount, uint256 rewardsDuration) external;\n\n/* ==========  Rewards  ========== */\n\n  function notifyRewardAmounts() external;\n\n  function notifyRewardAmount(address stakingToken) external;\n\n  function increaseStakingRewards(address stakingToken, uint88 rewardAmount) external;\n\n  function setRewardsDuration(address stakingToken, uint256 newDuration) external;\n\n/* ==========  Token Recovery  ========== */\n\n  function recoverERC20(address stakingToken, address tokenAddress) external;\n\n/* ==========  Queries  ========== */\n\n  function getStakingTokens() external view returns (address[] memory);\n\n  function getStakingRewards(address stakingToken) external view returns (address);\n\n  function computeStakingRewardsAddress(address stakingToken) external view returns (address);\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}
