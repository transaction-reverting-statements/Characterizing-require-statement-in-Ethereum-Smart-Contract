{{
  "language": "Solidity",
  "sources": {
    "contracts/NNRewardPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./iface/INestPool.sol\";\nimport \"./lib/SafeERC20.sol\";\nimport './lib/TransferHelper.sol';\nimport \"./iface/INestMining.sol\";\nimport \"./iface/INNRewardPool.sol\";\n\n/// @title NNRewardPool\n/// @author Inf Loop - \n/// @author Paradox  - \n\n/// @notice The NNRewardPool contract distributes the mining rewards,\n///     15% share of the amount of nest-token produced by miners\n/// @dev The nest-tokens are put in NestPool. This contract only traces \n///     the sum-amount of all of the rewards (nest-token)\n///   - NNToken is pre-deployed in Nest v3.0, so we should connect (legacy)\n///       with NNRewardPool. Whenever a NN holder transfers NN token to another,\n///       NNToken will call back NNRewardPool.nodeCount() to settle rewards (decisively)\n///       for both sender and receiver.\n///   - After upgrading, NNRewardPool will count rewards from zero. Any NN holder should\n///       claim rewards that had been issued before upgrading from the old contract. Old\n///       data about NN rewards will be dropped in this contract, while it can also accessible\n///       through OLD (Nest v3.0) contracts.\ncontract NNRewardPool is INNRewardPool {\n    using SafeMath for uint256;\n\n    /* ========== STATE ============== */\n\n    uint8   public flag;     // | 1: active \n                            // | 0: uninitialized\n                            // | 2: shutdown\n\n    uint8   constant NNREWARD_FLAG_UNINITIALIZED    = 0;\n    uint8   constant NNREWARD_FLAG_ACTIVE           = 1;\n    uint8   constant NNREWARD_FLAG_PAUSED           = 2;\n\n    uint256 public rewardSum;\n    uint256 public totalSupplyNN;\n\n    /// @dev From nest-node address to checkpoints of reward-sum\n    mapping(address => uint256) public rewardSumCheckpoint;\n\n    /* ========== ADDRESSES ============== */\n\n    address public C_NNToken;\n    address public C_NestToken;\n    address public C_NestPool;\n    address public C_NestMining;\n\n    address public governance;\n\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /// @notice Constructor of NNRewardPool contract\n    /// @dev The NNToken contract was created on the Ethereum mainnet \n    /// @param NestPool The address of NestPool Contract\n    /// @param NNToken The address of NestNode Token Contract\n    constructor(address NestPool, address NNToken) public\n    {\n        C_NestPool = NestPool;\n        C_NNToken = NNToken;\n        totalSupplyNN = uint128(ERC20(C_NNToken).totalSupply());\n        governance = msg.sender;\n        flag = NNREWARD_FLAG_UNINITIALIZED;\n    }\n\n    function start() external onlyGovernance\n    {\n        require(flag == NNREWARD_FLAG_UNINITIALIZED, \"Nest:NTC:!flag\");\n\n        flag = NNREWARD_FLAG_ACTIVE;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyBy(address _account)\n    {\n        require(msg.sender == _account, \"Nest:NN:!Auth\");\n        _;\n    }\n\n    modifier noContract() \n    {\n        require(address(msg.sender) == address(tx.origin), \"Nest:NN:BAN(contract)\");\n        _;\n    }\n\n    modifier onlyGovernance() \n    {\n        require(msg.sender == governance, \"Nest:NN:!governance\");\n        _;\n    }\n\n    modifier onlyGovOrBy(address _account)\n    {\n        if (msg.sender != governance) { \n            require(msg.sender == _account,\n                \"Nest:NN:!Auth\");\n        }\n        _;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    /// @dev To ensure that all of governance-addresses be consistent, every contract\n    ///        besides NestPool must load newest `governance` from NestPool.\n    function loadGovernance() override external \n    { \n        governance = INestPool(C_NestPool).governance();\n    }\n\n    /// @dev The function loads all nest-contracts, it is supposed to be called by NestPool\n    function loadContracts() override external onlyGovOrBy(C_NestPool)\n    {\n        C_NestToken = INestPool(C_NestPool).addrOfNestToken();\n        C_NNToken = INestPool(C_NestPool).addrOfNNToken();\n        C_NestMining = INestPool(C_NestPool).addrOfNestMining();    \n\n    }\n\n    /// @dev Stop service for emergency\n    function pause() external onlyGovernance\n    {\n        require(flag == NNREWARD_FLAG_ACTIVE, \"Nest:NN:!flag\");\n        flag = NNREWARD_FLAG_PAUSED;\n        emit FlagSet(address(msg.sender), uint256(NNREWARD_FLAG_PAUSED));\n    }\n\n    /// @dev Resume service \n    function resume() external onlyGovernance\n    {\n        require(flag == NNREWARD_FLAG_PAUSED, \"Nest:NN:!flag\");\n        flag = NNREWARD_FLAG_ACTIVE;\n        emit FlagSet(address(msg.sender), uint256(NNREWARD_FLAG_ACTIVE));\n    }\n\n    /* ========== ADDING REWARDS ========== */\n\n\n    /// @notice Add rewards for Nest-Nodes, only NestMining (contract) are allowed\n    /// @dev  The rewards need to pull from NestPool\n    /// @param _amount The amount of Nest token as the rewards to each nest-node\n    function addNNReward(uint256 _amount) override external onlyBy(C_NestMining)\n    {\n        if (_amount > 0) {\n            uint256 _newSum = uint256(rewardSum).add(_amount);\n            rewardSum = uint128(_newSum);\n            emit NNRewardAdded(_amount, _newSum);\n        }\n        return;\n    }\n\n    // /// @dev The updator is to update the sum of NEST tokens mined in NestMining\n    // function updateNNReward() external\n    // {\n    //     require(flag == NNREWARD_FLAG_ACTIVE, \"Nest:NN:!flag\");\n\n    //     uint256 _allMined = INestMining(C_NestMining).minedNestAmount();\n    //     if (_allMined > rewardSum) {\n    //         uint256 _amount = _allMined.mul(NN_REWARD_PERCENTAGE).div(100).sub(rewardSum);\n    //         uint256 _newSum = uint256(rewardSum).add(_amount);\n    //         rewardSum = uint128(_newSum);\n    //         emit NNRewardAdded(_amount, _newSum);\n    //     }\n    // }\n\n    // modifier updateNNReward1()\n    // {\n    //     require(flag == NNREWARD_FLAG_ACTIVE, \"Nest:NN:!flag\");\n\n    //     uint256 _allMined = INestMining(C_NestMining).minedNestAmount();\n    //     if (_allMined > rewardSum) {\n    //         uint256 _amount = _allMined.mul(NN_REWARD_PERCENTAGE).div(100).sub(rewardSum);\n    //         uint256 _newSum = uint256(rewardSum).add(_amount);\n    //         rewardSum = uint128(_newSum);\n    //         emit NNRewardAdded(_amount, _newSum);\n    //     }\n    //    _;\n    // }\n\n    /* ========== CLAIM/SETTLEMENT ========== */\n\n    /// @notice Claim rewards by Nest-Nodes\n    /// @dev The rewards need to pull from NestPool\n    function claimNNReward() override external noContract \n    {\n        require(flag == NNREWARD_FLAG_ACTIVE, \"Nest:NN:!flag\");\n\n        uint256 blnc =  ERC20(C_NNToken).balanceOf(address(msg.sender));\n        require(blnc > 0, \"Nest:NN:!(NNToken)\");\n        uint256 total = totalSupplyNN;\n        uint256 sum = rewardSum;\n        uint256 reward = sum.sub(rewardSumCheckpoint[address(msg.sender)]);\n        uint256 share = reward.mul(blnc).div(total);\n\n        rewardSumCheckpoint[address(msg.sender)] = sum;\n        emit NNRewardClaimed(address(msg.sender), share);\n     \n        INestPool(C_NestPool).withdrawNest(address(this), share);\n        require(ERC20(C_NestToken).transfer(address(msg.sender), share), \"Nest:NN:!TRANS\");\n        \n        return;\n    }\n\n    /// @notice Settle rewards for two NN holders\n    /// @dev The function is for callback from NNToken. It is banned for contracts.\n    /// @param from The address of the NN sender \n    /// @param to The address of the NN receiver \n    function settleNNReward(address from, address to) internal\n    {\n        require(flag == NNREWARD_FLAG_ACTIVE, \"Nest:NN:!flag\");\n\n        uint256 fromBlnc = ERC20(C_NNToken).balanceOf(address(from));\n        require (fromBlnc > 0, \"Nest:NN:!(fromBlnc)\");\n        uint256 sum = rewardSum;\n        uint256 total = totalSupplyNN;\n\n        uint256 fromReward = sum.sub(rewardSumCheckpoint[from]).mul(fromBlnc).div(total);      \n        rewardSumCheckpoint[from] = sum;      \n       \n        uint256 toBlnc = ERC20(C_NNToken).balanceOf(address(to));\n        uint256 toReward = sum.sub(rewardSumCheckpoint[to]).mul(toBlnc).div(total);\n        rewardSumCheckpoint[to] = sum;\n        \n        if (fromReward > 0) {\n            INestPool(C_NestPool).withdrawNest(address(this), fromReward);\n            require(ERC20(C_NestToken).transfer(from, fromReward), \"Nest:NN:!TRANS\");\n            emit NNRewardClaimed(from, uint128(fromReward));\n        }\n\n        if (toReward > 0) { \n            INestPool(C_NestPool).withdrawNest(address(this), toReward);\n            require(ERC20(C_NestToken).transfer(to, toReward), \"Nest:NN:!TRANS\");\n            emit NNRewardClaimed(to, uint128(toReward));\n        }\n\n        return;\n    }\n\n    /// @dev The callback function called by NNToken.transfer()\n    /// @param fromAdd The address of 'from' to transfer\n    /// @param toAdd The address of 'to' to transfer\n    function nodeCount(address fromAdd, address toAdd) \n        override\n        external\n        onlyBy(address(C_NNToken)) \n    {\n        settleNNReward(fromAdd, toAdd);\n        return;\n    }\n\n    /// @notice Show the amount of rewards unclaimed\n    /// @return reward The reward of a NN holder\n    function unclaimedNNReward() override external view returns (uint256 reward) \n    {\n        uint256 blnc = ERC20(C_NNToken).balanceOf(address(msg.sender));\n        uint256 sum = uint256(rewardSum);\n        uint256 total = uint256(totalSupplyNN);\n     \n        reward = sum.sub(rewardSumCheckpoint[address(msg.sender)]).mul(blnc).div(total);\n    }\n\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n\n    function div(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"ds-math-div-zero\");\n        z = x / y;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    }\n}"
    },
    "contracts/iface/INestPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport \"../lib/SafeERC20.sol\";\n\ninterface INestPool {\n\n    // function getNTokenFromToken(address token) view external returns (address);\n    // function setNTokenToToken(address token, address ntoken) external; \n\n    function addNest(address miner, uint256 amount) external;\n    function addNToken(address contributor, address ntoken, uint256 amount) external;\n\n    function depositEth(address miner) external payable;\n    function depositNToken(address miner,  address from, address ntoken, uint256 amount) external;\n\n    function freezeEth(address miner, uint256 ethAmount) external; \n    function unfreezeEth(address miner, uint256 ethAmount) external;\n\n    function freezeNest(address miner, uint256 nestAmount) external;\n    function unfreezeNest(address miner, uint256 nestAmount) external;\n\n    function freezeToken(address miner, address token, uint256 tokenAmount) external; \n    function unfreezeToken(address miner, address token, uint256 tokenAmount) external;\n\n    function freezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\n    function unfreezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\n\n    function getNTokenFromToken(address token) external view returns (address); \n    function setNTokenToToken(address token, address ntoken) external; \n\n    function withdrawEth(address miner, uint256 ethAmount) external;\n    function withdrawToken(address miner, address token, uint256 tokenAmount) external;\n\n    function withdrawNest(address miner, uint256 amount) external;\n    function withdrawEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\n    // function withdrawNToken(address miner, address ntoken, uint256 amount) external;\n    function withdrawNTokenAndTransfer(address miner, address ntoken, uint256 amount, address to) external;\n\n\n    function balanceOfNestInPool(address miner) external view returns (uint256);\n    function balanceOfEthInPool(address miner) external view returns (uint256);\n    function balanceOfTokenInPool(address miner, address token)  external view returns (uint256);\n\n    function addrOfNestToken() external view returns (address);\n    function addrOfNestMining() external view returns (address);\n    function addrOfNTokenController() external view returns (address);\n    function addrOfNNRewardPool() external view returns (address);\n    function addrOfNNToken() external view returns (address);\n    function addrOfNestStaking() external view returns (address);\n    function addrOfNestQuery() external view returns (address);\n    function addrOfNestDAO() external view returns (address);\n\n    function addressOfBurnedNest() external view returns (address);\n\n    function setGovernance(address _gov) external; \n    function governance() external view returns(address);\n    function initNestLedger(uint256 amount) external;\n    function drainNest(address to, uint256 amount, address gov) external;\n\n}"
    },
    "contracts/lib/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.6.12;\n\nimport \"./Address.sol\";\nimport \"./SafeMath.sol\";\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/lib/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/iface/INestMining.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/SafeERC20.sol\";\n\n\ninterface INestMining {\n    \n    struct Params {\n        uint8    miningEthUnit;     // = 10;\n        uint32   nestStakedNum1k;   // = 1;\n        uint8    biteFeeRate;       // = 1; \n        uint8    miningFeeRate;     // = 10;\n        uint8    priceDurationBlock; \n        uint8    maxBiteNestedLevel; // = 3;\n        uint8    biteInflateFactor;\n        uint8    biteNestInflateFactor;\n    }\n\n    function priceOf(address token) external view returns(uint256 ethAmount, uint256 tokenAmount, uint256 bn);\n    \n    function priceListOfToken(address token, uint8 num) external view returns(uint128[] memory data, uint256 bn);\n\n    // function priceOfTokenAtHeight(address token, uint64 atHeight) external view returns(uint256 ethAmount, uint256 tokenAmount, uint64 bn);\n\n    function latestPriceOf(address token) external view returns (uint256 ethAmount, uint256 tokenAmount, uint256 bn);\n\n    function priceAvgAndSigmaOf(address token) \n        external view returns (uint128, uint128, int128, uint32);\n\n    function minedNestAmount() external view returns (uint256);\n\n    /// @dev Only for governance\n    function loadContracts() external; \n    \n    function loadGovernance() external;\n\n    function upgrade() external;\n\n    function setup(uint32   genesisBlockNumber, uint128  latestMiningHeight, uint128  minedNestTotalAmount, Params calldata initParams) external;\n\n    function setParams1(uint128  latestMiningHeight, uint128  minedNestTotalAmount) external;\n}"
    },
    "contracts/iface/INNRewardPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n/// @title NNRewardPool\n/// @author Inf Loop - \n/// @author Paradox  - \n\ninterface INNRewardPool {\n    \n    /* [DEPRECATED]\n        uint256 constant DEV_REWARD_PERCENTAGE   = 5;\n        uint256 constant NN_REWARD_PERCENTAGE    = 15;\n        uint256 constant MINER_REWARD_PERCENTAGE = 80;\n    */\n\n    /// @notice Add rewards for Nest-Nodes, only governance or NestMining (contract) are allowed\n    /// @dev  The rewards need to pull from NestPool\n    /// @param _amount The amount of Nest token as the rewards to each nest-node\n    function addNNReward(uint256 _amount) external;\n\n    /// @notice Claim rewards by Nest-Nodes\n    /// @dev The rewards need to pull from NestPool\n    function claimNNReward() external ;  \n\n    /// @dev The callback function called by NNToken.transfer()\n    /// @param fromAdd The address of 'from' to transfer\n    /// @param toAdd The address of 'to' to transfer\n    function nodeCount(address fromAdd, address toAdd) external;\n\n    /// @notice Show the amount of rewards unclaimed\n    /// @return reward The reward of a NN holder\n    function unclaimedNNReward() external view returns (uint256 reward);\n\n    /// @dev Only for governance\n    function loadContracts() external; \n\n    /// @dev Only for governance\n    function loadGovernance() external; \n\n    /* ========== EVENTS ============== */\n\n    /// @notice When rewards are added to the pool\n    /// @param reward The amount of Nest Token\n    /// @param allRewards The snapshot of all rewards accumulated\n    event NNRewardAdded(uint256 reward, uint256 allRewards);\n\n    /// @notice When rewards are claimed by nodes \n    /// @param nnode The address of the nest node\n    /// @param share The amount of Nest Token claimed by the nest node\n    event NNRewardClaimed(address nnode, uint256 share);\n\n    /// @notice When flag of state is set by governance \n    /// @param gov The address of the governance\n    /// @param flag The value of the new flag\n    event FlagSet(address gov, uint256 flag);\n}"
    },
    "contracts/lib/Address.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.6.12;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{value:amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}
