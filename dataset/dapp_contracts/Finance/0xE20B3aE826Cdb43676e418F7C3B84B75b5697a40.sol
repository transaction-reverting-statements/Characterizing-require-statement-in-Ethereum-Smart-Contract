{"INXMMaster.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract INXMMaster {\r\n\r\n    address public tokenAddress;\r\n\r\n    address public owner;\r\n\r\n\r\n    uint public pauseTime;\r\n\r\n    function delegateCallBack(bytes32 myid) external;\r\n\r\n    function masterInitialized() public view returns(bool);\r\n    \r\n    function isInternal(address _add) public view returns(bool);\r\n\r\n    function isPause() public view returns(bool check);\r\n\r\n    function isOwner(address _add) public view returns(bool);\r\n\r\n    function isMember(address _add) public view returns(bool);\r\n    \r\n    function checkIsAuthToGoverned(address _add) public view returns(bool);\r\n\r\n    function updatePauseTime(uint _time) public;\r\n\r\n    function dAppLocker() public view returns(address _add);\r\n\r\n    function dAppToken() public view returns(address _add);\r\n\r\n    function getLatestAddress(bytes2 _contractName) public view returns(address payable contractAddress);\r\n}"},"Iupgradable.sol":{"content":"pragma solidity 0.5.7;\r\n\r\nimport \"./INXMMaster.sol\";\r\n\r\n\r\ncontract Iupgradable {\r\n\r\n    INXMMaster public ms;\r\n    address public nxMasterAddress;\r\n\r\n    modifier onlyInternal {\r\n        require(ms.isInternal(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier isMemberAndcheckPause {\r\n        require(ms.isPause() == false \u0026\u0026 ms.isMember(msg.sender) == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(ms.isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier checkPause {\r\n        require(ms.isPause() == false);\r\n        _;\r\n    }\r\n\r\n    modifier isMember {\r\n        require(ms.isMember(msg.sender), \"Not member\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function  changeDependentContractAddress() public;\r\n\r\n    /**\r\n     * @dev change master address\r\n     * @param _masterAddress is the new address\r\n     */\r\n    function changeMasterAddress(address _masterAddress) public {\r\n        if (address(ms) != address(0)) {\r\n            require(address(ms) == msg.sender, \"Not master\");\r\n        }\r\n        ms = INXMMaster(_masterAddress);\r\n        nxMasterAddress = _masterAddress;\r\n    }\r\n\r\n}\r\n"},"SafeMath.sol":{"content":"pragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n"},"TokenData.sol":{"content":"/* Copyright (C) 2017 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n    \r\npragma solidity 0.5.7;\r\n\r\nimport \"./Iupgradable.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n\r\ncontract TokenData is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    address payable public walletAddress;\r\n    uint public lockTokenTimeAfterCoverExp;\r\n    uint public bookTime;\r\n    uint public lockCADays;\r\n    uint public lockMVDays;\r\n    uint public scValidDays;\r\n    uint public joiningFee;\r\n    uint public stakerCommissionPer;\r\n    uint public stakerMaxCommissionPer;\r\n    uint public tokenExponent;\r\n    uint public priceStep;\r\n\r\n    struct StakeCommission {\r\n        uint commissionEarned;\r\n        uint commissionRedeemed;\r\n    }\r\n\r\n    struct Stake {\r\n        address stakedContractAddress;\r\n        uint stakedContractIndex;\r\n        uint dateAdd;\r\n        uint stakeAmount;\r\n        uint unlockedAmount;\r\n        uint burnedAmount;\r\n        uint unLockableBeforeLastBurn;\r\n    }\r\n\r\n    struct Staker {\r\n        address stakerAddress;\r\n        uint stakerIndex;\r\n    }\r\n\r\n    struct CoverNote {\r\n        uint amount;\r\n        bool isDeposited;\r\n    }\r\n\r\n    /**\r\n     * @dev mapping of uw address to array of sc address to fetch \r\n     * all staked contract address of underwriter, pushing\r\n     * data into this array of Stake returns stakerIndex \r\n     */ \r\n    mapping(address =\u003e Stake[]) public stakerStakedContracts; \r\n\r\n    /** \r\n     * @dev mapping of sc address to array of UW address to fetch\r\n     * all underwritters of the staked smart contract\r\n     * pushing data into this mapped array returns scIndex \r\n     */\r\n    mapping(address =\u003e Staker[]) public stakedContractStakers;\r\n\r\n    /**\r\n     * @dev mapping of staked contract Address to the array of StakeCommission\r\n     * here index of this array is stakedContractIndex\r\n     */ \r\n    mapping(address =\u003e mapping(uint =\u003e StakeCommission)) public stakedContractStakeCommission;\r\n\r\n    mapping(address =\u003e uint) public lastCompletedStakeCommission;\r\n\r\n    /** \r\n     * @dev mapping of the staked contract address to the current \r\n     * staker index who will receive commission.\r\n     */ \r\n    mapping(address =\u003e uint) public stakedContractCurrentCommissionIndex;\r\n\r\n    /** \r\n     * @dev mapping of the staked contract address to the \r\n     * current staker index to burn token from.\r\n     */ \r\n    mapping(address =\u003e uint) public stakedContractCurrentBurnIndex;\r\n\r\n    /** \r\n     * @dev mapping to return true if Cover Note deposited against coverId\r\n     */ \r\n    mapping(uint =\u003e CoverNote) public depositedCN;\r\n\r\n    mapping(address =\u003e uint) internal isBookedTokens;\r\n\r\n    event Commission(\r\n        address indexed stakedContractAddress,\r\n        address indexed stakerAddress,\r\n        uint indexed scIndex,\r\n        uint commissionAmount\r\n    );\r\n\r\n    constructor(address payable _walletAdd) public {\r\n        walletAddress = _walletAdd;\r\n        bookTime = 12 hours;\r\n        joiningFee = 2000000000000000; // 0.002 Ether\r\n        lockTokenTimeAfterCoverExp = 35 days;\r\n        scValidDays = 250;\r\n        lockCADays = 7 days;\r\n        lockMVDays = 2 days;\r\n        stakerCommissionPer = 20;\r\n        stakerMaxCommissionPer = 50;\r\n        tokenExponent = 4;\r\n        priceStep = 1000;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Change the wallet address which receive Joining Fee\r\n     */\r\n    function changeWalletAddress(address payable _address) external onlyInternal {\r\n        walletAddress = _address;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters of a code\r\n     * @param code whose details we want\r\n     * @return string value of the code\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\r\n        codeVal = code;\r\n        if (code == \"TOKEXP\") {\r\n\r\n            val = tokenExponent; \r\n\r\n        } else if (code == \"TOKSTEP\") {\r\n\r\n            val = priceStep;\r\n\r\n        } else if (code == \"RALOCKT\") {\r\n\r\n            val = scValidDays;\r\n\r\n        } else if (code == \"RACOMM\") {\r\n\r\n            val = stakerCommissionPer;\r\n\r\n        } else if (code == \"RAMAXC\") {\r\n\r\n            val = stakerMaxCommissionPer;\r\n\r\n        } else if (code == \"CABOOKT\") {\r\n\r\n            val = bookTime / (1 hours);\r\n\r\n        } else if (code == \"CALOCKT\") {\r\n\r\n            val = lockCADays / (1 days);\r\n\r\n        } else if (code == \"MVLOCKT\") {\r\n\r\n            val = lockMVDays / (1 days);\r\n\r\n        } else if (code == \"QUOLOCKT\") {\r\n\r\n            val = lockTokenTimeAfterCoverExp / (1 days);\r\n\r\n        } else if (code == \"JOINFEE\") {\r\n\r\n            val = joiningFee;\r\n\r\n        } \r\n    }\r\n\r\n    /**\r\n    * @dev Just for interface\r\n    */\r\n    function changeDependentContractAddress() public { //solhint-disable-line\r\n    }\r\n    \r\n    /**\r\n     * @dev to get the contract staked by a staker \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return the address of staked contract\r\n     */\r\n    function getStakerStakedContractByIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (address stakedContractAddress) \r\n    {\r\n        stakedContractAddress = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker\u0027s staked burned \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return amount burned\r\n     */\r\n    function getStakerStakedBurnedByIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (uint burnedAmount) \r\n    {\r\n        burnedAmount = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].burnedAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker\u0027s staked unlockable before the last burn \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return unlockable staked tokens\r\n     */\r\n    function getStakerStakedUnlockableBeforeLastBurnByIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (uint unlockable) \r\n    {\r\n        unlockable = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].unLockableBeforeLastBurn;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker\u0027s staked contract index \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return is the index of the smart contract address\r\n     */\r\n    function getStakerStakedContractIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (uint scIndex) \r\n    {\r\n        scIndex = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker index of the staked contract\r\n     * @param _stakedContractAddress is the address of the staked contract\r\n     * @param _stakedContractIndex is the index of staked contract\r\n     * @return is the index of the staker\r\n     */\r\n    function getStakedContractStakerIndex(\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (uint sIndex) \r\n    {\r\n        sIndex = stakedContractStakers[\r\n            _stakedContractAddress][_stakedContractIndex].stakerIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker\u0027s initial staked amount on the contract \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return staked amount\r\n     */\r\n    function getStakerInitialStakedAmountOnContract(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        public \r\n        view\r\n        returns (uint amount)\r\n    {\r\n        amount = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakeAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker\u0027s staked contract length \r\n     * @param _stakerAddress is the address of the staker\r\n     * @return length of staked contract\r\n     */\r\n    function getStakerStakedContractLength(\r\n        address _stakerAddress\r\n    ) \r\n        public\r\n        view\r\n        returns (uint length)\r\n    {\r\n        length = stakerStakedContracts[_stakerAddress].length;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker\u0027s unlocked tokens which were staked \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return amount\r\n     */\r\n    function getStakerUnlockedStakedTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        public \r\n        view\r\n        returns (uint amount)\r\n    {\r\n        amount = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].unlockedAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the unlocked staked tokens by a staker.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker to distribute commission.\r\n     * @param _amount amount to be given as commission.\r\n     */ \r\n    function pushUnlockedStakedTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        stakerStakedContracts[_stakerAddress][\r\n            _stakerIndex].unlockedAmount = stakerStakedContracts[_stakerAddress][\r\n                _stakerIndex].unlockedAmount.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the Burned tokens for a staker.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker.\r\n     * @param _amount amount to be burned.\r\n     */ \r\n    function pushBurnedTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        stakerStakedContracts[_stakerAddress][\r\n            _stakerIndex].burnedAmount = stakerStakedContracts[_stakerAddress][\r\n                _stakerIndex].burnedAmount.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the unLockable tokens for a staker before last burn.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker.\r\n     * @param _amount amount to be added to unlockable.\r\n     */ \r\n    function pushUnlockableBeforeLastBurnTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        stakerStakedContracts[_stakerAddress][\r\n            _stakerIndex].unLockableBeforeLastBurn = stakerStakedContracts[_stakerAddress][\r\n                _stakerIndex].unLockableBeforeLastBurn.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev sets the unLockable tokens for a staker before last burn.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker.\r\n     * @param _amount amount to be added to unlockable.\r\n     */ \r\n    function setUnlockableBeforeLastBurnTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        stakerStakedContracts[_stakerAddress][\r\n            _stakerIndex].unLockableBeforeLastBurn = _amount;\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the earned commission earned by a staker.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakedContractAddress address of smart contract.\r\n     * @param _stakedContractIndex index of the staker to distribute commission.\r\n     * @param _commissionAmount amount to be given as commission.\r\n     */ \r\n    function pushEarnedStakeCommissions(\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex,\r\n        uint _commissionAmount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {\r\n        stakedContractStakeCommission[_stakedContractAddress][_stakedContractIndex].\r\n            commissionEarned = stakedContractStakeCommission[_stakedContractAddress][\r\n                _stakedContractIndex].commissionEarned.add(_commissionAmount);\r\n                \r\n        emit Commission(\r\n            _stakerAddress,\r\n            _stakedContractAddress,\r\n            _stakedContractIndex,\r\n            _commissionAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the redeemed commission redeemed by a staker.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker to distribute commission.\r\n     * @param _amount amount to be given as commission.\r\n     */ \r\n    function pushRedeemedStakeCommissions(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        uint stakedContractIndex = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractIndex;\r\n        address stakedContractAddress = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractAddress;\r\n        stakedContractStakeCommission[stakedContractAddress][stakedContractIndex].\r\n            commissionRedeemed = stakedContractStakeCommission[\r\n                stakedContractAddress][stakedContractIndex].commissionRedeemed.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets stake commission given to an underwriter\r\n     * for particular stakedcontract on given index.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker commission.\r\n     */ \r\n    function getStakerEarnedStakeCommission(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        public \r\n        view\r\n        returns (uint) \r\n    {\r\n        return _getStakerEarnedStakeCommission(_stakerAddress, _stakerIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets stake commission redeemed by an underwriter\r\n     * for particular staked contract on given index.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker commission.\r\n     * @return commissionEarned total amount given to staker.\r\n     */ \r\n    function getStakerRedeemedStakeCommission(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        public \r\n        view\r\n        returns (uint) \r\n    {\r\n        return _getStakerRedeemedStakeCommission(_stakerAddress, _stakerIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets total stake commission given to an underwriter\r\n     * @param _stakerAddress address of staker.\r\n     * @return totalCommissionEarned total commission earned by staker.\r\n     */ \r\n    function getStakerTotalEarnedStakeCommission(\r\n        address _stakerAddress\r\n    )\r\n        public \r\n        view\r\n        returns (uint totalCommissionEarned) \r\n    {\r\n        totalCommissionEarned = 0;\r\n        for (uint i = 0; i \u003c stakerStakedContracts[_stakerAddress].length; i++) {\r\n            totalCommissionEarned = totalCommissionEarned.\r\n                add(_getStakerEarnedStakeCommission(_stakerAddress, i));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets total stake commission given to an underwriter\r\n     * @param _stakerAddress address of staker.\r\n     * @return totalCommissionEarned total commission earned by staker.\r\n     */ \r\n    function getStakerTotalReedmedStakeCommission(\r\n        address _stakerAddress\r\n    )\r\n        public \r\n        view\r\n        returns(uint totalCommissionRedeemed) \r\n    {\r\n        totalCommissionRedeemed = 0;\r\n        for (uint i = 0; i \u003c stakerStakedContracts[_stakerAddress].length; i++) {\r\n            totalCommissionRedeemed = totalCommissionRedeemed.add(\r\n                _getStakerRedeemedStakeCommission(_stakerAddress, i));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev set flag to deposit/ undeposit cover note \r\n     * against a cover Id\r\n     * @param coverId coverId of Cover\r\n     * @param flag true/false for deposit/undeposit\r\n     */\r\n    function setDepositCN(uint coverId, bool flag) public onlyInternal {\r\n\r\n        if (flag == true) {\r\n            require(!depositedCN[coverId].isDeposited, \"Cover note already deposited\");    \r\n        }\r\n\r\n        depositedCN[coverId].isDeposited = flag;\r\n    }\r\n\r\n    /**\r\n     * @dev set locked cover note amount\r\n     * against a cover Id\r\n     * @param coverId coverId of Cover\r\n     * @param amount amount of nxm to be locked\r\n     */\r\n    function setDepositCNAmount(uint coverId, uint amount) public onlyInternal {\r\n\r\n        depositedCN[coverId].amount = amount;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker address on a staked contract \r\n     * @param _stakedContractAddress is the address of the staked contract in concern\r\n     * @param _stakedContractIndex is the index of staked contract\u0027s index\r\n     * @return address of staker\r\n     */\r\n    function getStakedContractStakerByIndex(\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex\r\n    )\r\n        public\r\n        view\r\n        returns (address stakerAddress)\r\n    {\r\n        stakerAddress = stakedContractStakers[\r\n            _stakedContractAddress][_stakedContractIndex].stakerAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the length of stakers on a staked contract \r\n     * @param _stakedContractAddress is the address of the staked contract in concern\r\n     * @return length in concern\r\n     */\r\n    function getStakedContractStakersLength(\r\n        address _stakedContractAddress\r\n    ) \r\n        public\r\n        view\r\n        returns (uint length)\r\n    {\r\n        length = stakedContractStakers[_stakedContractAddress].length;\r\n    } \r\n    \r\n    /**\r\n     * @dev Adds a new stake record.\r\n     * @param _stakerAddress staker address.\r\n     * @param _stakedContractAddress smart contract address.\r\n     * @param _amount amountof NXM to be staked.\r\n     */\r\n    function addStake(\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _amount\r\n    ) \r\n        public\r\n        onlyInternal\r\n        returns(uint scIndex) \r\n    {\r\n        scIndex = (stakedContractStakers[_stakedContractAddress].push(\r\n            Staker(_stakerAddress, stakerStakedContracts[_stakerAddress].length))).sub(1);\r\n        stakerStakedContracts[_stakerAddress].push(\r\n            Stake(_stakedContractAddress, scIndex, now, _amount, 0, 0, 0));\r\n    }\r\n\r\n    /**\r\n     * @dev books the user\u0027s tokens for maintaining Assessor Velocity, \r\n     * i.e. once a token is used to cast a vote as a Claims assessor,\r\n     * @param _of user\u0027s address.\r\n     */\r\n    function bookCATokens(address _of) public onlyInternal {\r\n        require(!isCATokensBooked(_of), \"Tokens already booked\");\r\n        isBookedTokens[_of] = now.add(bookTime);\r\n    }\r\n\r\n    /**\r\n     * @dev to know if claim assessor\u0027s tokens are booked or not \r\n     * @param _of is the claim assessor\u0027s address in concern\r\n     * @return boolean representing the status of tokens booked\r\n     */\r\n    function isCATokensBooked(address _of) public view returns(bool res) {\r\n        if (now \u003c isBookedTokens[_of])\r\n            res = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the index which will receive commission.\r\n     * @param _stakedContractAddress smart contract address.\r\n     * @param _index current index.\r\n     */\r\n    function setStakedContractCurrentCommissionIndex(\r\n        address _stakedContractAddress,\r\n        uint _index\r\n    )\r\n        public\r\n        onlyInternal\r\n    {\r\n        stakedContractCurrentCommissionIndex[_stakedContractAddress] = _index;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the last complete commission index\r\n     * @param _stakerAddress smart contract address.\r\n     * @param _index current index.\r\n     */\r\n    function setLastCompletedStakeCommissionIndex(\r\n        address _stakerAddress,\r\n        uint _index\r\n    )\r\n        public\r\n        onlyInternal\r\n    {\r\n        lastCompletedStakeCommission[_stakerAddress] = _index;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the index till which commission is distrubuted.\r\n     * @param _stakedContractAddress smart contract address.\r\n     * @param _index current index.\r\n     */\r\n    function setStakedContractCurrentBurnIndex(\r\n        address _stakedContractAddress,\r\n        uint _index\r\n    )\r\n        public\r\n        onlyInternal\r\n    {\r\n        stakedContractCurrentBurnIndex[_stakedContractAddress] = _index;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"TOKEXP\") {\r\n\r\n            _setTokenExponent(val); \r\n\r\n        } else if (code == \"TOKSTEP\") {\r\n\r\n            _setPriceStep(val);\r\n\r\n        } else if (code == \"RALOCKT\") {\r\n\r\n            _changeSCValidDays(val);\r\n\r\n        } else if (code == \"RACOMM\") {\r\n\r\n            _setStakerCommissionPer(val);\r\n\r\n        } else if (code == \"RAMAXC\") {\r\n\r\n            _setStakerMaxCommissionPer(val);\r\n\r\n        } else if (code == \"CABOOKT\") {\r\n\r\n            _changeBookTime(val * 1 hours);\r\n\r\n        } else if (code == \"CALOCKT\") {\r\n\r\n            _changelockCADays(val * 1 days);\r\n\r\n        } else if (code == \"MVLOCKT\") {\r\n\r\n            _changelockMVDays(val * 1 days);\r\n\r\n        } else if (code == \"QUOLOCKT\") {\r\n\r\n            _setLockTokenTimeAfterCoverExp(val * 1 days);\r\n\r\n        } else if (code == \"JOINFEE\") {\r\n\r\n            _setJoiningFee(val);\r\n\r\n        } else {\r\n            revert(\"Invalid param code\");\r\n        } \r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to get stake commission given to an \r\n     * underwriter for particular stakedcontract on given index.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker commission.\r\n     */ \r\n    function _getStakerEarnedStakeCommission(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        internal\r\n        view \r\n        returns (uint amount) \r\n    {\r\n        uint _stakedContractIndex;\r\n        address _stakedContractAddress;\r\n        _stakedContractAddress = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractAddress;\r\n        _stakedContractIndex = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractIndex;\r\n        amount = stakedContractStakeCommission[\r\n            _stakedContractAddress][_stakedContractIndex].commissionEarned;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to get stake commission redeemed by an \r\n     * underwriter for particular stakedcontract on given index.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker commission.\r\n     */ \r\n    function _getStakerRedeemedStakeCommission(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        internal\r\n        view \r\n        returns (uint amount) \r\n    {\r\n        uint _stakedContractIndex;\r\n        address _stakedContractAddress;\r\n        _stakedContractAddress = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractAddress;\r\n        _stakedContractIndex = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractIndex;\r\n        amount = stakedContractStakeCommission[\r\n            _stakedContractAddress][_stakedContractIndex].commissionRedeemed;\r\n    }\r\n\r\n    /**\r\n     * @dev to set the percentage of staker commission \r\n     * @param _val is new percentage value\r\n     */\r\n    function _setStakerCommissionPer(uint _val) internal {\r\n        stakerCommissionPer = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev to set the max percentage of staker commission \r\n     * @param _val is new percentage value\r\n     */\r\n    function _setStakerMaxCommissionPer(uint _val) internal {\r\n        stakerMaxCommissionPer = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev to set the token exponent value \r\n     * @param _val is new value\r\n     */\r\n    function _setTokenExponent(uint _val) internal {\r\n        tokenExponent = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev to set the price step \r\n     * @param _val is new value\r\n     */\r\n    function _setPriceStep(uint _val) internal {\r\n        priceStep = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes number of days for which NXM needs to staked in case of underwriting\r\n     */ \r\n    function _changeSCValidDays(uint _days) internal {\r\n        scValidDays = _days;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the time period up to which tokens will be locked.\r\n     *      Used to generate the validity period of tokens booked by\r\n     *      a user for participating in claim\u0027s assessment/claim\u0027s voting.\r\n     */ \r\n    function _changeBookTime(uint _time) internal {\r\n        bookTime = _time;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes lock CA days - number of days for which tokens \r\n     * are locked while submitting a vote.\r\n     */ \r\n    function _changelockCADays(uint _val) internal {\r\n        lockCADays = _val;\r\n    }\r\n    \r\n    /**\r\n     * @dev Changes lock MV days - number of days for which tokens are locked\r\n     * while submitting a vote.\r\n     */ \r\n    function _changelockMVDays(uint _val) internal {\r\n        lockMVDays = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes extra lock period for a cover, post its expiry.\r\n     */ \r\n    function _setLockTokenTimeAfterCoverExp(uint time) internal {\r\n        lockTokenTimeAfterCoverExp = time;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the joining fee for membership\r\n     */\r\n    function _setJoiningFee(uint _amount) internal {\r\n        joiningFee = _amount;\r\n    }\r\n}"}}
