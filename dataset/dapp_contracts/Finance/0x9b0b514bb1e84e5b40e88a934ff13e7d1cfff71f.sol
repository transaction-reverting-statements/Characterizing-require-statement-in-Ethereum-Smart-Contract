{{
  "language": "Solidity",
  "sources": {
    "contracts/iface/INest_3_Abonus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.0;\n\ninterface INest_3_Abonus {\n\n    function getETHNum(address token) external view returns (uint256); \n\n    function turnOutAllEth(uint256 amount, address target) external;\n\n}"
    },
    "contracts/NestUpgrade.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/SafeMath.sol\";\n\nimport \"./iface/INestPool.sol\";\nimport \"./iface/INestDAO.sol\";\nimport \"./iface/INestMining.sol\";\nimport \"./iface/INestQuery.sol\";\nimport \"./iface/INestStaking.sol\";\nimport \"./iface/INNRewardPool.sol\";\nimport \"./iface/INTokenController.sol\";\n\nimport \"./iface/INest_3_Abonus.sol\";\nimport \"./iface/INest_3_Leveling.sol\";\nimport \"./iface/INest_3_MiningContract.sol\";\nimport \"./iface/INest_NToken_TokenAuction.sol\";\nimport \"./iface/INest_NToken_TokenMapping.sol\";\n\n// import \"hardhat/console.sol\";\n\n/*\n    steps:\n\n    Attention: no new quote pairs are allowed when executing upgrade contracts !!!\n    \n    //==================== set params ====================//\n   \n    1. nest3Admin: Set nest3Admin address to NestUpgrade.address\n\n    2. nest3.5: gov: NestPool.setGovernance(NestUpgrade.address)\n\n    3. nest3.5: NestUpgrade.setPairsOfTokens(..., tokanL), can be run multiple times, \n      all token-ntoken settings must be completed before proceeding to the next step, \n      USDT-NEST included. tokenL[i] != USDT.address\n\n    4. nest3.5: NestUpgrade.SetupParamsOfNestMining(...), this function can only be \n      executed once\n\n    //========================================================//\n    \n    \n    Attention: nest 3 stops running when funds are transferred !!!!\n    //===================== transfer funds ===================//\n    \n    5. nest3.5: gov: NestPool.setGovernance(NestUpgrade.address)\n    \n    6. nest3.5: NestUpgrade.transferNestFromNest3(), transfer NEST(umined) to NestPool\n       if failed: \n            all right, no funds are transferred to the new contract at this time;\n       if succeeded: \n            go to next step;\n\n    7. nest3.5: gov: NestPool.setGovernance(NestUpgrade.address)\n\n    8. nest3.5: NestUpgrade.transferETHFromNest3(...), transfer ETH to address(this), \n       can be run multiple times, each tokens should be applied once, USDT must be included \n       if falied: \n            run NestUpgrade.transferNestInUrgent() to revert\n       if succeeded: \n            go to next step\n\n    9. nest3.5: NestUpgrade.transferETHToNestDAO(...), transfer ETH to NestDAO.addr, \n        if failed: can run NestUpgrade.transferETH()\n        if succeeded: next step\n\n    10. nest3.5: NestUpgrade.initNest35(), NestMining.upgrade() / NestDAO.start()\n        if failed: NestDAO.migrateTo(...), transfer eth to new DAO\n        if succeeded: end\n*/\n\ncontract NestUpgrade {\n\n    using SafeMath for uint256;\n\n    address public governance;\n\n    address public C_NestToken;\n    address public C_NestPool;\n    address public C_NestMining;\n    address public C_NestDAO;\n\n    uint8 public flag;\n\n    uint256 public latestHeight;\n    uint256 public nestBal;\n    uint256 public minedNestAmount;\n    uint256 public nest;\n    uint256 public tokenNum;         // Nest_NToken_TokenAuction.checkTokenNum()\n\n    uint256 public ntoken_num1 = 0;  // record how many pairs of tokens have been set\n                                     // finally,the value should be equal to  \n                                     // Nest_NToken_TokenAuction.checkTokenNum()\n\n    uint256 public ntoken_num2 = 0;  // record the number of tokens for which funds have been transferred\n\n    uint256 constant total_nest = 10_000_000_000;  // total nest == 10 billion\n\n    mapping(address => address) _token_ntoken_mapping;\n\n    receive() external payable {}\n\n    modifier onlyGovernance()\n    {\n        require(msg.sender == governance, \"Nest:Upg:!gov\");\n        _;\n    }\n\n    constructor(address NestPool) public \n    {\n        governance = msg.sender;\n        C_NestPool = NestPool;\n        flag = 0;\n    }\n    \n    function shutdown() public onlyGovernance\n    {\n        flag = 2;\n    }\n\n    function resume() public onlyGovernance\n    {\n        flag = 0;\n    }\n\n    /// @notice Upgrade from Nest v3.0 to v3.5\n    /// @dev setNtokenToToken(token, ntoken)\n    ///   If the number of ntokens is too large \n    ///   and gas consumption exceeds the limit,\n    ///   you can execute setPairsOfTokens() multiple times.\n    ///   open new ntoken in nest3 should not be allowed.\n    function setPairsOfTokens(\n            address usdtToken,\n            address Nest_NToken_TokenMapping, \n            address[] memory tokenL) public onlyGovernance\n    {\n        address[] memory ntokenL = new address[](tokenL.length);\n\n        require(flag < 2, \"Nest:Upg:!flag\");\n        require(tokenL.length == ntokenL.length, \"Ntoken:Upg:!len\");\n\n        for(uint i=0; i 0, \"LatestHeight:Upg: err\");\n\n        INestMining(C_NestMining).setParams1(uint128(latestHeight), uint128(minedNestAmount));\n\n        // send nest to nestpool.addr\n        INest_3_MiningContract(Nest_3_MiningContract).takeOutNest(C_NestPool);\n        nest = ERC20(C_NestToken).balanceOf(C_NestPool);\n        _C_NestPool.initNestLedger(nest);\n \n        _C_NestPool.setGovernance(governance);\n\n        INestMining(C_NestMining).loadGovernance();\n\n        return;\n    }\n\n    /// @notice Transfer NEST from nest3 to nest3.5\n    /// @param Nest_3_MiningContract Address of Nest_3_MiningContract\n    /// @param Nest_NToken_TokenAuction Address of Nest_NToken_TokenAuction\n    /// @param Nest_3_Abonus Address of Nest_NToken_TokenMapping\n    /// @param Nest_3_Leveling Address of Nest_NToken_TokenMapping\n    /// @param tokenL Lists of tokens addresses, usdt included\n    /// @dev This function could be executed many times\n    function transferETHFromNest3(\n            address Nest_3_MiningContract,\n            address Nest_NToken_TokenAuction,\n            address Nest_3_Abonus,\n            address Nest_3_Leveling,\n            address[] memory tokenL\n            ) public onlyGovernance\n    {\n        address[] memory ntokenL = new address[](tokenL.length);\n\n        require(flag < 2, \"Nest:Upg:!flag\");\n        INestPool _C_NestPool = INestPool(C_NestPool);\n        C_NestToken = _C_NestPool.addrOfNestToken();\n\n        C_NestMining = _C_NestPool.addrOfNestMining();\n        C_NestDAO = _C_NestPool.addrOfNestDAO();\n        \n        INestMining(C_NestMining).loadGovernance();\n\n        INestDAO(C_NestDAO).loadGovernance();\n\n        \n        for(uint i=0; i 0)\n                {\n                    INest_3_Abonus(Nest_3_Abonus).turnOutAllEth(amount_bonus, address(this));\n                }\n\n                amount_leveling = INest_3_Leveling(Nest_3_Leveling).checkEthMapping(ntokenL[i]);\n\n                if(amount_leveling > 0)\n                {\n                    INest_3_Leveling(Nest_3_Leveling).turnOutAllEth(amount_leveling, address(this));    \n                }\n\n                amount = amount_bonus.add(amount_leveling);\n\n                if(amount > 0)\n                {\n                    INestDAO(C_NestDAO).initEthLedger(ntokenL[i], amount);\n                }\n\n                _token_ntoken_mapping[tokenL[i]] = ntokenL[i];\n\n                ntoken_num2 += 1; \n\n            }\n        }\n\n        return;\n    }\n\n    /// @notice Transfer ETH to NestDAO\n    /// @param NestDAO Address of NestDAO contract\n    /// @param Nest_NToken_TokenAuction Address of Nest_NToken_TokenAuction\n    /// @dev All ETH(ntoken) must be transfered to address(this) \n    function transferETHToNestDAO(address NestDAO, address Nest_NToken_TokenAuction)\n        public onlyGovernance\n    {\n        tokenNum = INest_NToken_TokenAuction(Nest_NToken_TokenAuction).checkTokenNum();\n        require(tokenNum == ntoken_num2, \"ntoken_num2:Upg: !sufficient\");\n\n        (bool success, ) = NestDAO.call{value: address(this).balance}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n\n    }\n\n    /// @dev Initialize nest3.5, NestMining.upgrade() / NestDAO.start()\n    /// @dev This function can only be executed once\n    /// @dev New ntoken not turned on at this time, set ntokenCounter by C_NTokenController.start(...)\n    function switchOnNest35() public onlyGovernance\n    {\n        require(flag < 2, \"Nest:Upg:!flag\");\n        INestPool _C_NestPool = INestPool(C_NestPool);\n        C_NestToken = _C_NestPool.addrOfNestToken();\n\n        C_NestMining = _C_NestPool.addrOfNestMining();\n        C_NestDAO = _C_NestPool.addrOfNestDAO();\n        \n        INestMining(C_NestMining).loadGovernance();\n\n        INestDAO(C_NestDAO).loadGovernance();\n          \n        // start nest3.5\n        \n        INestMining(C_NestMining).upgrade();\n\n        INestDAO(C_NestDAO).loadContracts();\n\n        _C_NestPool.setGovernance(governance);\n\n        INestMining(C_NestMining).loadGovernance();\n        INestDAO(C_NestDAO).loadGovernance();\n\n        return;\n    }\n\n\n    //================== urgent, if deployment failed ================//\n    \n    /// @dev If the upgrading failed, transfer ETH to an temporary address\n    function transferETH(address to) public onlyGovernance\n    {\n        (bool success, ) = to.call{value: address(this).balance}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n\n    /// @dev if the upgrading failed, withdraw nest from nestpool\n    /// @param to Address where you want to transfer\n    /// @param amount NEST amount\n    /// @param upgrade Address of NestUpgrade\n    function transferNestInUrgent(address to, uint256 amount, address upgrade) \n        public onlyGovernance \n    {\n        require(flag < 2, \"Nest:Upg:!flag\");\n        INestPool _C_NestPool = INestPool(C_NestPool);\n        _C_NestPool.drainNest(to, amount, upgrade);\n    }\n\n    ///@dev set NestPool gov\n    /// NestPool.setGovernance(NestUpgrade.address) at first\n    function setGov() public onlyGovernance\n    {\n        INestPool _C_NestPool = INestPool(C_NestPool);\n        \n        _C_NestPool.setGovernance(governance);\n\n        C_NestMining = _C_NestPool.addrOfNestMining();\n\n        C_NestDAO = _C_NestPool.addrOfNestDAO();\n        \n        INestMining(C_NestMining).loadGovernance();\n\n        INestDAO(C_NestDAO).loadGovernance();\n    }\n\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n\n    function div(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"ds-math-div-zero\");\n        z = x / y;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    }\n}"
    },
    "contracts/iface/INestPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport \"../lib/SafeERC20.sol\";\n\ninterface INestPool {\n\n    // function getNTokenFromToken(address token) view external returns (address);\n    // function setNTokenToToken(address token, address ntoken) external; \n\n    function addNest(address miner, uint256 amount) external;\n    function addNToken(address contributor, address ntoken, uint256 amount) external;\n\n    function depositEth(address miner) external payable;\n    function depositNToken(address miner,  address from, address ntoken, uint256 amount) external;\n\n    function freezeEth(address miner, uint256 ethAmount) external; \n    function unfreezeEth(address miner, uint256 ethAmount) external;\n\n    function freezeNest(address miner, uint256 nestAmount) external;\n    function unfreezeNest(address miner, uint256 nestAmount) external;\n\n    function freezeToken(address miner, address token, uint256 tokenAmount) external; \n    function unfreezeToken(address miner, address token, uint256 tokenAmount) external;\n\n    function freezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\n    function unfreezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\n\n    function getNTokenFromToken(address token) external view returns (address); \n    function setNTokenToToken(address token, address ntoken) external; \n\n    function withdrawEth(address miner, uint256 ethAmount) external;\n    function withdrawToken(address miner, address token, uint256 tokenAmount) external;\n\n    function withdrawNest(address miner, uint256 amount) external;\n    function withdrawEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) external;\n    // function withdrawNToken(address miner, address ntoken, uint256 amount) external;\n    function withdrawNTokenAndTransfer(address miner, address ntoken, uint256 amount, address to) external;\n\n\n    function balanceOfNestInPool(address miner) external view returns (uint256);\n    function balanceOfEthInPool(address miner) external view returns (uint256);\n    function balanceOfTokenInPool(address miner, address token)  external view returns (uint256);\n\n    function addrOfNestToken() external view returns (address);\n    function addrOfNestMining() external view returns (address);\n    function addrOfNTokenController() external view returns (address);\n    function addrOfNNRewardPool() external view returns (address);\n    function addrOfNNToken() external view returns (address);\n    function addrOfNestStaking() external view returns (address);\n    function addrOfNestQuery() external view returns (address);\n    function addrOfNestDAO() external view returns (address);\n\n    function addressOfBurnedNest() external view returns (address);\n\n    function setGovernance(address _gov) external; \n    function governance() external view returns(address);\n    function initNestLedger(uint256 amount) external;\n    function drainNest(address to, uint256 amount, address gov) external;\n\n}"
    },
    "contracts/iface/INestDAO.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\ninterface INestDAO {\n\n    function addETHReward(address ntoken) external payable; \n\n    function addNestReward(uint256 amount) external;\n\n    /// @dev Only for governance\n    function loadContracts() external; \n\n    /// @dev Only for governance\n    function loadGovernance() external;\n    \n    /// @dev Only for governance\n    function start() external; \n\n    function initEthLedger(address ntoken, uint256 amount) external;\n\n    event NTokenRedeemed(address ntoken, address user, uint256 amount);\n\n    event AssetsCollected(address user, uint256 ethAmount, uint256 nestAmount);\n\n    event ParamsSetup(address gov, uint256 oldParam, uint256 newParam);\n\n    event FlagSet(address gov, uint256 flag);\n\n}"
    },
    "contracts/iface/INestMining.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/SafeERC20.sol\";\n\n\ninterface INestMining {\n    \n    struct Params {\n        uint8    miningEthUnit;     // = 10;\n        uint32   nestStakedNum1k;   // = 1;\n        uint8    biteFeeRate;       // = 1; \n        uint8    miningFeeRate;     // = 10;\n        uint8    priceDurationBlock; \n        uint8    maxBiteNestedLevel; // = 3;\n        uint8    biteInflateFactor;\n        uint8    biteNestInflateFactor;\n    }\n\n    function priceOf(address token) external view returns(uint256 ethAmount, uint256 tokenAmount, uint256 bn);\n    \n    function priceListOfToken(address token, uint8 num) external view returns(uint128[] memory data, uint256 bn);\n\n    // function priceOfTokenAtHeight(address token, uint64 atHeight) external view returns(uint256 ethAmount, uint256 tokenAmount, uint64 bn);\n\n    function latestPriceOf(address token) external view returns (uint256 ethAmount, uint256 tokenAmount, uint256 bn);\n\n    function priceAvgAndSigmaOf(address token) \n        external view returns (uint128, uint128, int128, uint32);\n\n    function minedNestAmount() external view returns (uint256);\n\n    /// @dev Only for governance\n    function loadContracts() external; \n    \n    function loadGovernance() external;\n\n    function upgrade() external;\n\n    function setup(uint32   genesisBlockNumber, uint128  latestMiningHeight, uint128  minedNestTotalAmount, Params calldata initParams) external;\n\n    function setParams1(uint128  latestMiningHeight, uint128  minedNestTotalAmount) external;\n}"
    },
    "contracts/iface/INestQuery.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n/// @title The interface of NestQuery\n/// @author Inf Loop - \n/// @author Paradox  - \ninterface INestQuery {\n\n    /// @notice Activate a pay-per-query defi client with NEST tokens\n    /// @dev No contract is allowed to call it\n    /// @param defi The addres of client (DeFi DApp)\n    function activate(address defi) external;\n\n    /// @notice Deactivate a pay-per-query defi client\n    /// @param defi The address of a client (DeFi DApp)\n    function deactivate(address defi) external;\n\n    /// @notice Query for PPQ (pay-per-query) clients\n    /// @dev Consider that if a user call a DeFi that queries NestQuery, DeFi should\n    ///     pass the user's wallet address to query() as `payback`.\n    /// @param token The address of token contract\n    /// @param payback The address of change\n    function query(address token, address payback) \n        external payable returns (uint256, uint256, uint256);\n\n    /// @notice Query for PPQ (pay-per-query) clients\n    /// @param token The address of token contract\n    /// @param payback The address of change\n    /// @return ethAmount The amount of ETH in pair (ETH, TOKEN)\n    /// @return tokenAmount The amount of TOKEN in pair (ETH, TOKEN)\n    /// @return avgPrice The average of last 50 prices \n    /// @return vola The volatility of prices \n    /// @return bn The block number when (ETH, TOKEN) takes into effective\n    function queryPriceAvgVola(address token, address payback) \n        external payable returns (uint256, uint256, uint128, int128, uint256);\n\n    /// @notice The main function called by DeFi clients, compatible to Nest Protocol v3.0 \n    /// @dev  The payback address is ZERO, so the changes are kept in this contract\n    ///         The ABI keeps consist with Nest v3.0\n    /// @param tokenAddress The address of token contract address\n    /// @return ethAmount The amount of ETH in price pair (ETH, ERC20)\n    /// @return erc20Amount The amount of ERC20 in price pair (ETH, ERC20)\n    /// @return blockNum The block.number where the price is being in effect\n    function updateAndCheckPriceNow(address tokenAddress) \n        external payable returns (uint256, uint256, uint256);\n\n    /// @notice A non-free function for querying price \n    /// @param token  The address of the token contract\n    /// @param num    The number of price sheets in the list\n    /// @param payback The address for change\n    /// @return The array of prices, each of which is (blockNnumber, ethAmount, tokenAmount)\n    function queryPriceList(address token, uint8 num, address payback) \n        external payable returns (uint128[] memory);\n\n    /// @notice A view function returning the historical price list from the current block\n    /// @param token  The address of the token contract\n    /// @param num    The number of price sheets in the list\n    /// @return The array of prices, each of which is (blockNnumber, ethAmount, tokenAmount)\n    function priceList(address token, uint8 num) \n        external view returns (uint128[] memory);\n\n    /// @notice A view function returning the latestPrice\n    /// @param token  The address of the token contract\n    function latestPrice(address token)\n    external view returns (uint256 ethAmount, uint256 tokenAmount, uint128 avgPrice, int128 vola, uint256 bn) ;\n\n    /// @dev Only for governance\n    function loadContracts() external; \n\n    /// @dev Only for governance\n    function loadGovernance() external; \n\n\n    event ClientActivated(address, uint256, uint256);\n    // event ClientRenewed(address, uint256, uint256, uint256);\n    event PriceQueried(address client, address token, uint256 ethAmount, uint256 tokenAmount, uint256 bn);\n    event PriceAvgVolaQueried(address client, address token, uint256 bn, uint128 avgPrice, int128 vola);\n\n    event PriceListQueried(address client, address token, uint256 bn, uint8 num);\n\n    // governance events\n    event ParamsSetup(address gov, uint256 oldParams, uint256 newParams);\n    event FlagSet(address gov, uint256 flag);\n}"
    },
    "contracts/iface/INestStaking.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n\ninterface INestStaking {\n    // Views\n\n    /// @dev How many stakingToken (XToken) deposited into to this reward pool (staking pool)\n    /// @param  ntoken The address of NToken\n    /// @return The total amount of XTokens deposited in this staking pool\n    function totalStaked(address ntoken) external view returns (uint256);\n\n    /// @dev How many stakingToken (XToken) deposited by the target account\n    /// @param  ntoken The address of NToken\n    /// @param  account The target account\n    /// @return The total amount of XToken deposited in this staking pool\n    function stakedBalanceOf(address ntoken, address account) external view returns (uint256);\n\n\n    // Mutative\n    /// @dev Stake/Deposit into the reward pool (staking pool)\n    /// @param  ntoken The address of NToken\n    /// @param  amount The target amount\n    function stake(address ntoken, uint256 amount) external;\n\n    function stakeFromNestPool(address ntoken, uint256 amount) external;\n\n    /// @dev Withdraw from the reward pool (staking pool), get the original tokens back\n    /// @param  ntoken The address of NToken\n    /// @param  amount The target amount\n    function unstake(address ntoken, uint256 amount) external;\n\n    /// @dev Claim the reward the user earned\n    /// @param ntoken The address of NToken\n    /// @return The amount of ethers as rewards\n    function claim(address ntoken) external returns (uint256);\n\n    /// @dev Add ETH reward to the staking pool\n    /// @param ntoken The address of NToken\n    function addETHReward(address ntoken) external payable;\n\n    /// @dev Only for governance\n    function loadContracts() external; \n\n    /// @dev Only for governance\n    function loadGovernance() external; \n\n    function pause() external;\n\n    function resume() external;\n\n    //function setParams(uint8 dividendShareRate) external;\n\n    /* ========== EVENTS ========== */\n\n    // Events\n    event RewardAdded(address ntoken, address sender, uint256 reward);\n    event NTokenStaked(address ntoken, address indexed user, uint256 amount);\n    event NTokenUnstaked(address ntoken, address indexed user, uint256 amount);\n    event SavingWithdrawn(address ntoken, address indexed to, uint256 amount);\n    event RewardClaimed(address ntoken, address indexed user, uint256 reward);\n\n    event FlagSet(address gov, uint256 flag);\n}"
    },
    "contracts/iface/INNRewardPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n/// @title NNRewardPool\n/// @author Inf Loop - \n/// @author Paradox  - \n\ninterface INNRewardPool {\n    \n    /* [DEPRECATED]\n        uint256 constant DEV_REWARD_PERCENTAGE   = 5;\n        uint256 constant NN_REWARD_PERCENTAGE    = 15;\n        uint256 constant MINER_REWARD_PERCENTAGE = 80;\n    */\n\n    /// @notice Add rewards for Nest-Nodes, only governance or NestMining (contract) are allowed\n    /// @dev  The rewards need to pull from NestPool\n    /// @param _amount The amount of Nest token as the rewards to each nest-node\n    function addNNReward(uint256 _amount) external;\n\n    /// @notice Claim rewards by Nest-Nodes\n    /// @dev The rewards need to pull from NestPool\n    function claimNNReward() external ;  \n\n    /// @dev The callback function called by NNToken.transfer()\n    /// @param fromAdd The address of 'from' to transfer\n    /// @param toAdd The address of 'to' to transfer\n    function nodeCount(address fromAdd, address toAdd) external;\n\n    /// @notice Show the amount of rewards unclaimed\n    /// @return reward The reward of a NN holder\n    function unclaimedNNReward() external view returns (uint256 reward);\n\n    /// @dev Only for governance\n    function loadContracts() external; \n\n    /// @dev Only for governance\n    function loadGovernance() external; \n\n    /* ========== EVENTS ============== */\n\n    /// @notice When rewards are added to the pool\n    /// @param reward The amount of Nest Token\n    /// @param allRewards The snapshot of all rewards accumulated\n    event NNRewardAdded(uint256 reward, uint256 allRewards);\n\n    /// @notice When rewards are claimed by nodes \n    /// @param nnode The address of the nest node\n    /// @param share The amount of Nest Token claimed by the nest node\n    event NNRewardClaimed(address nnode, uint256 share);\n\n    /// @notice When flag of state is set by governance \n    /// @param gov The address of the governance\n    /// @param flag The value of the new flag\n    event FlagSet(address gov, uint256 flag);\n}"
    },
    "contracts/iface/INTokenController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface INTokenController {\n\n    /// @dev A struct for an ntoken\n    ///     size: 2 x 256bit\n    struct NTokenTag {\n        address owner;          // the owner with the highest bid\n        uint128 nestFee;        // NEST amount staked for opening a NToken\n        uint64  startTime;      // the start time of service\n        uint8   state;          // =0: normal | =1 disabled\n        uint56  _reserved;      // padding space\n    }\n\n    function open(address token) external;\n    \n    function NTokenTagOf(address token) external view returns (NTokenTag memory);\n\n    /// @dev Only for governance\n    function loadContracts() external; \n\n    function loadGovernance() external;\n\n    function setParams(uint256 _openFeeNestAmount) external;\n\n    event ParamsSetup(address gov, uint256 oldParam, uint256 newParam);\n\n    event FlagSet(address gov, uint256 flag);\n\n}\n"
    },
    "contracts/iface/INest_3_Leveling.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.0;\n\ninterface INest_3_Leveling {\n\n    function checkEthMapping(address token) external view returns (uint256); \n\n    function turnOutAllEth(uint256 amount, address target) external;\n\n}"
    },
    "contracts/iface/INest_3_MiningContract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.0;\n\ninterface INest_3_MiningContract {\n\n    function takeOutNest(address target) external; \n\n    function checkLatestMining() external view returns(uint256);\n\n    function checkNestBalance() external view returns(uint256);\n    \n}"
    },
    "contracts/iface/INest_NToken_TokenAuction.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.0;\n\ninterface INest_NToken_TokenAuction {\n\n    function checkTokenNum() external view returns (uint256); \n    \n}"
    },
    "contracts/iface/INest_NToken_TokenMapping.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.0;\n\ninterface INest_NToken_TokenMapping {\n\n    function checkTokenMapping(address token) external view returns (address); \n    \n}"
    },
    "contracts/lib/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.6.12;\n\nimport \"./Address.sol\";\nimport \"./SafeMath.sol\";\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/lib/Address.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.6.12;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{value:amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}"
    },
    "contracts/NTokenController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/SafeERC20.sol\";\nimport './lib/TransferHelper.sol';\nimport \"./lib/ReentrancyGuard.sol\";\n\nimport \"./iface/INestPool.sol\";\nimport \"./iface/INTokenController.sol\";\nimport \"./iface/INToken.sol\";\nimport \"./NToken.sol\";\n\n// import \"./NestMining.sol\";\n// import \"./iface/INNRewardPool.sol\";\n\n/// @title NTokenController\n/// @author Inf Loop - \n/// @author Paradox  - \n\ncontract NTokenController is INTokenController, ReentrancyGuard {\n\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /* ========== STATE VARIABLES ============== */\n\n    /// @dev A number counter for generating ntoken name\n    uint32  public ntokenCounter;\n    uint8   public flag;         // 0: uninitialized | 1: active | 2: shutdown\n    uint216 private _reserved;\n\n    uint8   constant NTCTRL_FLAG_UNINITIALIZED    = 0;\n    uint8   constant NTCTRL_FLAG_ACTIVE           = 1;\n    uint8   constant NTCTRL_FLAG_PAUSED           = 2;\n\n    /// @dev A mapping for all auctions\n    ///     token(address) => NTokenTag\n    mapping(address => NTokenTag) private nTokenTagList;\n\n    /* ========== PARAMETERS ============== */\n\n    uint256 public openFeeNestAmount = 10_000; // default = 10_000\n\n    /* ========== ADDRESSES ============== */\n\n    /// @dev Contract address of NestPool\n    address public C_NestPool;\n    /// @dev Contract address of NestToken\n    address public C_NestToken;\n    /// @dev Contract address of NestDAO\n    address public C_NestDAO;\n\n    address private governance;\n\n    /* ========== EVENTS ============== */\n\n    /// @notice when the auction of a token gets started\n    /// @param token    The address of the (ERC20) token\n    /// @param ntoken   The address of the ntoken w.r.t. token for incentives\n    /// @param owner    The address of miner who opened the oracle\n    event NTokenOpened(address token, address ntoken, address owner);\n    event NTokenDisabled(address token);\n    event NTokenEnabled(address token);\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address NestPool) public\n    {\n        governance = msg.sender;\n        flag = NTCTRL_FLAG_UNINITIALIZED;\n        C_NestPool = NestPool;\n    }\n\n    /// @dev The initialization function takes `_ntokenCounter` as argument, \n    ///     which shall be migrated from Nest v3.0\n    function start(uint32 _ntokenCounter) public onlyGovernance\n    {\n        require(flag == NTCTRL_FLAG_UNINITIALIZED, \"Nest:NTC:!flag\");\n        ntokenCounter = _ntokenCounter;\n        flag = NTCTRL_FLAG_ACTIVE;\n        emit FlagSet(address(msg.sender), uint256(NTCTRL_FLAG_ACTIVE));\n    }\n\n    modifier noContract()\n    {\n        require(address(msg.sender) == address(tx.origin), \"Nest:NTC:^(contract)\");\n        _;\n    }\n\n    modifier whenActive() \n    {\n        require(flag == NTCTRL_FLAG_ACTIVE, \"Nest:NTC:!flag\");\n        _;\n    }\n\n    modifier onlyGovOrBy(address _account)\n    {\n        if (msg.sender != governance) { \n            require(msg.sender == _account,\n                \"Nest:NTC:!Auth\");\n        }\n        _;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    modifier onlyGovernance() \n    {\n        require(msg.sender == governance, \"Nest:NTC:!governance\");\n        _;\n    }\n\n    function loadGovernance() override external\n    {\n        governance = INestPool(C_NestPool).governance();\n    }\n\n    /// @dev  It should be called immediately after the depolyment\n    function loadContracts() override external onlyGovOrBy(C_NestPool) \n    {\n        C_NestToken = INestPool(C_NestPool).addrOfNestToken();\n        C_NestDAO = INestPool(C_NestPool).addrOfNestDAO();\n    }\n    \n    function setParams(uint256 _openFeeNestAmount) override external onlyGovernance\n    {\n        emit ParamsSetup(address(msg.sender), openFeeNestAmount, _openFeeNestAmount);\n        openFeeNestAmount = _openFeeNestAmount;\n    }\n\n    /// @dev  Bad tokens should be banned \n    function disable(address token) external onlyGovernance\n    {\n        NTokenTag storage _to = nTokenTagList[token];\n        _to.state = 1;\n        emit NTokenDisabled(token);\n    }\n\n    function enable(address token) external onlyGovernance\n    {\n        NTokenTag storage _to = nTokenTagList[token];\n        _to.state = 0;\n        emit NTokenEnabled(token);\n    }\n\n    /// @dev Stop service for emergency\n    function pause() external onlyGovernance\n    {\n        require(flag == NTCTRL_FLAG_ACTIVE, \"Nest:NTC:!flag\");\n        flag = NTCTRL_FLAG_PAUSED;\n        emit FlagSet(address(msg.sender), uint256(NTCTRL_FLAG_PAUSED));\n    }\n\n    /// @dev Resume service \n    function resume() external onlyGovernance\n    {\n        require(flag == NTCTRL_FLAG_PAUSED, \"Nest:NTC:!flag\");\n        flag = NTCTRL_FLAG_ACTIVE;\n        emit FlagSet(address(msg.sender), uint256(NTCTRL_FLAG_ACTIVE));\n    }\n\n    /* ========== OPEN ========== */\n\n    /// @notice  Open a NToken for a token by anyone (contracts aren't allowed)\n    /// @dev  Create and map the (Token, NToken) pair in NestPool\n    /// @param token  The address of token contract\n    function open(address token) override external noContract whenActive\n    {\n        require(INestPool(C_NestPool).getNTokenFromToken(token) == address(0x0),\n            \"Nest:NTC:EX(token)\");\n        require(nTokenTagList[token].state == 0,\n            \"Nest:NTC:DIS(token)\");\n\n        nTokenTagList[token] = NTokenTag(\n            address(msg.sender),                                // owner\n            uint128(0),                                         // nestFee\n            uint64(block.timestamp),                            // startTime\n            0,                                                  // state\n            0                                                   // _reserved\n        );\n        \n        //  create ntoken\n        NToken ntoken = new NToken(strConcat(\"NToken\",\n                getAddressStr(ntokenCounter)),\n                strConcat(\"N\", getAddressStr(ntokenCounter)),\n                address(governance),\n                // NOTE: here `bidder`, we use `C_NestPool` to separate new NTokens \n                //   from old ones, whose bidders are the miners creating NTokens\n                address(C_NestPool)\n        );\n\n        // increase the counter\n        ntokenCounter = ntokenCounter + 1;  // safe math\n        INestPool(C_NestPool).setNTokenToToken(token, address(ntoken));\n\n        // is token valid ?\n        ERC20 tokenERC20 = ERC20(token);\n        tokenERC20.safeTransferFrom(address(msg.sender), address(this), 1);\n        require(tokenERC20.balanceOf(address(this)) >= 1, \n            \"Nest:NTC:!TEST(token)\");\n        tokenERC20.safeTransfer(address(msg.sender), 1);\n\n        // charge nest\n        ERC20(C_NestToken).transferFrom(address(msg.sender), address(C_NestDAO), openFeeNestAmount);\n\n        // raise an event\n        emit NTokenOpened(token, address(ntoken), address(msg.sender));\n\n    }\n\n    /* ========== VIEWS ========== */\n\n    function NTokenTagOf(address token) override public view returns (NTokenTag memory) \n    {\n        return nTokenTagList[token];\n    }\n\n    /* ========== HELPERS ========== */\n\n    /// @dev from NESTv3.0\n    function strConcat(string memory _a, string memory _b) public pure returns (string memory)\n    {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        string memory ret = new string(_ba.length + _bb.length);\n        bytes memory bret = bytes(ret);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) {\n            bret[k++] = _ba[i];\n        } \n        for (uint i = 0; i < _bb.length; i++) {\n            bret[k++] = _bb[i];\n        } \n        return string(ret);\n    } \n    \n    /// @dev Convert a 4-digital number into a string, from NestV3.0\n    function getAddressStr(uint256 iv) public pure returns (string memory) \n    {\n        bytes memory buf = new bytes(64);\n        uint256 index = 0;\n        do {\n            buf[index++] = byte(uint8(iv % 10 + 48));\n            iv /= 10;\n        } while (iv > 0 || index < 4);\n        bytes memory str = new bytes(index);\n        for(uint256 i = 0; i < index; ++i) {\n            str[i] = buf[index - i - 1];\n        }\n        return string(str);\n    }\n\n}"
    },
    "contracts/lib/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/lib/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/// @dev The non-empty constructor is conflict with upgrades-openzeppelin. \n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n\n    // NOTE: _NOT_ENTERED is set to ZERO such that it needn't constructor\n    uint256 private constant _NOT_ENTERED = 0;\n    uint256 private constant _ENTERED = 1;\n\n    uint256 private _status;\n\n    // constructor () internal {\n    //     _status = _NOT_ENTERED;\n    // }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
    },
    "contracts/iface/INToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\ninterface INToken {\n    // mint ntoken for value\n    function mint(uint256 amount, address account) external;\n\n    // the block height where the ntoken was created\n    function checkBlockInfo() external view returns(uint256 createBlock, uint256 recentlyUsedBlock);\n    // the owner (auction winner) of the ntoken\n    function checkBidder() external view returns(address);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}"
    },
    "contracts/NToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./iface/INToken.sol\";\nimport \"./iface/INestPool.sol\";\n\n\n/// @title NNRewardPool\n/// @author MLY0813 - \n/// @author Inf Loop - \n/// @author Paradox  - \n\n// The contract is based on Nest_NToken from Nest Protocol v3.0. Considering compatibility, the interface\n// keeps the same. \n\ncontract NToken is INToken {\n    using SafeMath for uint256;\n    \n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowed;\n    uint256 public _totalSupply = 0 ether;                                        \n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 public createdAtHeight;\n    uint256 public lastestMintAtHeight;\n    address public governance;\n\n    /// @dev The address of NestPool (Nest Protocol v3.5)\n    address C_NestPool;\n    address C_NestMining;\n    \n    /// @notice Constructor\n    /// @dev Given the address of NestPool, NToken can get other contracts by calling addrOfxxx()\n    /// @param _name The name of NToken\n    /// @param _symbol The symbol of NToken\n    /// @param gov The address of admin\n    /// @param NestPool The address of NestPool\n    constructor (string memory _name, string memory _symbol, address gov, address NestPool) public {\n    \tname = _name;                                                               \n    \tsymbol = _symbol;\n    \tcreatedAtHeight = block.number;\n    \tlastestMintAtHeight = block.number;\n    \tgovernance = gov;\n    \tC_NestPool = NestPool;\n        C_NestMining = INestPool(C_NestPool).addrOfNestMining();\n    }\n\n    modifier onlyGovernance() \n    {\n        require(msg.sender == governance, \"Nest:NTK:!gov\");\n        _;\n    }\n\n    /// @dev To ensure that all of governance-addresses be consist with each other\n    function loadGovernance() external \n    { \n        governance = INestPool(C_NestPool).governance();\n    }\n\n    function loadContracts() external onlyGovernance\n    {\n        C_NestMining = INestPool(C_NestPool).addrOfNestMining();\n    }\n\n    function resetNestPool(address _NestPool) external onlyGovernance\n    {\n        C_NestPool = _NestPool;\n    }\n\n    /// @dev Mint \n    /// @param amount The amount of NToken to add\n    /// @param account The account of NToken to add\n    function mint(uint256 amount, address account) override public {\n        require(address(msg.sender) == C_NestMining, \"Nest:NTK:!Auth\");\n        _balances[account] = _balances[account].add(amount);\n        _totalSupply = _totalSupply.add(amount);\n        lastestMintAtHeight = block.number;\n    }\n\n    /// @notice The view of totalSupply\n    /// @return The total supply of ntoken\n    function totalSupply() override public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @dev The view of balances\n    /// @param owner The address of an account\n    /// @return The balance of the account\n    function balanceOf(address owner) override public view returns (uint256) {\n        return _balances[owner];\n    }\n    \n    \n    /// @notice The view of variables about minting \n    /// @dev The naming follows Nestv3.0\n    /// @return createBlock The block number where the contract was created\n    /// @return recentlyUsedBlock The block number where the last minting went\n    function checkBlockInfo() \n        override public view \n        returns(uint256 createBlock, uint256 recentlyUsedBlock) \n    {\n        return (createdAtHeight, lastestMintAtHeight);\n    }\n\n    function allowance(address owner, address spender) override public view returns (uint256) \n    {\n        return _allowed[owner][spender];\n    }\n\n    function transfer(address to, uint256 value) override public returns (bool) \n    {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) override public returns (bool) \n    {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n\n    function transferFrom(address from, address to, uint256 value) override public returns (bool) \n    {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) \n    {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) \n    {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function _transfer(address from, address to, uint256 value) internal {\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n    \n    /// @dev The ABI keeps unchanged with old NTokens, so as to support token-and-ntoken-mining\n    /// @return The address of bidder\n    function checkBidder() override public view returns(address) {\n        return C_NestPool;\n    }\n}"
    },
    "contracts/NNRewardPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./iface/INestPool.sol\";\nimport \"./lib/SafeERC20.sol\";\nimport './lib/TransferHelper.sol';\nimport \"./iface/INestMining.sol\";\nimport \"./iface/INNRewardPool.sol\";\n\n/// @title NNRewardPool\n/// @author Inf Loop - \n/// @author Paradox  - \n\n/// @notice The NNRewardPool contract distributes the mining rewards,\n///     15% share of the amount of nest-token produced by miners\n/// @dev The nest-tokens are put in NestPool. This contract only traces \n///     the sum-amount of all of the rewards (nest-token)\n///   - NNToken is pre-deployed in Nest v3.0, so we should connect (legacy)\n///       with NNRewardPool. Whenever a NN holder transfers NN token to another,\n///       NNToken will call back NNRewardPool.nodeCount() to settle rewards (decisively)\n///       for both sender and receiver.\n///   - After upgrading, NNRewardPool will count rewards from zero. Any NN holder should\n///       claim rewards that had been issued before upgrading from the old contract. Old\n///       data about NN rewards will be dropped in this contract, while it can also accessible\n///       through OLD (Nest v3.0) contracts.\ncontract NNRewardPool is INNRewardPool {\n    using SafeMath for uint256;\n\n    /* ========== STATE ============== */\n\n    uint8   public flag;     // | 1: active \n                            // | 0: uninitialized\n                            // | 2: shutdown\n\n    uint8   constant NNREWARD_FLAG_UNINITIALIZED    = 0;\n    uint8   constant NNREWARD_FLAG_ACTIVE           = 1;\n    uint8   constant NNREWARD_FLAG_PAUSED           = 2;\n\n    uint256 public rewardSum;\n    uint256 public totalSupplyNN;\n\n    /// @dev From nest-node address to checkpoints of reward-sum\n    mapping(address => uint256) public rewardSumCheckpoint;\n\n    /* ========== ADDRESSES ============== */\n\n    address public C_NNToken;\n    address public C_NestToken;\n    address public C_NestPool;\n    address public C_NestMining;\n\n    address public governance;\n\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /// @notice Constructor of NNRewardPool contract\n    /// @dev The NNToken contract was created on the Ethereum mainnet \n    /// @param NestPool The address of NestPool Contract\n    /// @param NNToken The address of NestNode Token Contract\n    constructor(address NestPool, address NNToken) public\n    {\n        C_NestPool = NestPool;\n        C_NNToken = NNToken;\n        totalSupplyNN = uint128(ERC20(C_NNToken).totalSupply());\n        governance = msg.sender;\n        flag = NNREWARD_FLAG_UNINITIALIZED;\n    }\n\n    function start() external onlyGovernance\n    {\n        require(flag == NNREWARD_FLAG_UNINITIALIZED, \"Nest:NTC:!flag\");\n\n        flag = NNREWARD_FLAG_ACTIVE;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyBy(address _account)\n    {\n        require(msg.sender == _account, \"Nest:NN:!Auth\");\n        _;\n    }\n\n    modifier noContract() \n    {\n        require(address(msg.sender) == address(tx.origin), \"Nest:NN:BAN(contract)\");\n        _;\n    }\n\n    modifier onlyGovernance() \n    {\n        require(msg.sender == governance, \"Nest:NN:!governance\");\n        _;\n    }\n\n    modifier onlyGovOrBy(address _account)\n    {\n        if (msg.sender != governance) { \n            require(msg.sender == _account,\n                \"Nest:NN:!Auth\");\n        }\n        _;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    /// @dev To ensure that all of governance-addresses be consistent, every contract\n    ///        besides NestPool must load newest `governance` from NestPool.\n    function loadGovernance() override external \n    { \n        governance = INestPool(C_NestPool).governance();\n    }\n\n    /// @dev The function loads all nest-contracts, it is supposed to be called by NestPool\n    function loadContracts() override external onlyGovOrBy(C_NestPool)\n    {\n        C_NestToken = INestPool(C_NestPool).addrOfNestToken();\n        C_NNToken = INestPool(C_NestPool).addrOfNNToken();\n        C_NestMining = INestPool(C_NestPool).addrOfNestMining();    \n\n    }\n\n    /// @dev Stop service for emergency\n    function pause() external onlyGovernance\n    {\n        require(flag == NNREWARD_FLAG_ACTIVE, \"Nest:NN:!flag\");\n        flag = NNREWARD_FLAG_PAUSED;\n        emit FlagSet(address(msg.sender), uint256(NNREWARD_FLAG_PAUSED));\n    }\n\n    /// @dev Resume service \n    function resume() external onlyGovernance\n    {\n        require(flag == NNREWARD_FLAG_PAUSED, \"Nest:NN:!flag\");\n        flag = NNREWARD_FLAG_ACTIVE;\n        emit FlagSet(address(msg.sender), uint256(NNREWARD_FLAG_ACTIVE));\n    }\n\n    /* ========== ADDING REWARDS ========== */\n\n\n    /// @notice Add rewards for Nest-Nodes, only NestMining (contract) are allowed\n    /// @dev  The rewards need to pull from NestPool\n    /// @param _amount The amount of Nest token as the rewards to each nest-node\n    function addNNReward(uint256 _amount) override external onlyBy(C_NestMining)\n    {\n        if (_amount > 0) {\n            uint256 _newSum = uint256(rewardSum).add(_amount);\n            rewardSum = uint128(_newSum);\n            emit NNRewardAdded(_amount, _newSum);\n        }\n        return;\n    }\n\n    // /// @dev The updator is to update the sum of NEST tokens mined in NestMining\n    // function updateNNReward() external\n    // {\n    //     require(flag == NNREWARD_FLAG_ACTIVE, \"Nest:NN:!flag\");\n\n    //     uint256 _allMined = INestMining(C_NestMining).minedNestAmount();\n    //     if (_allMined > rewardSum) {\n    //         uint256 _amount = _allMined.mul(NN_REWARD_PERCENTAGE).div(100).sub(rewardSum);\n    //         uint256 _newSum = uint256(rewardSum).add(_amount);\n    //         rewardSum = uint128(_newSum);\n    //         emit NNRewardAdded(_amount, _newSum);\n    //     }\n    // }\n\n    // modifier updateNNReward1()\n    // {\n    //     require(flag == NNREWARD_FLAG_ACTIVE, \"Nest:NN:!flag\");\n\n    //     uint256 _allMined = INestMining(C_NestMining).minedNestAmount();\n    //     if (_allMined > rewardSum) {\n    //         uint256 _amount = _allMined.mul(NN_REWARD_PERCENTAGE).div(100).sub(rewardSum);\n    //         uint256 _newSum = uint256(rewardSum).add(_amount);\n    //         rewardSum = uint128(_newSum);\n    //         emit NNRewardAdded(_amount, _newSum);\n    //     }\n    //    _;\n    // }\n\n    /* ========== CLAIM/SETTLEMENT ========== */\n\n    /// @notice Claim rewards by Nest-Nodes\n    /// @dev The rewards need to pull from NestPool\n    function claimNNReward() override external noContract \n    {\n        require(flag == NNREWARD_FLAG_ACTIVE, \"Nest:NN:!flag\");\n\n        uint256 blnc =  ERC20(C_NNToken).balanceOf(address(msg.sender));\n        require(blnc > 0, \"Nest:NN:!(NNToken)\");\n        uint256 total = totalSupplyNN;\n        uint256 sum = rewardSum;\n        uint256 reward = sum.sub(rewardSumCheckpoint[address(msg.sender)]);\n        uint256 share = reward.mul(blnc).div(total);\n\n        rewardSumCheckpoint[address(msg.sender)] = sum;\n        emit NNRewardClaimed(address(msg.sender), share);\n     \n        INestPool(C_NestPool).withdrawNest(address(this), share);\n        require(ERC20(C_NestToken).transfer(address(msg.sender), share), \"Nest:NN:!TRANS\");\n        \n        return;\n    }\n\n    /// @notice Settle rewards for two NN holders\n    /// @dev The function is for callback from NNToken. It is banned for contracts.\n    /// @param from The address of the NN sender \n    /// @param to The address of the NN receiver \n    function settleNNReward(address from, address to) internal\n    {\n        require(flag == NNREWARD_FLAG_ACTIVE, \"Nest:NN:!flag\");\n\n        uint256 fromBlnc = ERC20(C_NNToken).balanceOf(address(from));\n        require (fromBlnc > 0, \"Nest:NN:!(fromBlnc)\");\n        uint256 sum = rewardSum;\n        uint256 total = totalSupplyNN;\n\n        uint256 fromReward = sum.sub(rewardSumCheckpoint[from]).mul(fromBlnc).div(total);      \n        rewardSumCheckpoint[from] = sum;      \n       \n        uint256 toBlnc = ERC20(C_NNToken).balanceOf(address(to));\n        uint256 toReward = sum.sub(rewardSumCheckpoint[to]).mul(toBlnc).div(total);\n        rewardSumCheckpoint[to] = sum;\n        \n        if (fromReward > 0) {\n            INestPool(C_NestPool).withdrawNest(address(this), fromReward);\n            require(ERC20(C_NestToken).transfer(from, fromReward), \"Nest:NN:!TRANS\");\n            emit NNRewardClaimed(from, uint128(fromReward));\n        }\n\n        if (toReward > 0) { \n            INestPool(C_NestPool).withdrawNest(address(this), toReward);\n            require(ERC20(C_NestToken).transfer(to, toReward), \"Nest:NN:!TRANS\");\n            emit NNRewardClaimed(to, uint128(toReward));\n        }\n\n        return;\n    }\n\n    /// @dev The callback function called by NNToken.transfer()\n    /// @param fromAdd The address of 'from' to transfer\n    /// @param toAdd The address of 'to' to transfer\n    function nodeCount(address fromAdd, address toAdd) \n        override\n        external\n        onlyBy(address(C_NNToken)) \n    {\n        settleNNReward(fromAdd, toAdd);\n        return;\n    }\n\n    /// @notice Show the amount of rewards unclaimed\n    /// @return reward The reward of a NN holder\n    function unclaimedNNReward() override external view returns (uint256 reward) \n    {\n        uint256 blnc = ERC20(C_NNToken).balanceOf(address(msg.sender));\n        uint256 sum = uint256(rewardSum);\n        uint256 total = uint256(totalSupplyNN);\n     \n        reward = sum.sub(rewardSumCheckpoint[address(msg.sender)]).mul(blnc).div(total);\n    }\n\n}"
    },
    "contracts/test/NNToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport \"../lib/SafeMath.sol\";\nimport \"../iface/INNRewardPool.sol\";\n\n\n/// @dev This contract is only for debugging. It will be replaced with `Superman` deployed on the mainnet.\ncontract NNToken {\n    using SafeMath for uint;\n\n    event Log(string msg);\n    event LogUint(string msg, uint256 v);\n    event LogAddress(string msg, address a);\n\n    INNRewardPool _C_NNRewardPool;\n\n    // string public constant name = \"Test Token\";\n    // string public constant symbol = \"TT\";\n    // uint8 public constant decimals = 18;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint  public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    // bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor(uint _totalSupply, string memory _symbol) public {\n        // _totalSupply = 1500;\n        _mint(msg.sender, _totalSupply);\n        name = \"xxx\";\n        symbol = _symbol;\n        decimals = 0;\n    }\n\n    function setContracts(address C_NNRewardPool) external {\n        _C_NNRewardPool = INNRewardPool(C_NNRewardPool);\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n\n        require (to != address(0), \"Cannot transfer to address(0)\");\n        _C_NNRewardPool.nodeCount(from, to);\n\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            // LogAddress(\"USDT.transferFrom> from\", from );\n            // LogAddress(\"USDT.transferFrom> msg.sender\", msg.sender );\n            // LogUint(\"USDT.transferFrom> allowance[from][msg.sender]\", allowance[from][msg.sender]);\n            // LogUint(\"USDT.transferFrom> value\", value);\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                // DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}"
    },
    "contracts/test/UERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.12;\n\nimport \"../lib/SafeMath.sol\";\n\ncontract UERC20 {\n    using SafeMath for uint;\n\n    event Log(string msg);\n    event LogUint(string msg, uint256 v);\n    event LogAddress(string msg, address a);\n\n    // string public constant name = \"Test Token\";\n    // string public constant symbol = \"TT\";\n    // uint8 public constant decimals = 18;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint  public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor(uint _totalSupply, string memory _name, string memory _symbol, uint8 _decimals) public {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        _mint(msg.sender, _totalSupply);\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            // LogAddress(\"USDT.transferFrom> from\", from );\n            // LogAddress(\"USDT.transferFrom> msg.sender\", msg.sender );\n            // LogUint(\"USDT.transferFrom> allowance[from][msg.sender]\", allowance[from][msg.sender]);\n            // LogUint(\"USDT.transferFrom> value\", value);\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}"
    },
    "contracts/NestVote.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/AddressPayable.sol\";\n\nimport \"./iface/INestMining.sol\";\nimport \"./iface/INestPool.sol\";\n\n\nimport \"./lib/SafeERC20.sol\";\nimport \"./lib/ReentrancyGuard.sol\";\nimport './lib/TransferHelper.sol';\n\n// import \"hardhat/console.sol\";\n\n\n/// @title NestVote\n/// @author Inf Loop - \n/// @author Paradox  - \n\ncontract NestVote is ReentrancyGuard {\n\n    using SafeMath for uint256;\n\n    /* ========== STATE ============== */\n\n    uint32 public voteDuration = 7 days;\n    uint32 public acceptance = 51;\n    uint256 public proposalStaking = 100_000 * 1e18;\n\n    struct Proposal {\n        string description;\n        uint32 state;  // 0: proposed | 1: accepted | 2: rejected\n        uint32 startTime;\n        uint32 endTime;\n        uint64 voters;\n        uint128 stakedNestAmount;\n        address contractAddr;\n        address proposer;\n        address executor;\n    }\n    \n    Proposal[] public proposalList;\n    mapping(uint256 => mapping(address => uint256)) public stakedNestAmount;\n\n    address private C_NestToken;\n    address private C_NestPool;\n    address private C_NestDAO;\n    address private C_NestMining;\n\n    address public governance;\n   \n    uint8 public  flag;\n    uint8 constant NESTVOTE_FLAG_UNINITIALIZED = 0;\n    uint8 constant NESTVOTE_FLAG_INITIALIZED   = 1;\n\n\n    /* ========== EVENTS ========== */\n\n    event NIPSubmitted(address proposer, uint256 id);\n    event NIPVoted(address voter, uint256 id, uint256 amount);\n    event NIPWithdraw(address voter, uint256 id, uint256 blnc);\n    event NIPRevoke(address voter, uint256 id, uint256 amount);\n    event NIPExecute(address executor, uint256 id);\n\n    /* ========== CONSTRUCTOR ========== */\n\n    receive() external payable {}\n\n    // NOTE: to support open-zeppelin/upgrades, leave it blank\n    constructor() public\n    {  }\n\n    // NOTE: can only be executed once\n    function initialize(address NestPool) external\n    {\n        require(flag == NESTVOTE_FLAG_UNINITIALIZED, \"Vote:init:!flag\" );\n\n        governance = msg.sender;\n        C_NestPool = NestPool;\n        flag = NESTVOTE_FLAG_INITIALIZED;\n\n    }\n\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyGovernance() \n    {\n        require(msg.sender == governance);\n        _;\n    }\n\n    modifier noContract() \n    {\n        require(address(msg.sender) == address(tx.origin), \"Nest:Vote:BAN(contract)\");\n        _;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    function loadGovernance() external \n    { \n        governance = INestPool(C_NestPool).governance();\n    }\n\n\n    function setGovernance(address _gov) external onlyGovernance\n    { \n        INestPool(C_NestPool).setGovernance(_gov);\n    }\n\n    function loadContracts() public onlyGovernance\n    {\n        C_NestToken = INestPool(C_NestPool).addrOfNestToken();\n        C_NestDAO = INestPool(C_NestPool).addrOfNestDAO();\n        C_NestMining = INestPool(C_NestPool).addrOfNestMining();\n    }\n\n    function releaseGovTo(address gov) public onlyGovernance\n    {\n        governance = gov;\n    }\n\n    function setParams(uint32 voteDuration_, uint32 acceptance_, uint256 proposalStaking_) \n        public onlyGovernance\n    {\n        acceptance = acceptance_;\n        voteDuration = voteDuration_;\n        proposalStaking = proposalStaking_;\n    }\n\n    /* ========== VOTE ========== */\n    \n    function propose(address contract_, string memory description) external\n    {\n        uint256 id = proposalList.length;\n        proposalList.push(Proposal(\n            string(description),\n            uint32(0),                   // state\n            uint32(block.timestamp),    //startTime\n            uint32(block.timestamp + voteDuration),  //endTime\n            uint64(0),                  // voters\n            uint128(0),                 // stakedNestAmount\n            contract_,                 //contractAddr\n            address(msg.sender),        // proposer\n            address(0)                 // executor\n         ));\n\n        ERC20(C_NestToken).transferFrom(address(msg.sender), address(this), proposalStaking);\n\n        emit NIPSubmitted(msg.sender, id);\n    }\n\n    function vote(uint256 id, uint256 amount) external noContract\n    {\n        Proposal memory p = proposalList[id];\n        require (block.timestamp <= p.endTime, \"Nest:Vote:!time\");\n        uint256 blncs = stakedNestAmount[id][address(msg.sender)];\n        stakedNestAmount[id][address(msg.sender)] = blncs.add(amount); \n        p.stakedNestAmount = uint128(uint256(p.stakedNestAmount).add(amount));\n        if (blncs == 0) {\n            p.voters = uint64(uint256(p.voters).add(1));\n\n        }\n        proposalList[id] = p;\n\n        ERC20(C_NestToken).transferFrom(address(msg.sender), address(this), amount);\n\n        emit NIPVoted(msg.sender, id, amount);\n    }\n\n    function withdraw(uint256 id) external noContract\n    {\n        Proposal memory p = proposalList[id];\n        require (p.state > 0, \"Nest:Vote:!state\");\n\n        uint256 blnc = stakedNestAmount[id][address(msg.sender)];\n        p.stakedNestAmount = uint128(uint256(p.stakedNestAmount).sub(blnc));\n        stakedNestAmount[id][address(msg.sender)] = 0;\n\n        proposalList[id] = p;\n\n        ERC20(C_NestToken).transfer(address(msg.sender), blnc);\n\n        emit NIPWithdraw(msg.sender, id, blnc);\n    }\n\n    function revoke(uint256 id, uint256 amount) external noContract\n    {\n        Proposal memory p = proposalList[id];\n\n        require (uint256(block.timestamp) <= uint256(p.endTime), \"Nest:Vote:!time\");\n\n        uint256 blnc = stakedNestAmount[id][address(msg.sender)];\n        require(blnc >= amount, \"Nest:Vote:!amount\"); \n        if (blnc == amount) {\n            p.voters = uint64(uint256(p.voters).sub(1));\n        }\n\n        p.stakedNestAmount = uint128(uint256(p.stakedNestAmount).sub(amount));\n        stakedNestAmount[id][address(msg.sender)] = blnc.sub(amount);\n\n        proposalList[id] = p;\n\n        ERC20(C_NestToken).transfer(address(msg.sender), amount);\n\n        emit NIPRevoke(msg.sender, id, amount);\n    }\n\n    function execute(uint256 id) external\n    {\n        uint256 _total_mined = INestMining(C_NestMining).minedNestAmount();\n        uint256 _burned = ERC20(C_NestToken).balanceOf(address(0x1));\n        uint256 _repurchased = ERC20(C_NestToken).balanceOf(C_NestDAO);\n\n        uint256 _circulation = _total_mined.sub(_repurchased).sub(_burned);\n\n        Proposal storage p = proposalList[id];\n        require (p.state == 0, \"Nest:Vote:!state\");\n        require (p.endTime < block.timestamp, \"Nest:Vote:!time\");\n\n        if (p.stakedNestAmount > _circulation.mul(acceptance).div(100)) {\n            address _contract = p.contractAddr;\n            (bool success, bytes memory result) = _contract.delegatecall(abi.encodeWithSignature(\"run()\"));\n            require(success, \"Nest:Vote:!exec\");\n            p.state = 1;\n        } else {\n            p.state = 2;\n        }\n        p.executor = address(msg.sender);\n\n        proposalList[id] = p;\n        \n        ERC20(C_NestToken).transfer(p.proposer, proposalStaking);\n\n        emit NIPExecute(msg.sender, id);\n    }\n\n    function stakedNestNum(uint256 id) public view returns (uint256) \n    {\n        Proposal storage p = proposalList[id];\n        //return (uint256(p.stakedNestAmount).div(1e18));\n        return (uint256(p.stakedNestAmount));\n    }\n\n    function numberOfVoters(uint256 id) public view returns (uint256) \n    {\n        Proposal storage p = proposalList[id];\n        return (uint256(p.voters));\n    }\n\n}"
    },
    "contracts/lib/AddressPayable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nlibrary address_make_payable {\n   function make_payable(address x) internal pure returns (address payable) {\n      return address(uint160(x));\n   }\n}"
    },
    "contracts/NestStaking.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/AddressPayable.sol\";\n\nimport \"./iface/INestPool.sol\";\nimport \"./iface/INestStaking.sol\";\n\nimport \"./lib/SafeERC20.sol\";\nimport \"./lib/ReentrancyGuard.sol\";\nimport './lib/TransferHelper.sol';\n\n/// @title NestStaking\n/// @author Inf Loop - \n/// @author Paradox  - \n\ncontract NestStaking is INestStaking, ReentrancyGuard {\n\n    using SafeMath for uint256;\n\n    /* ========== STATE ============== */\n\n    /// @dev  The flag of staking global state\n    uint8 public flag;      // = 0: uninitialized\n                            // = 1: active\n                            // = 2: no staking\n                            // = 3: paused \n\n    uint248 private _reserved1;\n\n    uint8 constant STAKING_FLAG_UNINITIALIZED    = 0;\n    uint8 constant STAKING_FLAG_ACTIVE           = 1;\n    uint8 constant STAKING_FLAG_NO_STAKING       = 2;\n    uint8 constant STAKING_FLAG_PAUSED           = 3;\n\n    /// @dev The balance of savings w.r.t a ntoken(or nest-token)\n    ///     _pending_saving_Amount: ntoken => saving amount\n    //mapping(address => uint256) private _pending_saving_amount;\n\n    /// @dev The per-ntoken-reward (ETH) w.r.t a ntoken(or nest-token)\n    ///     _reward_per_ntoken_stored: ntoken => amount\n    mapping(address => uint256) private _reward_per_ntoken_stored;\n\n    // _reward_per_ntoken_claimed: (ntoken, acount, amount) => amount\n    mapping(address => mapping(address => uint256)) _reward_per_ntoken_claimed;\n\n    // ntoken => last reward \n    mapping(address => uint256) public lastRewardsTotal;\n\n    // _ntoken_total: ntoken => amount\n    mapping(address => uint256) _ntoken_staked_total;\n\n    // _staked_balances: (ntoken, account) => amount\n    mapping(address => mapping(address => uint256)) private _staked_balances;\n\n    // rewardsTotal: (ntoken) => amount\n    mapping(address => uint256) public rewardsTotal;\n    \n    // _rewards_balances: (ntoken, account) => amount\n    mapping(address => mapping(address => uint256)) public rewardBalances;\n\n    /* ========== PARAMETERS ============== */\n    \n    /// @dev The percentage of dividends \n    uint8 private _dividend_share; // = 100 as default;\n\n    uint8 constant STAKING_DIVIDEND_SHARE_PRECENTAGE = 100;\n\n    uint248 private _reserved2;\n\n    /* ========== ADDRESSES ============== */\n\n    address private C_NestToken;\n    address private C_NestPool;\n\n    address private governance;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    receive() external payable {}\n\n    // NOTE: to support open-zeppelin/upgrades, leave it blank\n    constructor() public { }\n\n    /// @dev It is called by the proxy (open-zeppelin/upgrades), only ONCE!\n    function initialize(address NestPool) external \n    {\n        require(flag == STAKING_FLAG_UNINITIALIZED, \"Nest:Stak:!flag\");\n        governance = msg.sender;\n        _dividend_share = STAKING_DIVIDEND_SHARE_PRECENTAGE;\n        flag = STAKING_FLAG_ACTIVE;\n        C_NestPool = NestPool;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyGovOrBy(address _contract) \n    {\n        require(msg.sender == governance || msg.sender == _contract, \"Nest:Stak:!sender\");\n        _;\n    }\n\n    modifier whenActive() \n    {\n        require(flag == STAKING_FLAG_ACTIVE, \"Nest:Stak:!flag\");\n        _;\n    }\n\n    modifier onlyGovernance() \n    {\n        require(msg.sender == governance, \"Nest:Stak:!gov\");\n        _;\n    }\n\n    mapping(uint256 => mapping(address => bool)) private _status;\n\n    modifier onlyOneBlock() {\n        require(\n            !_status[block.number][tx.origin],\n            'Nest:Stak:!block'\n        );\n        require(\n            !_status[block.number][msg.sender],\n            'Nest:Stak:!block'\n        );\n\n        _;\n\n        _status[block.number][tx.origin] = true;\n        _status[block.number][msg.sender] = true;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    function loadContracts() override external onlyGovOrBy(C_NestPool)\n    {\n        C_NestToken = INestPool(C_NestPool).addrOfNestToken();\n    }\n\n    /// @dev To ensure that all of governance-addresses be consist with each other\n    function loadGovernance() override external \n    { \n        governance = INestPool(C_NestPool).governance();\n    }\n\n    /// @dev Stop service for emergency\n    function pause() override external onlyGovernance\n    {\n        require(flag == STAKING_FLAG_ACTIVE, \"Nest:Stak:!flag\");\n        flag = STAKING_FLAG_PAUSED;\n        emit FlagSet(address(msg.sender), uint256(STAKING_FLAG_PAUSED));\n    }\n\n    /// @dev Resume service \n    function resume() override external onlyGovernance\n    {\n        require(flag == STAKING_FLAG_PAUSED, \"Nest:Stak:!flag\");\n        flag = STAKING_FLAG_ACTIVE;\n        emit FlagSet(address(msg.sender), uint256(STAKING_FLAG_ACTIVE));\n    }\n\n    /*\n    // exist bug\n    function withdrawSavingByGov(address ntoken, address to, uint256 amount) \n        external \n        nonReentrant \n        onlyGovernance \n    {\n        require(flag == STAKING_FLAG_PAUSED, \"Nest:Stak:!flag\");\n\n        _pending_saving_amount[ntoken] = _pending_saving_amount[ntoken].sub(amount);\n\n        // must refresh WETH balance record after updating WETH balance\n        // or lastRewardsTotal could be less than the newest WETH balance in the next update\n        uint256 _newTotal = rewardsTotal[ntoken].sub(amount);\n        lastRewardsTotal[ntoken] = _newTotal;\n        rewardsTotal[ntoken] = _newTotal;\n        emit SavingWithdrawn(ntoken, to, amount);\n        TransferHelper.safeTransferETH(to, amount);      \n    }\n   \n    function setParams(uint8 dividendShareRate) override external onlyGovernance\n    {\n        if (dividendShareRate > 0 && dividendShareRate <= 100) {\n            _dividend_share = dividendShareRate;\n        }\n    }\n    */\n    /* ========== VIEWS ========== */\n    /*\n    function totalSaving(address ntoken)\n        external view returns (uint256) \n    {\n       return  _pending_saving_amount[ntoken];\n    }\n    */\n    function totalRewards(address ntoken)\n        external view returns (uint256) \n    {\n       return  rewardsTotal[ntoken];\n    }\n\n    function totalStaked(address ntoken) \n        external override view returns (uint256) \n    {\n        return _ntoken_staked_total[ntoken];\n    }\n\n    function stakedBalanceOf(address ntoken, address account) \n        external override view returns (uint256) \n    {\n        return _staked_balances[ntoken][account];\n    }\n\n    // CM:  =  + ( * _dividend_share% / ) \n    function rewardPerToken(address ntoken) \n        public \n        view \n        returns (uint256) \n    {\n        uint256 _total = _ntoken_staked_total[ntoken];\n        if (_total == 0) {\n            // use the old rewardPerTokenStored\n            // if not, the new accrued amount will never be distributed to anyone\n            return _reward_per_ntoken_stored[ntoken];\n        }\n        uint256 _rewardPerToken = _reward_per_ntoken_stored[ntoken].add(\n                accrued(ntoken).mul(1e18).mul(_dividend_share).div(_total).div(100)\n            );\n        return _rewardPerToken;\n    }\n\n    // CM:  =  - \n    function accrued(address ntoken) \n        public \n        view \n        returns (uint256) \n    {\n        // eth increment of eth since last update\n        uint256 _newest = rewardsTotal[ntoken];\n        // lastest must be larger than lastUpdate\n        return _newest.sub(lastRewardsTotal[ntoken]); \n    }\n\n    // CM:  = [ * ( - ) / 1e18] + \n    function earned(address ntoken, address account) \n        public \n        view \n        returns (uint256) \n    {\n        return _staked_balances[ntoken][account].mul(\n                        rewardPerToken(ntoken).sub(_reward_per_ntoken_claimed[ntoken][account])\n                    ).div(1e18).add(rewardBalances[ntoken][account]);\n    }\n    /*  // it is extra\n    // calculate\n    function _rewardPerTokenAndAccrued(address ntoken) \n        internal\n        view \n        returns (uint256, uint256) \n    {\n        uint256 _total = _ntoken_staked_total[ntoken];\n        if (_total == 0) {\n            // use the old rewardPerTokenStored, and accrued should be zero here\n            // if not the new accrued amount will never be distributed to anyone\n            return (_reward_per_ntoken_stored[ntoken], 0);\n        }\n        uint256 _accrued = accrued(ntoken);\n        uint256 _rewardPerToken = _reward_per_ntoken_stored[ntoken].add(\n                _accrued.mul(1e18).mul(_dividend_share).div(_total).div(100) \n            ); // 80% of accrued to NEST holders as dividend\n        return (_rewardPerToken, _accrued);\n    }\n    */\n    /* ========== STAK/UNSTAK/CLAIM ========== */\n\n    modifier updateReward(address ntoken, address account) \n    {\n        uint256 _total = _ntoken_staked_total[ntoken];\n        uint256 _accrued = rewardsTotal[ntoken].sub(lastRewardsTotal[ntoken]);\n        uint256 _rewardPerToken;      \n\n        if (_total == 0) {\n            // use the old rewardPerTokenStored, and accrued should be zero here\n            // if not the new accrued amount will never be distributed to anyone\n            _rewardPerToken = _reward_per_ntoken_stored[ntoken];\n        } else {\n            // 80% of accrued to NEST holders as dividend\n            _rewardPerToken = _reward_per_ntoken_stored[ntoken].add(\n                _accrued.mul(1e18).mul(_dividend_share).div(_total).div(100) \n            );\n            // update _reward_per_ntoken_stored\n            _reward_per_ntoken_stored[ntoken] = _rewardPerToken;\n            lastRewardsTotal[ntoken] = rewardsTotal[ntoken];\n            //uint256 _newSaving = _accrued.sub(_accrued.mul(_dividend_share).div(100)); // left 20%\n            //_pending_saving_amount[ntoken] = _pending_saving_amount[ntoken].add(_newSaving);\n        }\n\n        uint256 _newEarned = _staked_balances[ntoken][account].mul(\n                _rewardPerToken.sub(_reward_per_ntoken_claimed[ntoken][account])\n            ).div(1e18);\n\n        if (account != address(0)) { // Q: redundant\n            rewardBalances[ntoken][account] = rewardBalances[ntoken][account].add(_newEarned);\n            _reward_per_ntoken_claimed[ntoken][account] = _reward_per_ntoken_stored[ntoken];\n        }\n        _;\n    }\n\n    /// @notice Stake NTokens to get the dividends\n    function stake(address ntoken, uint256 amount)\n        external \n        override \n        nonReentrant \n        onlyOneBlock\n        whenActive\n        updateReward(ntoken, msg.sender) \n    {\n        require(amount > 0, \"Nest:Stak:!amount\");\n        _ntoken_staked_total[ntoken] = _ntoken_staked_total[ntoken].add(amount);\n        _staked_balances[ntoken][msg.sender] = _staked_balances[ntoken][msg.sender].add(amount);\n        //TransferHelper.safeTransferFrom(ntoken, msg.sender, address(this), amount);\n        emit NTokenStaked(ntoken, msg.sender, amount);\n        TransferHelper.safeTransferFrom(ntoken, msg.sender, address(this), amount);\n\n    }\n\n    /// @notice Stake NTokens to get the dividends\n    function stakeFromNestPool(address ntoken, uint256 amount) \n        external \n        override \n        nonReentrant \n        onlyOneBlock\n        whenActive\n        updateReward(ntoken, msg.sender) \n    {\n        require(amount > 0, \"Nest:Stak:!amount\");\n        _ntoken_staked_total[ntoken] = _ntoken_staked_total[ntoken].add(amount);\n        _staked_balances[ntoken][msg.sender] = _staked_balances[ntoken][msg.sender].add(amount);\n        INestPool(C_NestPool).withdrawNTokenAndTransfer(msg.sender, ntoken, amount, address(this));\n        emit NTokenStaked(ntoken, msg.sender, amount);\n    }\n\n    /// @notice Unstake NTokens\n    function unstake(address ntoken, uint256 amount) \n        public \n        override \n        nonReentrant \n        onlyOneBlock\n        whenActive\n        updateReward(ntoken, msg.sender)\n    {\n        require(amount > 0, \"Nest:Stak:!amount\");\n        _ntoken_staked_total[ntoken] = _ntoken_staked_total[ntoken].sub(amount);\n        _staked_balances[ntoken][msg.sender] = _staked_balances[ntoken][msg.sender].sub(amount);\n        //TransferHelper.safeTransfer(ntoken, msg.sender, amount);\n        emit NTokenUnstaked(ntoken, msg.sender, amount);\n        TransferHelper.safeTransfer(ntoken, msg.sender, amount);\n\n    }\n\n    /// @notice Claim rewards\n    function claim(address ntoken) \n        public \n        override \n        nonReentrant \n        whenActive\n        updateReward(ntoken, msg.sender) \n        returns (uint256)\n    {\n        uint256 _reward = rewardBalances[ntoken][msg.sender];\n        if (_reward > 0) {\n            rewardBalances[ntoken][msg.sender] = 0;\n            // WETH balance decreased after this\n            //TransferHelper.safeTransferETH(msg.sender, _reward);\n            // must refresh WETH balance record after updating WETH balance\n            // or lastRewardsTotal could be less than the newest WETH balance in the next update\n            uint256 _newTotal = rewardsTotal[ntoken].sub(_reward);\n            lastRewardsTotal[ntoken] = _newTotal;\n            rewardsTotal[ntoken] = _newTotal;         \n           \n            emit RewardClaimed(ntoken, msg.sender, _reward);\n\n             TransferHelper.safeTransferETH(msg.sender, _reward);\n        }\n        return _reward;\n    }\n\n    /* ========== INTER-CALLS ========== */\n\n    function addETHReward(address ntoken) \n        override \n        external \n        payable \n    {\n        // NOTE: no need to update reward here\n        // support for sending ETH for rewards\n        rewardsTotal[ntoken] = rewardsTotal[ntoken].add(msg.value); \n    }\n\n}\n"
    },
    "contracts/NestQueryV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/SafeERC20.sol\";\nimport './lib/TransferHelper.sol';\nimport \"./lib/ReentrancyGuard.sol\";\n\nimport \"./iface/INestPool.sol\";\nimport \"./iface/INestStaking.sol\";\nimport \"./iface/INToken.sol\";\nimport \"./iface/INestQuery.sol\";\nimport \"./iface/INestMining.sol\";\nimport \"./iface/INestDAO.sol\";\n\n/// @title NestQuery\n/// @author Inf Loop - \n/// @author Paradox  - \ncontract NestQuery is INestQuery, ReentrancyGuard {\n\n    using SafeMath for uint256;\n\n    /* ========== STATE ============== */\n\n    /// @notice The flag is the running status of NestQuery contract\n    /// @dev The flag is in {0, 1, 2}\n    /// @return The value of flag\n    uint8   public flag;\n    uint248 private _reserved;\n\n    // flag == 0: the contract needs initialization\n    // flag == 1: the contract is active after initialization\n    // flag == 2: the contract is shutdown, user interfaces like query() are closed,\n    //              while the governor has privileges to rescue\n    uint8  constant QUERY_FLAG_UNINITIALIZED = 0;\n    uint8  constant QUERY_FLAG_ACTIVE        = 1;\n    uint8  constant QUERY_FLAG_PAUSED        = 2;\n\n    struct Client {\n        uint64 startTime;\n        uint64 endTime;  // endTime==0 for non-monthly clients\n        uint32 fee;\n        uint32 typ;     // =1: PPQ | =2: PPM (forbidden for the moment)\n        uint64 _reserved;\n    }\n\n    /// @dev Here we only support pay-per-query clients. \n    ///     The other type (pay-per-month) isn't supported currently.\n    uint32 constant CLIENT_TYPE_PAY_PER_QUERY = 1;\n    // uint32 constant CLIENT_TYPE_PAY_PER_MONTH = 2;\n\n    mapping(address => uint256) public clientList;\n    mapping(address => address) public clientOp;\n\n    /* ========== PARAMETERS ============== */\n\n    /// @dev The four paramters are encoded into a uin256 slot to save GAS. Currently only four\n    ///        uint32 pieces are used, leaving sufficient spaces for later upgrading.\n    struct Params {\n        uint32 singleFeeEthTWei;            // Twei = 1e12\n        uint32 activationTime;              // second\n        uint32 activationFeeNestNum;        // 1 NEST = 1e18\n        uint32 _reserved2;\n    }\n\n    uint256 private paramsEncoded;\n\n    /// @dev The default values of parameters. They shall be setup via `setParams()` before \n    ///     the contract starts to rotates.\n    uint32  constant CLIENT_QUERY_FEE_ETH_TWEI = (0.01 ether) / 1e12;\n    uint32  constant CLIENT_ACTIVATION_NEST_AMOUNT = 0;\n    uint32  constant CLIENT_MONTHLY_FEE_NEST_AMOUNT = 0;\n    uint32  constant CLIENT_ACTIVATION_DURATION_SECOND = 10;\n\n    /* ========== ADDRESSES ============== */\n\n    /// @dev The contract variables for other contracts' addresses, loaded from NestPool\n    address    private C_NestToken;\n    address    private C_NestMining;\n    address    private C_NestPool;\n    address    private C_NestStaking;\n    address    private C_NestDAO;\n\n    /// @dev The governor's address, which is loaded from NestPool.\n    address public governance;\n\n    /* ========== CONSTRUCTOR ============== */\n\n    receive() external payable { }\n\n    // NOTE: to support open-zeppelin/upgrades, leave it blank\n    constructor() public { }\n\n    /// @dev It is supposedly called by the proxy (open-zeppelin/upgrades), only ONCE!\n    function initialize(address NestPool) external \n    { \n        require(flag == QUERY_FLAG_UNINITIALIZED, \"Nest:Qury:!flag\");\n        governance = address(msg.sender); \n        C_NestPool = NestPool;\n        uint32 _actFee = CLIENT_ACTIVATION_NEST_AMOUNT;\n        uint32 _singleFee = CLIENT_QUERY_FEE_ETH_TWEI;\n        uint32 _actTime = CLIENT_ACTIVATION_DURATION_SECOND;\n        paramsEncoded = encode_4x32_256(_singleFee, _actTime, _actFee, 0);\n        flag = QUERY_FLAG_ACTIVE;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier whenActive() \n    {\n        require(flag == QUERY_FLAG_ACTIVE, \"Nest:Qury:!flag\");\n        _;\n    }\n\n    modifier onlyGovernance() \n    {\n        require(msg.sender == governance, \"Nest:Qury:!governance\");\n        _;\n    }\n\n    modifier onlyGovOrBy(address _account)\n    {\n        if (msg.sender != governance) { \n            require(msg.sender == _account,\n                \"Nest:Qury:!Auth\");\n        }\n        _;\n    }\n    \n    /*\n    modifier onlyBy(address _contract)\n    {\n        require(msg.sender == _contract, \"Nest:Qury:!Auth\");\n        _;\n    }*/\n\n    modifier noContract() \n    {\n        require(address(msg.sender) == address(tx.origin), \"Nest:Qury:BAN(contract)\");\n        _;\n    }\n\n     /* ========== GOVERNANCE ========== */\n\n    /// @dev To ensure that all of governance-addresses be consist with each other, every contract\n    ///        besides NestPool must load newest `governance` from NestPool.\n    function loadGovernance() override external \n    { \n        governance = INestPool(C_NestPool).governance();\n    }\n\n    /// @notice Setup the parameters for queryings, one price for all token\n    /// @dev    Parameters can be reset by set time to zero\n    function setParams(uint256 single, uint32 time, uint256 nestAmount) \n        public \n        onlyGovernance\n    {\n        (uint32 _singleFee, uint32 _time, uint32 _actFee, uint32 _res) =  decode_4x32_256(paramsEncoded);\n\n        _singleFee = uint32(single);\n        _time = uint32(time);\n        _actFee = uint32(nestAmount / 1e18);\n    \n        uint256 oldParamsEncoded = paramsEncoded;\n\n        paramsEncoded = encode_4x32_256(_singleFee, _time, _actFee, _res);\n\n        emit ParamsSetup(address(msg.sender), oldParamsEncoded, paramsEncoded);\n    }\n\n    function params() external view \n        returns(uint256 single, uint64 leadTime, uint256 nestAmount) \n    {\n        (uint32 _singleFee, uint32 _time, uint32 _actFee, uint32 _res) =  decode_4x32_256(paramsEncoded);\n        single = uint256(_singleFee).mul(1e12);\n        leadTime = uint64(_time);\n        nestAmount = uint256(_actFee).mul(1e18);\n\n    }\n\n    function loadContracts() override external onlyGovOrBy(C_NestPool)\n    {\n        C_NestToken = INestPool(C_NestPool).addrOfNestToken();\n        C_NestMining = INestPool(C_NestPool).addrOfNestMining();\n        C_NestStaking = INestPool(C_NestPool).addrOfNestStaking();\n        C_NestDAO = INestPool(C_NestPool).addrOfNestDAO();\n    }\n\n    /// @dev Remove a client if something goes wrong\n    /// @param defi The address of a client (defi DApp)\n    function remove(address defi) \n        external \n        onlyGovernance\n    {\n        clientList[defi] = encodeClient(0, 0, 0, 0);\n        clientOp[defi] = address(0);\n    }\n\n    // /// @dev  The balance of NEST\n    // /// @return  The amount of NEST tokens for this contract\n    // function balanceNest() override external view returns (uint256) \n    // {\n    //     return ERC20(C_NestToken).balanceOf(address(this));\n    // }\n\n    // /// @dev  The balance of NEST\n    // /// @return  The amount of ethers withheld by this contract\n    // function balanceEth() override external view returns (uint256) \n    // {\n    //     return address(this).balance;\n    // }\n\n    /* ========== EMERGENCY ========== */\n\n    /// @dev Stop service for emergency\n    function pause() external onlyGovernance\n    {\n        require(flag == QUERY_FLAG_ACTIVE, \"Nest:Qury:!flag\");\n\n        flag = QUERY_FLAG_PAUSED;\n        emit FlagSet(address(msg.sender), uint256(QUERY_FLAG_PAUSED));\n    }\n\n    /// @dev Resume service \n    function resume() external onlyGovernance\n    {\n        require(flag == QUERY_FLAG_PAUSED, \"Nest:Qury:!flag\");\n\n        flag = QUERY_FLAG_ACTIVE;\n        emit FlagSet(address(msg.sender), uint256(QUERY_FLAG_ACTIVE));\n    }\n\n    /* ========== CLIENT ========== */\n\n    /// @notice Activate a pay-per-query defi client with NEST tokens\n    /// @dev No contract is allowed to call it\n    /// @param defi The addres of client (DeFi DApp)\n    function activate(address defi) \n        override external noContract whenActive\n    {\n        if (defi == address(0)) {\n            defi = address(msg.sender);\n        }\n        Client memory _c = decodeClient(clientList[defi]);\n        require (_c.typ == 0, \"Nest:Qury:EX(client)\");\n        (, uint32 _actTime, uint256 _actFee, ) = decode_4x32_256(paramsEncoded);          \n        uint256 _nestFee = _actFee.mul(1e18);\n        uint256 _start = uint64(block.timestamp.add(_actTime));\n        uint256 _end = 0;\n        uint256 _mfee = 0;\n        clientList[defi] = encodeClient(uint64(_start), uint64(_end), uint32(_mfee), 0x1);\n        clientOp[defi] = address(msg.sender);\n        emit ClientActivated(defi, _start, _end);\n        require(ERC20(C_NestToken).transferFrom(\n            address(msg.sender), \n            address(C_NestDAO), \n            _nestFee), \"Nest:Qury:!transfer\");\n    }\n\n    /// @notice Deactivate a pay-per-query defi client\n    /// @param defi The address of a client (DeFi DApp)\n    function deactivate(address defi) \n        override \n        external \n        whenActive\n    {\n        if (defi == address(0)) {\n            defi = address(msg.sender);\n        }\n        require(address(msg.sender) == clientOp[defi], \"Nest:Qury:!Op\");\n        clientList[defi] = encodeClient(0, 0, 0, 0);\n        clientOp[defi] = address(0);\n    }\n\n    /// @notice Query for PPQ (pay-per-query) clients\n    /// @dev Consider that if a user call a DeFi that queries NestQuery, DeFi should\n    ///     pass the user's wallet address to query() as `payback`.\n    /// @param token The address of token contract\n    /// @param payback The address of change\n    function query(address token, address payback) \n        override \n        public \n        payable \n        whenActive\n        nonReentrant\n        returns (uint256, uint256, uint256) \n    {\n        // check parameters\n        Client memory c = decodeClient(clientList[address(msg.sender)]);\n        require(c.typ == CLIENT_TYPE_PAY_PER_QUERY, \"Nest:Qury:=!(client.typ)\");\n        require(c.startTime != 0 && uint256(c.startTime) < block.timestamp \n            && uint256(c.endTime) == 0, \"Nest:Qury:!(client.time)\");\n\n        // lookup the latest effective price\n        (uint256 ethAmount, uint256 tokenAmount, uint256 bn) = INestMining(C_NestMining).latestPriceOf(token);\n        (uint256 _single, , , ) = decode_4x32_256(paramsEncoded);  \n\n        {\n            address _ntoken = INestPool(C_NestPool).getNTokenFromToken(token); \n            uint256 _ethFee = _single.mul(1e12);   // NOTE: the unit of _single is TWei\n            INestDAO(C_NestDAO).addETHReward{value:_ethFee}(address(_ntoken));\n\n            // return change\n            if (payback != address(0) && msg.value > _ethFee) {\n                TransferHelper.safeTransferETH(payback, msg.value.sub(_ethFee));\n            }\n        }\n    \n        emit PriceQueried(address(msg.sender), token, ethAmount, tokenAmount, bn);\n        return (ethAmount, tokenAmount, uint256(bn));\n    }\n\n    /// @notice Query for PPQ (pay-per-query) clients\n    /// @param token The address of token contract\n    /// @param payback The address of change\n    /// @return ethAmount The amount of ETH in pair (ETH, TOKEN)\n    /// @return tokenAmount The amount of TOKEN in pair (ETH, TOKEN)\n    /// @return avgPrice The average of last 50 prices \n    /// @return vola The volatility of prices \n    /// @return bn The block number when (ETH, TOKEN) takes into effective\n    function queryPriceAvgVola(address token, address payback)\n        override \n        external \n        payable \n        whenActive\n        nonReentrant\n        returns (uint256 ethAmount, uint256 tokenAmount, uint128 avgPrice, int128 vola, uint256 bn) \n    {\n        // check parameters\n        Client memory c = decodeClient(clientList[address(msg.sender)]);\n        require (c.typ == CLIENT_TYPE_PAY_PER_QUERY, \"Nest:Qury:=!(client.typ)\");\n        require(c.startTime != 0 && uint256(c.startTime) < block.timestamp \n            && uint256(c.endTime) == 0, \"Nest:Qury:!(client.time)\");\n\n        (ethAmount, tokenAmount, bn) = INestMining(C_NestMining).latestPriceOf(token);\n        (, avgPrice, vola,) = INestMining(C_NestMining).priceAvgAndSigmaOf(token);\n\n        {\n            (uint256 _single, , , ) = decode_4x32_256(paramsEncoded);  \n            address _ntoken = INestPool(C_NestPool).getNTokenFromToken(token); \n            uint256 _ethFee = _single.mul(1e12);   // NOTE: the unit of _single is TWei\n            INestDAO(C_NestDAO).addETHReward{value:_ethFee}(address(_ntoken));\n\n            // charge back\n            if (payback != address(0) && msg.value > _ethFee) {\n                TransferHelper.safeTransferETH(payback, msg.value.sub(_ethFee));\n            }\n        }\n        emit PriceAvgVolaQueried(address(msg.sender), token, bn, avgPrice, vola);\n\n    }\n    \n    /// @notice The main function called by DeFi clients, compatible to Nest Protocol v3.0 \n    /// @dev  The payback address is ZERO, so the changes are kept in this contract\n    ///         The ABI keeps consist with Nest v3.0\n    /// @param tokenAddress The address of token contract address\n    /// @return ethAmount The amount of ETH in price pair (ETH, ERC20)\n    /// @return erc20Amount The amount of ERC20 in price pair (ETH, ERC20)\n    /// @return blockNum The block.number where the price is being in effect\n    function updateAndCheckPriceNow(\n            address tokenAddress\n        ) \n        override\n        public \n        payable \n        whenActive\n        returns(uint256 ethAmount, uint256 erc20Amount, uint256 blockNum) \n    {\n        return query(tokenAddress, address(msg.sender));\n    }\n\n    /// @notice A non-free function for querying price \n    /// @param token  The address of the token contract\n    /// @param num    The number of price sheets in the list\n    /// @param payback The address for change\n    /// @return The array of prices, each of which is (blockNnumber, ethAmount, tokenAmount)\n    function queryPriceList(address token, uint8 num, address payback) \n        override public payable \n        whenActive\n        returns (uint128[] memory) \n    {\n        // check client \n        Client memory c = decodeClient(clientList[address(msg.sender)]);\n        require(c.typ == CLIENT_TYPE_PAY_PER_QUERY, \"Nest:Qury:=!(client.typ)\");\n        require(c.startTime != 0 && uint256(c.startTime) < block.timestamp \n            && uint256(c.endTime) == 0, \"Nest:Qury:!(client.time)\");\n\n        // retrieve the historical price list\n        (uint128[] memory data, uint256 bn) = INestMining(C_NestMining).priceListOfToken(token, num);\n        // require(miner != address(0x0), \"miner null\");\n\n        // get the associated NTOKEN with token\n        address _ntoken = INestPool(C_NestPool).getNTokenFromToken(token); \n\n        // calculate the fee rate \n        (uint256 _single, , , ) = decode_4x32_256(paramsEncoded);  \n        uint256 _ethFee = _single.mul(1e12);  // NOTE: the unit of _single is TWei\n\n        // transfer fee into NestDAO\n        INestDAO(C_NestDAO).addETHReward{value:_ethFee}(address(_ntoken));\n\n        // pay back the change\n        if (payback != address(0) && msg.value > _ethFee) {\n                TransferHelper.safeTransferETH(payback, msg.value.sub(_ethFee));\n        }\n\n        // notify client \n        emit PriceListQueried(address(msg.sender), token, bn, num);\n        \n        return data;\n    }\n\n    /// @notice A view function returning the historical price list from the current block\n    /// @param token  The address of the token contract\n    /// @param num    The number of price sheets in the list\n    /// @return The array of prices, each of which is (blockNnumber, ethAmount, tokenAmount)\n    function priceList(address token, uint8 num) \n        override public view \n        whenActive\n        noContract\n        returns (uint128[] memory) \n    {\n\n        // retrieve the historical price list\n        (uint128[] memory data, uint256 bn) = INestMining(C_NestMining).priceListOfToken(token, num);\n\n        // // get the associated NTOKEN with token\n        // address _ntoken = INestPool(C_NestPool).getNTokenFromToken(token); \n        \n        return data;\n    }\n    \n    function latestPrice(address token)\n        override \n        public \n        view \n        whenActive\n        noContract\n        returns (uint256 ethAmount, uint256 tokenAmount, uint128 avgPrice, int128 vola, uint256 bn) \n    {\n        (ethAmount, tokenAmount, bn) = INestMining(C_NestMining).latestPriceOf(token);\n        (, avgPrice, vola,) = INestMining(C_NestMining).priceAvgAndSigmaOf(token);\n\n    }\n  \n    /* ========== INTER-CALLS ========== */\n\n    // /// @dev Withdraw NEST only when emergency or governance\n    // /// @param to  The address of recipient\n    // /// @param amount  The amount of NEST tokens \n    // function withdrawNest(uint256 amount) \n    //     override external onlyBy(C_NestDAO)\n    // {\n    //     ERC20(C_NestToken).transfer(address(msg.sender), amount);\n    // }\n\n    // /// @dev Withdraw ethers only when emergency or governance\n    // /// @param to  The address of recipient\n    // /// @param amount  The amount of ethers \n    // function withdrawEth(uint256 amount) \n    //     override external onlyBy(C_NestDAO)\n    // {\n    //    TransferHelper.safeTransferETH(address(msg.sender), amount);\n    // }\n\n     /* ========== HELPERS ========== */\n\n    /// @dev For saving GAS\n    function encode_4x32_256(uint32 p1, uint32 p2, uint32 p3, uint32 p4) \n        internal \n        pure \n        returns (uint256 enc) \n    {\n        assembly {\n            mstore(0x20, p1)\n            mstore(0x18, p2)\n            mstore(0x10, p3)\n            mstore(0x8, p4)\n            enc := mload(0x20)\n        }\n    }\n\n    /// @dev For saving GAS\n    function decode_4x32_256(uint256 enc) \n        internal \n        pure \n        returns (uint32 p1, uint32 p2, uint32 p3, uint32 p4) \n    {\n        assembly {\n            p1 := enc\n            mstore(0x18, enc)\n            p4 := mload(0)\n            mstore(0x10, enc)\n            p3 := mload(0)\n            mstore(0x8, enc)\n            p2 := mload(0)\n        }\n    }\n\n    /// @dev For saving GAS\n    function encodeClient(uint64 _start, uint64 _end, uint32 _fee, uint32 _typ) \n        internal pure returns (uint256 enc) \n    {\n        assembly {\n            let y := 0\n            mstore(0x20, 0)\n            mstore(0x18, _typ)\n            mstore(0x14, _fee)\n            mstore(0x10, _end)\n            mstore(0x8, _start)\n            enc := mload(0x20)\n        }\n    }\n\n    \n    /// @dev For saving GAS\n    function decodeClient(uint256 enc) \n        internal pure returns (Client memory client) \n    {\n        uint32 _typ;\n        uint32 _fee;\n        uint64 _start;\n        uint64 _end;\n        assembly {\n            mstore(0x18, enc)\n            _start := mload(0)\n            mstore(0x10, enc)\n            _end := mload(0)\n            mstore(0xc, enc)\n            _fee := mload(0)\n            mstore(0x8, enc)\n            _typ := mload(0)\n        }\n        client = Client(_start, _end, _fee, _typ, 0);\n    }\n}\n"
    },
    "contracts/NestPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/AddressPayable.sol\";\nimport \"./lib/SafeERC20.sol\";\nimport './lib/TransferHelper.sol';\nimport \"./iface/INestPool.sol\";\nimport \"./iface/INestDAO.sol\";\nimport \"./iface/INestMining.sol\";\nimport \"./iface/INestQuery.sol\";\nimport \"./iface/INestStaking.sol\";\nimport \"./iface/INNRewardPool.sol\";\nimport \"./iface/INTokenController.sol\";\n\n/// @title NestPool\n/// @author Inf Loop - \n/// @author Paradox  - \n\n/// @dev The contract is for bookkeeping ETH, NEST and Tokens. It is served as a vault, such that \n///     assets are transferred internally to save GAS.\ncontract NestPool is INestPool {\n    \n    using address_make_payable for address;\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    uint8 private flag;  // 0: UNINITIALIZED  | 1: INITIALIZED\n    uint256 public minedNestAmount; \n\n    address override public governance;\n    address public addrOfNestBurning = address(0x1);\n\n    // Contracts \n    address public C_NestDAO;\n    address public C_NestMining;\n    ERC20   public C_NestToken;\n    address public C_NTokenController;\n    address public C_NNToken;\n    address public C_NNRewardPool;\n    address public C_NestStaking;\n    address public C_NestQuery;\n\n    // eth ledger for all miners\n    mapping(address => uint256) _eth_ledger;\n    // token => miner => amount \n    mapping(address => mapping(address => uint256)) _token_ledger;\n\n    // mapping(address => uint256) _nest_ledger;\n\n    mapping(address => address) _token_ntoken_mapping;\n\n    // parameters \n\n    constructor() public \n    {\n        governance = msg.sender;\n    }\n\n    receive() external payable { }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyGovernance() \n    {\n        require(msg.sender == governance, \"Nest:Pool:!governance\");\n        _;\n    }\n\n    modifier onlyBy(address _contract) \n    {\n        require(msg.sender == _contract, \"Nest:Pool:!Auth\");\n        _;\n    }\n\n    modifier onlyGovOrBy(address _contract) \n    {\n        require(msg.sender == governance || msg.sender == _contract, \"Nest:Pool:!Auth\");\n        _;\n    }\n\n    /*\n    modifier onlyGovOrBy2(address _contract, address _contract2)\n    {\n        require(msg.sender == governance || msg.sender == _contract || msg.sender == _contract2, \"Nest:Pool:!Auth\");\n        _;\n    }\n\n    modifier onlyGovOrBy3(address _contract1, address _contract2, address _contract3)\n    {\n        require(msg.sender == governance\n            || msg.sender == _contract1\n            || msg.sender == _contract2\n            || msg.sender == _contract3, \"Nest:Pool:!Auth\");\n        _;\n    }\n    */\n    modifier onlyByNest()\n    {\n        require(msg.sender == C_NestMining\n            || msg.sender == C_NTokenController \n            || msg.sender == C_NestDAO \n            || msg.sender == C_NestStaking \n            || msg.sender == C_NNRewardPool \n            || msg.sender == C_NestQuery, \"Nest:Pool:!Auth\");\n        _;\n    }\n\n    modifier onlyMiningContract()\n    {\n        require(address(msg.sender) == C_NestMining, \"Nest:Pool:onlyMining\");\n        _;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    function setGovernance(address _gov) \n        override external onlyGovernance \n    { \n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n        _nest_ledger[_gov] = _nest_ledger[governance];  \n        _nest_ledger[governance] = 0;\n        governance = _gov;\n    }\n\n    function setContracts(\n            address NestToken, address NestMining, \n            address NestStaking, address NTokenController, \n            address NNToken, address NNRewardPool, \n            address NestQuery, address NestDAO\n        ) \n        external onlyGovernance\n    {\n        if (NestToken != address(0)) {\n            C_NestToken = ERC20(NestToken);\n        }\n        if (NestMining != address(0)) {\n            C_NestMining = NestMining;\n        }\n        if (NTokenController != address(0)) {\n            C_NTokenController = NTokenController;\n        }\n        if (NNToken != address(0)) {\n            C_NNToken = NNToken;\n        }\n        if (NNRewardPool != address(0)) {\n            C_NNRewardPool = NNRewardPool;\n        }\n        if (NestStaking != address(0)) {\n            C_NestStaking = NestStaking;\n        }\n        if (NestQuery != address(0)) {\n            C_NestQuery = NestQuery;\n        }\n        if (NestDAO != address(0)) {\n            C_NestDAO = NestDAO;\n        }\n    }\n\n    /// @dev Set the total amount of NEST in the pool. After Nest v3.5 upgrading, all \n    ///    of the unmined NEST will be transferred by the governer to this pool. \n    function initNestLedger(uint256 amount) \n        override external onlyGovernance \n    {\n        require(_token_ledger[address(C_NestToken)][address(governance)] == 0, \"Nest:Pool:!init\"); \n        _token_ledger[address(C_NestToken)][address(governance)] = amount;\n    }\n\n    function getNTokenFromToken(address token) \n        override view public returns (address) \n    {\n        return _token_ntoken_mapping[token];\n    }\n\n    function setNTokenToToken(address token, address ntoken) \n        override \n        public\n        onlyGovOrBy(C_NTokenController) \n    {\n        _token_ntoken_mapping[token] = ntoken;\n        _token_ntoken_mapping[ntoken] = ntoken;\n    }\n\n    /* ========== ONLY FOR EMERGENCY ========== */\n\n    // function drainEth(address to, uint256 amount) \n    //     external onlyGovernance\n    // {\n    //     TransferHelper.safeTransferETH(to, amount);\n    // }\n\n    function drainNest(address to, uint256 amount, address gov) \n         override external onlyGovernance\n    {\n         require(_token_ledger[address(C_NestToken)][gov] >= amount, \"Nest:Pool:!amount\");\n         C_NestToken.transfer(to, amount);\n    }\n\n    function transferNestInPool(address from, address to, uint256 amount) \n        external onlyByNest\n    {\n        if (amount == 0) {\n            return;\n        }\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n        uint256 blnc = _nest_ledger[from];\n        require (blnc >= amount, \"Nest:Pool:!amount\");\n        _nest_ledger[from] = blnc.sub(amount);\n        _nest_ledger[to] = _nest_ledger[to].add(amount);\n    }\n\n    function transferTokenInPool(address token, address from, address to, uint256 amount) \n        external onlyByNest\n    {\n        if (amount == 0) {\n            return;\n        }\n        uint256 blnc = _token_ledger[token][from];\n        require (blnc >= amount, \"Nest:Pool:!amount\");\n        _token_ledger[token][from] = blnc.sub(amount);\n        _token_ledger[token][to] = _token_ledger[token][to].add(amount);\n    }\n\n    function transferEthInPool(address from, address to, uint256 amount) \n        external onlyByNest\n    {\n        if (amount == 0) {\n            return;\n        }\n        uint256 blnc = _eth_ledger[from];\n        require (blnc >= amount, \"Nest:Pool:!amount\");\n        _eth_ledger[from] = blnc.sub(amount);\n        _eth_ledger[to] = _eth_ledger[to].add(amount);\n    }\n\n\n    /* ========== FREEZING/UNFREEZING ========== */\n\n    // NOTE: Guarded by onlyMiningContract\n\n    function freezeEth(address miner, uint256 ethAmount) \n        override public onlyBy(C_NestMining) \n    {\n        // emit LogAddress(\"freezeEthAndToken> miner\", miner);\n        // emit LogAddress(\"freezeEthAndToken> token\", token);\n        uint256 blncs = _eth_ledger[miner];\n        require(blncs >= ethAmount, \"Nest:Pool:BAL(eth)<0\");\n        _eth_ledger[miner] = blncs - ethAmount;  //safe_math: checked before\n        _eth_ledger[address(this)] =  _eth_ledger[address(this)].add(ethAmount);\n    }\n\n    function unfreezeEth(address miner, uint256 ethAmount) \n        override public onlyBy(C_NestMining)  \n    {\n        if (ethAmount > 0) {\n            // LogUint(\"unfreezeEthAndToken> _eth_ledger[address(0x0)]\", _eth_ledger[address(0x0)]);\n            // LogUint(\"unfreezeEthAndToken> _eth_ledger[miner]\", _eth_ledger[miner]);\n            // LogUint(\"unfreezeEthAndToken> ethAmount\", ethAmount);\n            _eth_ledger[address(this)] =  _eth_ledger[address(this)].sub(ethAmount);\n            _eth_ledger[miner] = _eth_ledger[miner].add(ethAmount);\n        } \n    }\n\n    function freezeNest(address miner, uint256 nestAmount) \n        override public onlyBy(C_NestMining)  \n    {\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n\n        uint256 blncs = _nest_ledger[miner];\n        \n        _nest_ledger[address(this)] =  _nest_ledger[address(this)].add(nestAmount);\n\n        if (blncs < nestAmount) {\n            _nest_ledger[miner] = 0; \n            require(C_NestToken.transferFrom(miner,  address(this), nestAmount - blncs), \"Nest:Pool:!transfer\"); //safe math\n        } else {\n            _nest_ledger[miner] = blncs - nestAmount;  //safe math\n        }\n    }\n\n    function unfreezeNest(address miner, uint256 nestAmount) \n        override public onlyBy(C_NestMining)  \n    {\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n\n        if (nestAmount > 0) {\n            _nest_ledger[address(this)] =  _nest_ledger[address(this)].sub(nestAmount);\n            _nest_ledger[miner] = _nest_ledger[miner].add(nestAmount); \n        }\n    }\n\n    function freezeToken(address miner, address token, uint256 tokenAmount) \n        override external onlyBy(C_NestMining)  \n    {\n        uint256 blncs = _token_ledger[token][miner];\n        _token_ledger[token][address(this)] =  _token_ledger[token][address(this)].add(tokenAmount);\n        if (blncs < tokenAmount) {\n            _token_ledger[token][miner] = 0; \n            ERC20(token).safeTransferFrom(address(miner),  address(this), tokenAmount - blncs); //safe math\n        } else {\n            _token_ledger[token][miner] = blncs - tokenAmount;  //safe math\n        }\n    }\n\n    function unfreezeToken(address miner, address token, uint256 tokenAmount) \n        override external onlyBy(C_NestMining)  \n    {\n        if (tokenAmount > 0) {\n            _token_ledger[token][address(this)] =  _token_ledger[token][address(this)].sub(tokenAmount);\n            _token_ledger[token][miner] = _token_ledger[token][miner].add(tokenAmount); \n        }\n    }\n\n    function freezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) \n        override external onlyBy(C_NestMining)  \n    {\n        uint256 blncs = _eth_ledger[miner];\n        require(blncs >= ethAmount, \"Nest:Pool:!eth\");\n        _eth_ledger[miner] = blncs - ethAmount;  //safe_math: checked before\n        _eth_ledger[address(this)] =  _eth_ledger[address(this)].add(ethAmount);\n\n        blncs = _token_ledger[token][miner];\n        _token_ledger[token][address(this)] =  _token_ledger[token][address(this)].add(tokenAmount);\n        if (blncs < tokenAmount) {\n            _token_ledger[token][miner] = 0;\n            ERC20(token).safeTransferFrom(address(miner),  address(this), tokenAmount - blncs); //safe math\n        } else {\n            _token_ledger[token][miner] = blncs - tokenAmount;  //safe math\n        }\n    }\n\n    function unfreezeEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) \n        override external onlyBy(C_NestMining)  \n    {\n        if (ethAmount > 0) {\n            _eth_ledger[address(this)] =  _eth_ledger[address(this)].sub(ethAmount);\n            _eth_ledger[miner] = _eth_ledger[miner].add(ethAmount);\n        } \n\n        if (tokenAmount > 0) {\n            _token_ledger[token][address(this)] =  _token_ledger[token][address(this)].sub(tokenAmount);\n            _token_ledger[token][miner] = _token_ledger[token][miner].add(tokenAmount); \n        }\n    }\n\n    /* ========== BALANCE ========== */\n\n\n    function balanceOfNestInPool(address miner) \n        override public view returns (uint256)\n    {\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n\n        return _nest_ledger[miner];\n    }\n\n    function balanceOfEthInPool(address miner) \n        override public view returns (uint256)\n    {\n        return _eth_ledger[miner];\n    }\n\n    function balanceOfTokenInPool(address miner, address token) \n        override public view returns (uint256)\n    {\n        return _token_ledger[token][miner];\n    }\n\n    function balanceOfEthFreezed() public view returns (uint256)\n    {\n        return _eth_ledger[address(this)];\n    }\n\n    function balanceOfTokenFreezed(address token) public view returns (uint256)\n    {\n        return _token_ledger[token][address(this)];\n    }\n\n    /* ========== DISTRIBUTING ========== */\n\n    function addNest(address miner, uint256 amount) \n        override public onlyBy(C_NestMining)\n    {\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n        _nest_ledger[governance] = _nest_ledger[governance].sub(amount);\n        _nest_ledger[miner] = _nest_ledger[miner].add(amount);\n        minedNestAmount = minedNestAmount.add(amount);\n    }\n\n    function addNToken(address miner, address ntoken, uint256 amount) \n        override public onlyBy(C_NestMining)\n    {\n        _token_ledger[ntoken][miner] = _token_ledger[ntoken][miner].add(amount);\n    }\n\n    /* ========== DEPOSIT ========== */\n\n    // NOTE: Guarded by onlyMiningContract\n\n    function depositEth(address miner) \n        override payable external onlyGovOrBy(C_NestMining) \n    {\n        _eth_ledger[miner] =  _eth_ledger[miner].add(msg.value);\n    }\n\n    function depositNToken(address miner, address from, address ntoken, uint256 amount) \n        override external onlyGovOrBy(C_NestMining) \n    {\n        ERC20(ntoken).transferFrom(from, address(this), amount);\n        _token_ledger[ntoken][miner] =  _token_ledger[ntoken][miner].add(amount);\n    }\n\n    /* ========== WITHDRAW ========== */\n\n    // NOTE: Guarded by onlyGovOrBy(C_NestMining), onlyGovOrBy(C_NestStaking)\n    \n    /// @dev If amount == 0, it won't go stuck\n    function withdrawEth(address miner, uint256 ethAmount) \n        override public onlyByNest\n    {\n        uint256 blncs = _eth_ledger[miner];\n        require(ethAmount <= blncs, \"Nest:Pool:!blncs\");\n        if (ethAmount > 0) {\n            _eth_ledger[miner] = blncs - ethAmount; // safe math\n            TransferHelper.safeTransferETH(miner, ethAmount);\n        }\n    }\n\n    /// @dev If amount == 0, it won't go stuck\n    function withdrawToken(address miner, address token, uint256 tokenAmount) \n        override public onlyByNest\n    {\n        uint256 blncs = _token_ledger[token][miner];\n        require(tokenAmount <= blncs, \"Nest:Pool:!blncs\");\n        if (tokenAmount > 0) {\n            _token_ledger[token][miner] = blncs - tokenAmount; // safe math\n            ERC20(token).safeTransfer(miner, tokenAmount);\n        }\n    }\n\n\n    /// @dev If amount == 0, it won't go stuck\n    function withdrawNest(address miner, uint256 amount) \n        override public onlyByNest\n    {\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n\n        uint256 blncs = _nest_ledger[miner];\n        require(amount <= blncs, \"Nest:Pool:!blncs\");\n        if (amount > 0) {\n            _nest_ledger[miner] = blncs - amount;  // safe math\n            require(C_NestToken.transfer(miner, amount),\"Nest:Pool:!TRANS\");\n        }\n    }\n\n\n    /// @dev If amount == 0, it won't go stuck\n    function withdrawEthAndToken(address miner, uint256 ethAmount, address token, uint256 tokenAmount) \n        override public onlyBy(C_NestMining)\n    {\n        uint256 blncs = _eth_ledger[miner];\n        if (ethAmount <= blncs && ethAmount > 0) {\n            _eth_ledger[miner] = blncs - ethAmount;  // safe math\n            TransferHelper.safeTransferETH(miner, ethAmount);\n        }\n\n        blncs = _token_ledger[token][miner];\n        if (tokenAmount <= blncs && tokenAmount > 0) {\n            _token_ledger[token][miner] = blncs - tokenAmount;  // safe math\n            ERC20(token).safeTransfer(miner, tokenAmount);\n        }\n    }\n\n    /// @dev If amount == 0, it won't go stuck\n    function withdrawNTokenAndTransfer(address miner, address ntoken, uint256 amount, address to) \n        override public onlyBy(C_NestStaking)\n    {\n        uint256 blncs = _token_ledger[ntoken][miner];\n        require(amount <= blncs, \"Nest:Pool:!blncs\");\n        if (amount > 0) {\n            _token_ledger[ntoken][miner] = blncs - amount;  // safe math\n            require(ERC20(ntoken).transfer(to, amount),\"Nest:Pool:!TRANS\");\n        }\n    }\n\n    /* ========== HELPERS (VIEWS) ========== */\n    // the user needs to be reminded of the parameter settings    \n    function assetsList(uint256 len, address[] memory tokenList) \n        public view returns (uint256[] memory) \n    {\n        // len < = length(tokenList) + 1\n        require(len == tokenList.length + 1, \"Nest: Pool: !assetsList\");\n        uint256[] memory list = new uint256[](len);\n        list[0] = _eth_ledger[address(msg.sender)];\n        for (uint i = 0; i < len - 1; i++) {\n            address _token = tokenList[i];\n            list[i+1] = _token_ledger[_token][address(msg.sender)];\n        }\n        return list;\n    }\n\n    function addrOfNestMining() override public view returns (address) \n    {\n        return C_NestMining;\n    }\n\n    function addrOfNestToken() override public view returns (address) \n    {\n        return address(C_NestToken);\n    }\n\n    function addrOfNTokenController() override public view returns (address) \n    {\n        return C_NTokenController;\n    }\n    \n    function addrOfNNRewardPool() override public view returns (address) \n    {\n        return C_NNRewardPool;\n    }\n\n    function addrOfNNToken() override public view returns (address) \n    {\n        return C_NNToken;\n    }\n\n    function addrOfNestStaking() override public view returns (address) \n    {\n        return C_NestStaking;\n    }\n\n    function addrOfNestQuery() override public view returns (address) \n    {\n        return C_NestQuery;\n    }\n\n    function addrOfNestDAO() override public view returns (address) \n    {\n        return C_NestDAO;\n    }\n\n    function addressOfBurnedNest() override public view returns (address) \n    {\n        return addrOfNestBurning;\n    }\n\n    // function getMinerNToken(address miner, address token) public view returns (uint256 tokenAmount) \n    // {\n    //     if (token != address(0x0)) {\n    //         tokenAmount = _token_ledger[token][miner];\n    //     }\n    // } \n        \n    function getMinerEthAndToken(address miner, address token) \n        public view returns (uint256 ethAmount, uint256 tokenAmount) \n    {\n        ethAmount = _eth_ledger[miner];\n        if (token != address(0x0)) {\n            tokenAmount = _token_ledger[token][miner];\n        }\n    } \n\n    function getMinerNest(address miner) public view returns (uint256 nestAmount) \n    {\n        mapping(address => uint256) storage _nest_ledger = _token_ledger[address(C_NestToken)];\n\n        nestAmount = _nest_ledger[miner];\n    } \n\n}\n"
    },
    "contracts/NestMiningV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./libminingv1/MiningV1Data.sol\";\nimport \"./libminingv1/MiningV1Calc.sol\";\nimport \"./libminingv1/MiningV1Op.sol\";\n\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/SafeERC20.sol\";\nimport './lib/TransferHelper.sol';\nimport \"./lib/ABDKMath64x64.sol\";\n\nimport \"./iface/INestPool.sol\";\nimport \"./iface/INestStaking.sol\";\nimport \"./iface/INTokenLegacy.sol\";\nimport \"./iface/INestMining.sol\";\nimport \"./iface/INestDAO.sol\";\n// import \"hardhat/console.sol\";\n\n/// @title  NestMiningV1\n/// @author Inf Loop - \n/// @author Paradox  - \ncontract NestMiningV1 {\n\n    using SafeMath for uint256;\n\n    using MiningV1Calc for MiningV1Data.State;\n    using MiningV1Op for MiningV1Data.State;\n\n    /* ========== STATE VARIABLES ============== */\n\n    uint8       public  flag;\n    uint64      public  version; \n    uint8       private _entrant_state; \n    uint176     private _reserved; \n\n    MiningV1Data.State state;\n    \n    // NOTE: _NOT_ENTERED is set to ZERO such that it needn't constructor\n    uint8 private constant _NOT_ENTERED = 0;\n    uint8 private constant _ENTERED = 1;\n\n    uint8 constant MINING_FLAG_UNINITIALIZED    = 0;\n    uint8 constant MINING_FLAG_SETUP_NEEDED     = 1;\n    uint8 constant MINING_FLAG_UPGRADE_NEEDED   = 2;\n    uint8 constant MINING_FLAG_ACTIVE           = 3;\n\n    /* ========== ADDRESSES ============== */\n\n    address public  governance;\n    address private C_NestPool;\n\n    /* ========== STRUCTURES ============== */\n\n    struct Params {\n        uint8    miningEthUnit;     // = 10;\n        uint32   nestStakedNum1k;   // = 1;\n        uint8    biteFeeRate;       // = 1; \n        uint8    miningFeeRate;     // = 10;\n        uint8    priceDurationBlock; \n        uint8    maxBiteNestedLevel; // = 3;\n        uint8    biteInflateFactor;\n        uint8    biteNestInflateFactor;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor() public { }\n\n    function initialize(address NestPool) external \n    {\n        require(flag == MINING_FLAG_UNINITIALIZED, \"Nest:Mine:!flag\");\n\n        uint256 amount = MiningV1Data.MINING_NEST_YIELD_PER_BLOCK_BASE;\n        for (uint i =0; i < 10; i++) {\n            state._mining_nest_yield_per_block_amount[i] = amount;\n            amount = amount.mul(MiningV1Data.MINING_NEST_YIELD_CUTBACK_RATE).div(100);\n        }\n\n        amount = MiningV1Data.MINING_NTOKEN_YIELD_PER_BLOCK_BASE;\n        for (uint i =0; i < 10; i++) {\n            state._mining_ntoken_yield_per_block_amount[i] = amount;\n            amount = amount.mul(MiningV1Data.MINING_NTOKEN_YIELD_CUTBACK_RATE).div(100);\n        }\n        \n        governance = msg.sender;\n        version = uint64(block.number);\n\n        flag = MINING_FLAG_SETUP_NEEDED;\n        C_NestPool = NestPool;\n    }\n\n    /// @dev This function can only be called once immediately right after deployment\n    function setup(\n            uint32   genesisBlockNumber, \n            uint128  latestMiningHeight,\n            uint128  minedNestTotalAmount,\n            Params calldata initParams\n        ) external onlyGovernance\n    {\n        require(flag == MINING_FLAG_SETUP_NEEDED, \"Nest:Mine:!flag\");\n        \n        state.miningEthUnit = initParams.miningEthUnit;\n        state.nestStakedNum1k = initParams.nestStakedNum1k;\n        state.biteFeeRate = initParams.biteFeeRate;    // 0.1%\n        state.miningFeeRate = initParams.miningFeeRate;  // 0.1% on testnet\n        state.priceDurationBlock = initParams.priceDurationBlock;  // 5 on testnet\n        state.maxBiteNestedLevel = initParams.maxBiteNestedLevel;  \n        state.biteInflateFactor = initParams.biteInflateFactor;   // 1 on testnet\n        state.biteNestInflateFactor = initParams.biteNestInflateFactor; // 1 on testnet\n\n        state.latestMiningHeight = latestMiningHeight;\n        state.minedNestAmount = minedNestTotalAmount;\n        \n        // genesisBlock = 6236588 on testnet or mainnet\n        state.genesisBlock = genesisBlockNumber;\n\n        flag = MINING_FLAG_UPGRADE_NEEDED;\n        version = uint64(block.number);\n    }\n\n    /// @dev The function will be kicking off Nest Protocol v3.5.\n    ///    After upgrading, `post/post2()` are ready to be invoked.\n    ///    Before that, `post2Only4Upgrade()` is used to do posting.\n    ///    The purpose is to limit post2Only4Upgrade() to run \n    function upgrade() external onlyGovernance\n    {\n        require(flag == MINING_FLAG_UPGRADE_NEEDED, \"Nest:Mine:!flag\");\n\n        flag = MINING_FLAG_ACTIVE;\n    }\n\n    /// @notice Write the block number as a version number\n    /// @dev It shall be invoked *manually* whenever the contract is upgraded(behind proxy)\n    function incVersion() external onlyGovernance\n    {\n        version = uint64(block.number);\n    }\n\n    receive() external payable { }\n\n    /* ========== MODIFIERS ========== */\n\n    function _onlyGovernance() private view \n    {\n        require(msg.sender == governance, \"Nest:Mine:!GOV\");\n    }\n\n    modifier onlyGovernance() \n    {\n        _onlyGovernance();\n        _;\n    }\n\n    function _noContract() private view {\n        require(address(msg.sender) == address(tx.origin), \"Nest:Mine:contract!\");\n    }\n\n    modifier noContract() \n    {\n        _noContract();\n        _;\n    }\n\n    modifier noContractExcept(address _contract) \n    {\n        require(address(msg.sender) == address(tx.origin) || address(msg.sender) == _contract, \"Nest:Mine:contract!\");\n        _;\n    }\n\n    modifier onlyGovOrBy(address _contract) \n    {\n        require(msg.sender == governance || msg.sender == _contract, \"Nest:Mine:!sender\");\n        _;\n    }\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_entrant_state != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _entrant_state = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _entrant_state = _NOT_ENTERED;\n    }\n\n    modifier onlyByNest()\n    {\n        require(address(msg.sender) == address(tx.origin)\n            || msg.sender == state.C_NestDAO \n            || msg.sender == state.C_NestStaking \n            || msg.sender == state.C_NNRewardPool \n            || msg.sender == state.C_NestQuery, \"Nest:Mine:!Auth\");\n        _;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    function loadGovernance() external\n    {\n        governance = INestPool(C_NestPool).governance();\n    }\n\n    function loadContracts() external onlyGovOrBy(C_NestPool)\n    {\n        state.C_NestPool = C_NestPool;\n        state.C_NestToken = INestPool(state.C_NestPool).addrOfNestToken();\n        state.C_NestStaking = INestPool(state.C_NestPool).addrOfNestStaking();\n        state.C_NestQuery = INestPool(state.C_NestPool).addrOfNestQuery();\n        state.C_NNRewardPool = INestPool(state.C_NestPool).addrOfNNRewardPool();\n        state.C_NestDAO = INestPool(state.C_NestPool).addrOfNestDAO();\n    }\n\n    function setParams(Params calldata newParams) external \n        onlyGovernance\n    {\n        if (newParams.miningEthUnit != 0) {\n            state.miningEthUnit = newParams.miningEthUnit;\n        }\n        if (newParams.nestStakedNum1k != 0) {\n            state.nestStakedNum1k = newParams.nestStakedNum1k;\n        }\n        \n        state.biteFeeRate = newParams.biteFeeRate;\n\n        if (newParams.miningFeeRate != 0) {\n            state.miningFeeRate = newParams.miningFeeRate;\n        }\n\n        state.priceDurationBlock = newParams.priceDurationBlock;\n        state.maxBiteNestedLevel = newParams.maxBiteNestedLevel;\n        state.biteInflateFactor = newParams.biteInflateFactor;\n        state.biteNestInflateFactor = newParams.biteNestInflateFactor;\n\n        emit MiningV1Data.SetParams(state.miningEthUnit, state.nestStakedNum1k, state.biteFeeRate,\n                                    state.miningFeeRate, state.priceDurationBlock, state.maxBiteNestedLevel,\n                                    state.biteInflateFactor, state.biteNestInflateFactor);\n    }\n\n    /// @dev only be used at upgrade 3.0 to 3.5\n    /// @dev when the upgrade is complete, this function is disabled\n    function setParams1(\n            uint128  latestMiningHeight,\n            uint128  minedNestTotalAmount\n        ) external onlyGovernance\n        {\n            require(flag == MINING_FLAG_UPGRADE_NEEDED, \"Nest:Mine:!flag\");\n            state.latestMiningHeight = latestMiningHeight;\n            state.minedNestAmount = minedNestTotalAmount;\n        }\n\n    /* ========== HELPERS ========== */\n\n    function addrOfGovernance() view external\n        returns (address) \n    {   \n        return governance;\n    }\n\n    function parameters() view external \n        returns (Params memory params)\n    {\n        params.miningEthUnit = state.miningEthUnit;\n        params.nestStakedNum1k = state.nestStakedNum1k;\n        params.biteFeeRate = state.biteFeeRate;\n        params.miningFeeRate = state.miningFeeRate;\n        params.priceDurationBlock = state.priceDurationBlock;\n        params.maxBiteNestedLevel = state.maxBiteNestedLevel;\n        params.biteInflateFactor = state.biteInflateFactor;\n        params.biteNestInflateFactor = state.biteNestInflateFactor;\n    }\n\n    /* ========== POST/CLOSE Price Sheets ========== */\n\n\n    /// @notice Post a price sheet for TOKEN\n    /// @dev  It is for TOKEN (except USDx) whose total supply is below 1,000,000 * 1e18\n    /// @param token The address of TOKEN contract\n    /// @param ethNum The numbers of ethers to post sheets\n    /// @param tokenAmountPerEth The price of TOKEN\n    function post(\n            address token, \n            uint256 ethNum, \n            uint256 tokenAmountPerEth\n        )\n        external \n        payable \n        noContract\n    {\n        // check parameters\n        require(ethNum == state.miningEthUnit, \"Nest:Mine:!(ethNum)\");\n        // require(ethNum >= state.miningEthUnit && ethNum % state.miningEthUnit == 0, \"Nest:Mine:!(ethNum)\");\n        require(tokenAmountPerEth > 0, \"Nest:Mine:!(price)\");\n\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\n        address _ntoken = _C_NestPool.getNTokenFromToken(token);\n        require(_ntoken != address(0) &&  _ntoken != address(state.C_NestToken) && token != _ntoken, \"Nest:Mine:!(ntoken)\");\n\n        // check if the totalsupply of ntoken is less than MINING_NTOKEN_NON_DUAL_POST_THRESHOLD, otherwise use post2()\n        require(INToken(_ntoken).totalSupply() < MiningV1Data.MINING_NTOKEN_NON_DUAL_POST_THRESHOLD, \"Nest:Mine:!ntoken\");\n        // calculate eth fee\n        uint256 _ethFee = ethNum.mul(state.miningFeeRate).mul(1e18).div(10000);\n\n        { // settle ethers and tokens\n\n            // save the changes into miner's virtual account\n            if (msg.value.sub(_ethFee) > 0) {\n                _C_NestPool.depositEth{value:msg.value.sub(_ethFee)}(address(msg.sender));\n            }\n\n            INestStaking _C_NestStaking = INestStaking(state.C_NestStaking);\n            INestDAO _C_NestDAO = INestDAO(state.C_NestDAO);\n\n            _C_NestStaking.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NTOKEN_FEE_DIVIDEND_RATE).div(100)}(_ntoken);       \n            _C_NestDAO.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NTOKEN_FEE_DAO_RATE).div(100)}(_ntoken);       \n            _C_NestDAO.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NTOKEN_FEE_NEST_DAO_RATE).div(100)}(address(state.C_NestToken));  \n\n            // freeze eths and tokens in the nest pool\n            _C_NestPool.freezeEthAndToken(msg.sender, ethNum.mul(1 ether), \n                token, tokenAmountPerEth.mul(ethNum));\n            _C_NestPool.freezeNest(msg.sender, uint256(state.nestStakedNum1k).mul(1000 * 1e18));\n        }\n\n        {\n            MiningV1Data.PriceSheet[] storage _sheetToken = state.priceSheetList[token];\n            // append a new price sheet\n            _sheetToken.push(MiningV1Data.PriceSheet(\n                uint160(msg.sender),            // miner \n                uint32(block.number),           // atHeight\n                uint32(ethNum),                 // ethNum\n                uint32(ethNum),                 // remainNum\n                uint8(0),                       // level\n                uint8(MiningV1Data.PRICESHEET_TYPE_TOKEN),   // typ\n                uint8(MiningV1Data.PRICESHEET_STATE_POSTED), // state \n                uint8(0),                       // _reserved\n                uint32(ethNum),                 // ethNumBal\n                uint32(ethNum),                 // tokenNumBal\n                uint32(state.nestStakedNum1k),        // nestNum1k\n                uint128(tokenAmountPerEth)      // tokenAmountPerEth\n            ));\n            emit MiningV1Data.PricePosted(msg.sender, token, (_sheetToken.length - 1), ethNum.mul(1 ether), tokenAmountPerEth.mul(ethNum)); \n\n        }\n\n        { // mining\n            uint256 _minedH = state.minedAtHeight[token][block.number];\n            uint256 _ntokenH = uint256(_minedH >> 128);\n            uint256 _ethH = uint256(_minedH % (1 << 128));\n            if (_ntokenH == 0) {\n                uint256 _ntokenAmount = mineNToken(_ntoken);  \n                state.latestMiningHeight = uint32(block.number); \n                address _bidder = INToken(_ntoken).checkBidder();\n                if (_bidder == state.C_NestPool) { // for new NTokens, 100% to miners\n                    _ntokenH = _ntokenAmount;\n                    INToken(_ntoken).mint(_ntokenAmount, address(state.C_NestPool));\n                } else {// for old NTokens, 95% to miners, 5% to the bidder\n                    _ntokenH = _ntokenAmount.mul(MiningV1Data.MINING_LEGACY_NTOKEN_MINER_REWARD_PERCENTAGE).div(100);\n                    INTokenLegacy(_ntoken).increaseTotal(_ntokenAmount);\n                    INTokenLegacy(_ntoken).transfer(state.C_NestPool, _ntokenAmount);\n                    INestPool(state.C_NestPool).addNToken(_bidder, _ntoken, _ntokenAmount.sub(_ntokenH));\n                }\n            }\n            _ethH = _ethH.add(ethNum);\n            // require(_nestH < (1 << 128) && _ethH < (1 << 128), \"nestAtHeight/ethAtHeight error\");\n            state.minedAtHeight[token][block.number] = (_ntokenH * (1<< 128) + _ethH);\n        }\n\n        // calculate averge and volatility\n        state._stat(token);\n        return; \n    }\n\n    /// @notice Post two price sheets for a token and its ntoken simultaneously \n    /// @dev  Support dual-posts for TOKEN/NTOKEN, (ETH, TOKEN) + (ETH, NTOKEN)\n    /// @param token The address of TOKEN contract\n    /// @param ethNum The numbers of ethers to post sheets\n    /// @param tokenAmountPerEth The price of TOKEN\n    /// @param ntokenAmountPerEth The price of NTOKEN\n    function post2(\n            address token, \n            uint256 ethNum, \n            uint256 tokenAmountPerEth, \n            uint256 ntokenAmountPerEth\n        )\n        external \n        payable \n        noContract\n    {\n        // check parameters \n        require(ethNum == state.miningEthUnit, \"Nest:Mine:!(ethNum)\");\n        require(tokenAmountPerEth > 0 && ntokenAmountPerEth > 0, \"Nest:Mine:!(price)\");\n        address _ntoken = INestPool(state.C_NestPool).getNTokenFromToken(token);\n\n        // NOTE: uncomment the line below to ensure that only (ETH, NEST) can be dual-posted\n        require(_ntoken != token, \"Nest:Mine:!(ntoken)\");\n\n        // calculate eth fee\n        uint256 _ethFee = ethNum.mul(state.miningFeeRate).mul(1e18).div(10000);\n\n        { // settle ethers and tokens\n            INestPool _C_NestPool = INestPool(state.C_NestPool);\n\n            // save the changes into miner's virtual account\n            if (msg.value.sub(_ethFee) > 0) {\n                _C_NestPool.depositEth{value:msg.value.sub(_ethFee)}(address(msg.sender));\n            }\n            INestStaking _C_NestStaking = INestStaking(state.C_NestStaking);\n            INestDAO _C_NestDAO = INestDAO(state.C_NestDAO);\n\n            if (_ntoken == address(state.C_NestToken)) {\n                _C_NestStaking.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NEST_FEE_DIVIDEND_RATE).div(100)}(_ntoken);       \n                _C_NestDAO.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NEST_FEE_DAO_RATE).div(100)}(_ntoken);       \n            } else {\n                _C_NestStaking.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NTOKEN_FEE_DIVIDEND_RATE).div(100)}(_ntoken);       \n                _C_NestDAO.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NTOKEN_FEE_DAO_RATE).div(100)}(_ntoken);       \n                _C_NestDAO.addETHReward{value:_ethFee.mul(MiningV1Data.MINING_NTOKEN_FEE_NEST_DAO_RATE).div(100)}(address(state.C_NestToken));  \n            }\n            // freeze assets in the nest pool\n            _C_NestPool.freezeEthAndToken(msg.sender, ethNum.mul(1 ether), \n                token, tokenAmountPerEth.mul(ethNum));\n            _C_NestPool.freezeEthAndToken(msg.sender, ethNum.mul(1 ether), \n                _ntoken, ntokenAmountPerEth.mul(ethNum));\n            _C_NestPool.freezeNest(msg.sender, uint256(state.nestStakedNum1k).mul(2).mul(1000 * 1e18));\n        }\n\n        {\n            uint8 typ1;\n            uint8 typ2; \n            if (_ntoken == address(state.C_NestToken)) {\n                typ1 = MiningV1Data.PRICESHEET_TYPE_USD;\n                typ2 = MiningV1Data.PRICESHEET_TYPE_NEST;\n            } else {\n                typ1 = MiningV1Data.PRICESHEET_TYPE_TOKEN;\n                typ2 = MiningV1Data.PRICESHEET_TYPE_NTOKEN;\n            }\n            MiningV1Data.PriceSheet[] storage _sheetToken = state.priceSheetList[token];\n            // append a new price sheet\n            _sheetToken.push(MiningV1Data.PriceSheet(\n                uint160(msg.sender),            // miner \n                uint32(block.number),           // atHeight\n                uint32(ethNum),                 // ethNum\n                uint32(ethNum),                 // remainNum\n                uint8(0),                       // level\n                uint8(typ1),     // typ\n                uint8(MiningV1Data.PRICESHEET_STATE_POSTED), // state \n                uint8(0),                       // _reserved\n                uint32(ethNum),                 // ethNumBal\n                uint32(ethNum),                 // tokenNumBal\n                uint32(state.nestStakedNum1k),        // nestNum1k\n                uint128(tokenAmountPerEth)      // tokenAmountPerEth\n            ));\n\n            MiningV1Data.PriceSheet[] storage _sheetNToken = state.priceSheetList[_ntoken];\n            // append a new price sheet for ntoken\n            _sheetNToken.push(MiningV1Data.PriceSheet(\n                uint160(msg.sender),            // miner \n                uint32(block.number),           // atHeight\n                uint32(ethNum),                 // ethNum\n                uint32(ethNum),                 // remainNum\n                uint8(0),                       // level\n                uint8(typ2),     // typ\n                uint8(MiningV1Data.PRICESHEET_STATE_POSTED), // state \n                uint8(0),                       // _reserved\n                uint32(ethNum),                 // ethNumBal\n                uint32(ethNum),                 // tokenNumBal\n                uint32(state.nestStakedNum1k),  // nestNum1k\n                uint128(ntokenAmountPerEth)     // tokenAmountPerEth\n            ));\n            emit MiningV1Data.PricePosted(msg.sender, token, (_sheetToken.length - 1), ethNum.mul(1 ether), tokenAmountPerEth.mul(ethNum)); \n            emit MiningV1Data.PricePosted(msg.sender, _ntoken, (_sheetNToken.length - 1), ethNum.mul(1 ether), ntokenAmountPerEth.mul(ethNum)); \n        }\n\n        { // mining\n            if (_ntoken == address(state.C_NestToken)) {\n                uint256 _minedH = state.minedAtHeight[token][block.number];\n                uint256 _nestH = uint256(_minedH >> 128);\n                uint256 _ethH = uint256(_minedH % (1 << 128));\n                if (_nestH == 0) {\n                    uint256 _nestAmount = mineNest(); \n                    state.latestMiningHeight = uint32(block.number); \n                    state.minedNestAmount += uint128(_nestAmount);\n                    _nestH = _nestAmount.mul(MiningV1Data.MINER_NEST_REWARD_PERCENTAGE).div(100); \n\n                    // 15% of NEST to NNRewardPool\n                    INestPool(state.C_NestPool).addNest(state.C_NNRewardPool, _nestAmount.mul(MiningV1Data.NN_NEST_REWARD_PERCENTAGE).div(100));\n                    INNRewardPool(state.C_NNRewardPool).addNNReward(_nestAmount.mul(MiningV1Data.NN_NEST_REWARD_PERCENTAGE).div(100));\n\n                    // 5% of NEST to NestDAO\n                    INestPool(state.C_NestPool).addNest(state.C_NestDAO, _nestAmount.mul(MiningV1Data.DAO_NEST_REWARD_PERCENTAGE).div(100));\n                    INestDAO(state.C_NestDAO).addNestReward(_nestAmount.mul(MiningV1Data.DAO_NEST_REWARD_PERCENTAGE).div(100));\n                }\n                _ethH = _ethH.add(ethNum);\n                state.minedAtHeight[token][block.number] = (_nestH * (1<< 128) + _ethH);\n            } else {\n                uint256 _minedH = state.minedAtHeight[token][block.number];\n                uint256 _ntokenH = uint256(_minedH >> 128);\n                uint256 _ethH = uint256(_minedH % (1 << 128));\n                if (_ntokenH == 0) {\n                    uint256 _ntokenAmount = mineNToken(_ntoken);  \n                    state.latestMiningHeight = uint32(block.number); \n                    address _bidder = INToken(_ntoken).checkBidder();\n                    if (_bidder == state.C_NestPool) { // for new NTokens, 100% to miners\n                        _ntokenH = _ntokenAmount;\n                        INToken(_ntoken).mint(_ntokenAmount, address(state.C_NestPool));\n                    } else {                           // for old NTokens, 95% to miners, 5% to the bidder\n                        _ntokenH = _ntokenAmount.mul(MiningV1Data.MINING_LEGACY_NTOKEN_MINER_REWARD_PERCENTAGE).div(100);\n                        INTokenLegacy(_ntoken).increaseTotal(_ntokenAmount);\n                        INTokenLegacy(_ntoken).transfer(state.C_NestPool, _ntokenAmount);\n                        INestPool(state.C_NestPool).addNToken(_bidder, _ntoken, _ntokenAmount.sub(_ntokenH));\n                    }\n                }\n                _ethH = _ethH.add(ethNum);\n                state.minedAtHeight[token][block.number] = (_ntokenH * (1<< 128) + _ethH);\n            }\n        }\n\n        // calculate the average-prices and volatilities for (TOKEN. NTOKEN)\n\n        state._stat(token);\n        state._stat(_ntoken);\n        return; \n    }\n\n    /// @notice Close a price sheet of (ETH, USDx) | (ETH, NEST) | (ETH, TOKEN) | (ETH, NTOKEN)\n    /// @dev Here we allow an empty price sheet (still in VERIFICATION-PERIOD) to be closed \n    /// @param token The address of TOKEN contract\n    /// @param index The index of the price sheet w.r.t. `token`\n    function close(address token, uint256 index) \n        public \n        noContract \n    {\n\n        state._close(token, index);\n\n        // calculate average-price and volatility (forward)\n        state._stat(token);\n\n    }\n\n \n    /// @notice Close a price sheet and withdraw assets for WEB users.  \n    /// @dev Contracts aren't allowed to call it.\n    /// @param token The address of TOKEN contract\n    /// @param index The index of the price sheet w.r.t. `token`\n    function closeAndWithdraw(address token, uint256 index) \n        external \n        noContract\n    {\n       state._closeAndWithdraw(token, index);\n       state._stat(token);\n    }\n\n    /// @notice Close a batch of price sheets passed VERIFICATION-PHASE\n    /// @dev Empty sheets but in VERIFICATION-PHASE aren't allowed\n    /// @param token The address of TOKEN contract\n    /// @param indices A list of indices of sheets w.r.t. `token`\n    function closeList(address token, uint32[] memory indices) \n        external \n        noContract\n    {\n        state._closeList(token, indices);\n\n        state._stat(token);\n\n    }\n\n\n    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\n    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\n    /// @param token The address of token(ntoken)\n    /// @param index The position of the sheet in priceSheetList[token]\n    /// @param biteNum The amount of bitting (in the unit of ETH), realAmount = biteNum * newTokenAmountPerEth\n    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\n    function biteToken(address token, uint256 index, uint256 biteNum, uint256 newTokenAmountPerEth) \n        external \n        payable \n        noContract\n    {\n        state._biteToken(token, index, biteNum, newTokenAmountPerEth);\n        state._stat(token);\n    }\n\n    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\n    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\n    /// @param token The address of token(ntoken)\n    /// @param index The position of the sheet in priceSheetList[token]\n    /// @param biteNum The amount of bitting (in the unit of ETH), realAmount = biteNum * newTokenAmountPerEth\n    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\n    function biteEth(address token, uint256 index, uint256 biteNum, uint256 newTokenAmountPerEth)\n        external\n        payable\n        noContract\n    {\n        state._biteEth(token, index, biteNum, newTokenAmountPerEth);\n        state._stat(token);\n    }\n    \n    /* ========== PRICE QUERIES ========== */\n\n    /// @notice Get the latest effective price for a token\n    /// @dev It shouldn't be read from any contracts other than NestQuery\n    function latestPriceOf(address token) \n        public \n        view \n        onlyByNest\n        returns(uint256 ethAmount, uint256 tokenAmount, uint256 blockNum) \n    {\n        MiningV1Data.PriceSheet[] storage _plist = state.priceSheetList[token];\n        uint256 len = _plist.length;\n        uint256 _ethNum;\n        MiningV1Data.PriceSheet memory _sheet;\n        if (len == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 _first = 0;\n        for (uint i = 1; i <= len; i++) {\n            _sheet = _plist[len-i];\n            if (_first == 0 && _sheet.height + state.priceDurationBlock < block.number) {\n                _first = uint256(_sheet.height);\n                _ethNum = uint256(_sheet.remainNum);\n                tokenAmount = uint256(_sheet.tokenAmountPerEth).mul(_ethNum);\n                ethAmount = _ethNum.mul(1 ether);\n                blockNum = _first;\n            } else if (_first == uint256(_sheet.height)) {\n                _ethNum = _ethNum.add(_sheet.remainNum);\n                tokenAmount = tokenAmount.add(uint256(_sheet.tokenAmountPerEth).mul(_ethNum));\n                ethAmount = _ethNum.mul(1 ether);\n            } else if (_first > uint256(_sheet.height)) {\n                break;\n            }\n        }\n        blockNum = blockNum + uint256(state.priceDurationBlock); // safe math\n    }\n\n    /// @dev It shouldn't be read from any contracts other than NestQuery\n    function priceOf(address token)\n        public\n        view\n        noContractExcept(state.C_NestQuery)\n        returns(uint256 ethAmount, uint256 tokenAmount, uint256 blockNum) \n    {\n        MiningV1Data.PriceInfo memory pi = state.priceInfo[token];\n        require(pi.height > 0, \"Nest:Mine:NO(price)\");\n        return (uint256(pi.ethNum).mul(1 ether), pi.tokenAmount, pi.height + state.priceDurationBlock);\n    }\n\n    /// @dev It shouldn't be read from any contracts other than NestQuery\n    function priceAvgAndSigmaOf(address token) \n        public \n        view \n        onlyByNest\n        returns (uint128, uint128, int128, uint32) \n    {\n        MiningV1Data.PriceInfo memory pi = state.priceInfo[token];\n        require(pi.height > 0, \"Nest:Mine:NO(price)\");\n        int128 v = ABDKMath64x64.sqrt(ABDKMath64x64.abs(pi.volatility_sigma_sq));\n        uint128 p = uint128(uint256(pi.tokenAmount).div(uint256(pi.ethNum)));\n        return (p, pi.avgTokenAmount, v, pi.height + uint32(state.priceDurationBlock)); // safe math\n    }\n\n    function priceOfTokenAtHeight(address token, uint64 atHeight) \n        public \n        view \n        noContractExcept(state.C_NestQuery)\n        returns(uint256 ethAmount, uint256 tokenAmount, uint256 height) \n    {\n        return state._priceOfTokenAtHeight(token, atHeight);\n    }\n\n    /// @notice Return a consecutive price list for a token \n    /// @dev \n    /// @param token The address of token contract\n    /// @param num   The length of price list\n    function priceListOfToken(address token, uint8 num) \n        external view \n        noContractExcept(state.C_NestQuery)\n        returns (uint128[] memory data, uint256 bn) \n    {\n        return state._priceListOfToken(token, num);\n    }\n\n    /* ========== MINING ========== */\n    \n    function mineNest() public view returns (uint256) \n    {\n        uint256 _period = block.number.sub(MiningV1Data.MINING_NEST_GENESIS_BLOCK_HEIGHT).div(MiningV1Data.MINING_NEST_YIELD_CUTBACK_PERIOD);\n        uint256 _nestPerBlock;\n        if (_period > 9) {\n            _nestPerBlock = MiningV1Data.MINING_NEST_YIELD_OFF_PERIOD_AMOUNT;\n            if (block.number > MiningV1Data.MINING_FINAL_BLOCK_NUMBER) {\n                return 0;  // NEST is empty\n            }\n        } else {\n            _nestPerBlock = state._mining_nest_yield_per_block_amount[_period];\n        }\n        \n        return _nestPerBlock.mul(block.number.sub(state.latestMiningHeight));\n    }\n\n/*\n    function yieldAmountAtHeight(uint64 height) public view returns (uint128) {\n        uint256 period = uint256(height).sub(MINING_NEST_GENESIS_BLOCK_HEIGHT).div(MINING_NEST_YIELD_CUTBACK_PERIOD);\n        uint256 nestPerBlock;\n        if (period > 9) {\n            nestPerBlock = MINING_NEST_YIELD_OFF_PERIOD_AMOUNT;\n        } else {\n            nestPerBlock = _mining_nest_yield_per_block_amount[period];\n        }\n        uint256 yieldAmount = nestPerBlock.mul(uint256(height).sub(latestMiningHeight));\n        return uint128(yieldAmount);\n    }\n    */\n\n    function minedNestAmount() external view returns (uint256) \n    {\n       return uint256(state.minedNestAmount);\n    }\n\n    function latestMinedHeight() external view returns (uint64) \n    {\n       return uint64(state.latestMiningHeight);\n    }\n\n    function mineNToken(address ntoken) public view returns (uint256) \n    {\n        (uint256 _genesis, uint256 _last) = INToken(ntoken).checkBlockInfo();\n\n        uint256 _period = block.number.sub(_genesis).div(MiningV1Data.MINING_NEST_YIELD_CUTBACK_PERIOD);\n        uint256 _ntokenPerBlock;\n        if (_period > 9) {\n            _ntokenPerBlock = MiningV1Data.MINING_NTOKEN_YIELD_OFF_PERIOD_AMOUNT;\n        } else {\n            _ntokenPerBlock = state._mining_ntoken_yield_per_block_amount[_period];\n        }\n        uint256 _interval = block.number.sub(_last);\n        if (_interval > MiningV1Data.MINING_NTOKEN_YIELD_BLOCK_LIMIT) {\n            _interval = MiningV1Data.MINING_NTOKEN_YIELD_BLOCK_LIMIT;\n        }\n\n        // NOTE: no NTOKEN rewards if the mining interval is greater than a pre-defined number\n        uint256 yieldAmount = _ntokenPerBlock.mul(_interval);\n        return yieldAmount;\n    }\n\n    /* ========== WITHDRAW ========== */\n\n    function withdrawEth(uint256 ethAmount) \n        external nonReentrant\n    {\n        INestPool(state.C_NestPool).withdrawEth(address(msg.sender), ethAmount); \n    }\n\n    function withdrawEthAndToken(uint256 ethAmount, address token, uint256 tokenAmount) \n        external nonReentrant\n    {\n        INestPool(state.C_NestPool).withdrawEthAndToken(address(msg.sender), ethAmount, token, tokenAmount); \n    }\n\n    function withdrawNest(uint256 nestAmount) \n        external nonReentrant\n    {\n        INestPool(state.C_NestPool).withdrawNest(address(msg.sender), nestAmount); \n    }\n\n    function withdrawEthAndTokenAndNest(uint256 ethAmount, address token, uint256 tokenAmount, uint256 nestAmount) \n        external nonReentrant\n    {\n        INestPool(state.C_NestPool).withdrawEthAndToken(address(msg.sender), ethAmount, token, tokenAmount); \n        INestPool(state.C_NestPool).withdrawNest(address(msg.sender), nestAmount);\n    }\n\n    /* ========== VIEWS ========== */\n\n    function lengthOfPriceSheets(address token) \n        view \n        external \n        returns (uint256)\n    {\n        return state.priceSheetList[token].length;\n    }\n\n    function priceSheet(address token, uint256 index) \n        view external \n        returns (MiningV1Data.PriceSheetPub memory sheet) \n    {\n        return state._priceSheet(token, index); \n    }\n\n    function fullPriceSheet(address token, uint256 index) \n        view \n        public\n        noContract\n        returns (MiningV1Data.PriceSheet memory sheet) \n    {\n        uint256 len = state.priceSheetList[token].length;\n        require (index < len, \"Nest:Mine:>(len)\");\n        return state.priceSheetList[token][index];\n    }\n\n    function unVerifiedSheetList(address token) \n        view \n        public\n        noContract\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \n    {\n        return state.unVerifiedSheetList(token);\n    }\n\n    function unClosedSheetListOf(address miner, address token, uint256 fromIndex, uint256 num) \n        view \n        public\n        noContract\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \n    {\n        return state.unClosedSheetListOf(miner, token, fromIndex, num);\n    }\n\n    function sheetListOf(address miner, address token, uint256 fromIndex, uint256 num) \n        view \n        public\n        noContract\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \n    {\n        return state.sheetListOf(miner, token, fromIndex, num);\n    }\n\n    /* ========== CALCULATION ========== */\n\n    function stat(address _token) public \n    {\n        return state._stat(_token);\n    }\n\n\n    /* ========== ENCODING/DECODING ========== */\n\n    // function decodeU256Two(uint256 enc) public pure returns (uint128, uint128) {\n    //     return (uint128(enc / (1 << 128)), uint128(enc % (1 << 128)));\n    // }\n\n    /*\n    function decode(bytes32 x) internal pure returns (uint64 a, uint64 b, uint64 c, uint64 d) {\n        assembly {\n            d := x\n            mstore(0x18, x)\n            a := mload(0)\n            mstore(0x10, x)\n            b := mload(0)\n            mstore(0x8, x)\n            c := mload(0)\n        }\n    }\n   \n    /// @dev The function will be disabled when the upgrading is completed\n    /// TODO: (TBD) auth needed? \n    function post2Only4Upgrade(\n            address token,\n            uint256 ethNum,\n            uint256 tokenAmountPerEth,\n            uint256 ntokenAmountPerEth\n        )\n        external \n        noContract\n    {\n       // only avialble in upgrade phase\n        require (flag == MINING_FLAG_UPGRADE_NEEDED, \"Nest:Mine:!flag\");\n        state._post2Only4Upgrade(token, ethNum, tokenAmountPerEth, ntokenAmountPerEth);\n        address _ntoken = INestPool(state.C_NestPool).getNTokenFromToken(token);\n\n        // calculate average price and volatility\n        state._stat(token);\n        state._stat(_ntoken);\n    }\n    */\n}"
    },
    "contracts/libminingv1/MiningV1Data.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\n\nimport \"../iface/INestPool.sol\";\nimport \"../iface/INestStaking.sol\";\nimport \"../iface/INToken.sol\";\nimport \"../iface/INNRewardPool.sol\";\n\nimport \"../lib/SafeERC20.sol\";\n\n\n/// @author Inf Loop - \n/// @author 0x00  - <0x00@nestprotocol.org>\nlibrary MiningV1Data {\n\n    /* ========== CONSTANTS ========== */\n\n    // uint256 constant PRICE_DURATION_BLOCK = 25;\n\n    // uint256 constant MINING_NEST_GENESIS_BLOCK_HEIGHT = 6236588;\n    uint256 constant MINING_NEST_GENESIS_BLOCK_HEIGHT = 1; // for testing    \n\n    uint256 constant MINING_NEST_YIELD_CUTBACK_PERIOD = 2400000; // ~ 1 years \n    uint256 constant MINING_NEST_YIELD_CUTBACK_RATE = 80;     // percentage = 80%\n\n    // yield amount (per block) after the first ten years\n    uint256 constant MINING_NEST_YIELD_OFF_PERIOD_AMOUNT = 40 ether;\n    // yield amount (per block) in the first year, it drops to 80% in the following nine years\n    uint256 constant MINING_NEST_YIELD_PER_BLOCK_BASE = 400 ether;\n\n    uint256 constant MINING_NTOKEN_YIELD_CUTBACK_RATE = 80;\n    uint256 constant MINING_NTOKEN_YIELD_OFF_PERIOD_AMOUNT = 0.4 ether;\n    uint256 constant MINING_NTOKEN_YIELD_PER_BLOCK_BASE = 4 ether;\n\n    uint256 constant MINING_GENESIS_BLOCK_NUMBER = 6236588;\n    uint256 constant MINING_FINAL_BLOCK_NUMBER = 173121488;\n\n\n    uint256 constant MINING_NEST_FEE_DIVIDEND_RATE = 80;    // percentage = 80%\n    uint256 constant MINING_NEST_FEE_DAO_RATE = 20;         // percentage = 80%\n\n    uint256 constant MINING_NTOKEN_FEE_DIVIDEND_RATE        = 60;     // percentage = 60%\n    uint256 constant MINING_NTOKEN_FEE_DAO_RATE             = 20;     // percentage = 20%\n    uint256 constant MINING_NTOKEN_FEE_NEST_DAO_RATE        = 20;     // percentage = 20%\n\n    uint256 constant MINING_NTOKEN_YIELD_BLOCK_LIMIT = 100;\n\n    // uint256[10] private _mining_ntoken_yield_per_block_amount;\n\n    //uint256 constant c_mining_eth_unit = 10;  // 10 ether\n    // uint256 constant c_mining_price_deviateion_factor = 10; // removed\n    //uint256 constant c_mining_fee_thousandth = 10;\n\n    uint256 constant NN_NEST_REWARD_PERCENTAGE = 15;\n    uint256 constant DAO_NEST_REWARD_PERCENTAGE = 5;\n    uint256 constant MINER_NEST_REWARD_PERCENTAGE = 80;\n    // uint256 constant BIDDER_NTOKEN_REWARD_PERCENTAGE = 5;\n\n    uint256 constant MINING_LEGACY_NTOKEN_MINER_REWARD_PERCENTAGE = 95;\n    uint256 constant MINING_LEGACY_NTOKEN_BIDDER_REWARD_PERCENTAGE = 5;\n\n    uint8 constant PRICESHEET_STATE_CLOSED = 0;\n    uint8 constant PRICESHEET_STATE_POSTED = 1;\n    uint8 constant PRICESHEET_STATE_BITTEN = 2;\n\n    uint8 constant PRICESHEET_TYPE_USD     = 1;\n    uint8 constant PRICESHEET_TYPE_NEST    = 2;\n    uint8 constant PRICESHEET_TYPE_TOKEN   = 3;\n    uint8 constant PRICESHEET_TYPE_NTOKEN  = 4;\n    uint8 constant PRICESHEET_TYPE_BITTING = 8;\n\n\n    uint8 constant STATE_FLAG_UNINITIALIZED    = 0;\n    uint8 constant STATE_FLAG_SETUP_NEEDED     = 1;\n    uint8 constant STATE_FLAG_ACTIVE           = 3;\n    uint8 constant STATE_FLAG_MINING_STOPPED   = 4;\n    uint8 constant STATE_FLAG_CLOSING_STOPPED  = 5;\n    uint8 constant STATE_FLAG_WITHDRAW_STOPPED = 6;\n    uint8 constant STATE_FLAG_PRICE_STOPPED    = 7;\n    uint8 constant STATE_FLAG_SHUTDOWN         = 127;\n\n    uint256 constant MINING_NTOKEN_NON_DUAL_POST_THRESHOLD = 5_000_000 ether;\n\n\n    /// @dev size: (2 x 256 bit)\n    struct PriceSheet {    \n        uint160 miner;       //  miner who posted the price (most significant bits, or left-most)\n        uint32  height;\n        uint32  ethNum;   \n        uint32  remainNum;    \n\n        uint8   level;           // the level of bitting, 1-4: eth-doubling | 5 - 127: nest-doubling\n        uint8   typ;             // 1: USD | 2: NEST | 3: TOKEN | 4: NTOKEN(Not Available)\n        uint8   state;           // 0: closed | 1: posted | 2: bitten\n        uint8   _reserved; \n        uint32  ethNumBal;\n        uint32  tokenNumBal;\n        uint32  nestNum1k;\n        uint128 tokenAmountPerEth;\n    }\n    \n    /// @dev size: (3 x 256 bit)\n    struct PriceInfo {\n        uint32  index;\n        uint32  height;\n        uint32  ethNum;         //  the balance of eth\n        uint32  _reserved;\n        uint128 tokenAmount;    //  the balance of token \n        int128  volatility_sigma_sq;\n        int128  volatility_ut_sq;\n        uint128  avgTokenAmount;\n        uint128 _reserved2;     \n    }\n\n\n    /// @dev The struct is for public data in a price sheet, so as to protect prices from being read\n    struct PriceSheetPub {\n        uint160 miner;       //  miner who posted the price (most significant bits, or left-most)\n        uint32  height;\n        uint32  ethNum;   \n\n        uint8   typ;             // 1: USD | 2: NEST | 3: TOKEN | 4: NTOKEN(Not Available)\n        uint8   state;           // 0: closed | 1: posted | 2: bitten\n        uint32  ethNumBal;\n        uint32  tokenNumBal;\n    }\n\n\n    struct PriceSheetPub2 {\n        uint160 miner;       //  miner who posted the price (most significant bits, or left-most)\n        uint32  height;\n        uint32  ethNum;   \n        uint32  remainNum; \n\n        uint8   level;           // the level of bitting, 1-4: eth-doubling | 5 - 127: nest-doubling\n        uint8   typ;             // 1: USD | 2: NEST | 3: TOKEN | 4: NTOKEN(Not Available)\n        uint8   state;           // 0: closed | 1: posted | 2: bitten\n        uint256 index;           // return to the quotation of index\n        uint32  nestNum1k;\n        uint128 tokenAmountPerEth;   \n    }\n\n    /* ========== EVENTS ========== */\n\n    event PricePosted(address miner, address token, uint256 index, uint256 ethAmount, uint256 tokenAmount);\n    event PriceClosed(address miner, address token, uint256 index);\n    event Deposit(address miner, address token, uint256 amount);\n    event Withdraw(address miner, address token, uint256 amount);\n    event TokenBought(address miner, address token, uint256 index, uint256 biteEthAmount, uint256 biteTokenAmount);\n    event TokenSold(address miner, address token, uint256 index, uint256 biteEthAmount, uint256 biteTokenAmount);\n\n    event VolaComputed(uint32 h, uint32 pos, uint32 ethA, uint128 tokenA, int128 sigma_sq, int128 ut_sq);\n\n    event SetParams(uint8 miningEthUnit, uint32 nestStakedNum1k, uint8 biteFeeRate,\n                    uint8 miningFeeRate, uint8 priceDurationBlock, uint8 maxBiteNestedLevel,\n                    uint8 biteInflateFactor, uint8 biteNestInflateFactor);\n\n    // event GovSet(address oldGov, address newGov);\n\n    /* ========== GIANT STATE VARIABLE ========== */\n\n    struct State {\n        // TODO: more comments\n\n        uint8   miningEthUnit;      // = 10;\n        uint32  nestStakedNum1k;    // = 100;\n        uint8   biteFeeRate;        // = 1; \n        uint8   miningFeeRate;      // = 10;\n        uint8   priceDurationBlock; // = 25;\n        uint8   maxBiteNestedLevel; // = 3;\n        uint8   biteInflateFactor;  // = 2;\n        uint8   biteNestInflateFactor; // = 2;\n\n        uint32  genesisBlock;       // = 6236588;\n\n        uint128  latestMiningHeight;\n        uint128  minedNestAmount;   \n        \n        address  _developer_address;\n        address  _NN_address;\n\n        address     C_NestPool;\n        address     C_NestToken;\n        address     C_NestStaking;\n        address     C_NNRewardPool;\n        address     C_NestQuery;\n        address     C_NestDAO;\n\n        uint256[10] _mining_nest_yield_per_block_amount;\n        uint256[10] _mining_ntoken_yield_per_block_amount;\n\n        // A mapping (from token(address) to an array of PriceSheet)\n        mapping(address => PriceSheet[]) priceSheetList;\n\n        // from token(address) to Price\n        mapping(address => PriceInfo) priceInfo;\n\n        // (token-address, block-number) => (ethFee-total, nest/ntoken-mined-total)\n        mapping(address => mapping(uint256 => uint256)) minedAtHeight;\n\n        uint256  _reserved1;\n        uint256  _reserved2;\n        uint256  _reserved3;\n        uint256  _reserved4;\n    }\n\n}"
    },
    "contracts/libminingv1/MiningV1Calc.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/SafeMath.sol\";\nimport \"../lib/SafeERC20.sol\";\nimport '../lib/TransferHelper.sol';\nimport \"../lib/ABDKMath64x64.sol\";\n\nimport \"../iface/INestPool.sol\";\nimport \"../iface/INestStaking.sol\";\nimport \"../iface/INToken.sol\";\nimport \"../iface/INNRewardPool.sol\";\nimport \"../libminingv1/MiningV1Data.sol\";\n//import \"hardhat/console.sol\";\n\n\n/// @title  NestMiningV1/MiningV1Calc\n/// @author Inf Loop - \n/// @author Paradox  - \nlibrary MiningV1Calc {\n\n    using SafeMath for uint256;\n    // average block-out time: 14s\n    uint8 constant timespan = 14;\n    function _calcVola(\n            // uint256 ethA0, \n            uint256 tokenA0, \n            // uint256 ethA1, \n            uint256 tokenA1, \n            int128 _sigma_sq, \n            int128 _ut_sq,\n            uint256 _interval\n        ) \n        private \n        pure\n        // pure \n        returns (int128, int128)\n    {\n        int128 _ut_sq_2 = ABDKMath64x64.div(_ut_sq, \n            ABDKMath64x64.fromUInt(_interval.mul(timespan)));\n\n        int128 _new_sigma_sq = ABDKMath64x64.add(\n            ABDKMath64x64.mul(ABDKMath64x64.divu(95, 100), _sigma_sq), \n            ABDKMath64x64.mul(ABDKMath64x64.divu(5,100), _ut_sq_2));\n\n        int128 _new_ut_sq;\n        _new_ut_sq = ABDKMath64x64.pow(ABDKMath64x64.sub(\n                    ABDKMath64x64.divu(tokenA1, tokenA0), \n                    ABDKMath64x64.fromUInt(1)), \n                2);\n        \n        return (_new_sigma_sq, _new_ut_sq);\n    }\n\n    function _calcAvg(uint256 ethA, uint256 tokenA, uint256 _avg) \n        private \n        pure\n        returns(uint256)\n    {\n        uint256 _newP = tokenA.div(ethA);\n        uint256 _newAvg;\n\n        if (_avg == 0) {\n            _newAvg = _newP;\n        } else {\n            _newAvg = (_avg.mul(95).div(100)).add(_newP.mul(5).div(100));\n            // _newAvg = ABDKMath64x64.add(\n            //     ABDKMath64x64.mul(ABDKMath64x64.divu(95, 100), _avg),\n            //     ABDKMath64x64.mul(ABDKMath64x64.divu(5,100), _newP));\n        }\n\n        return _newAvg;\n    }\n\n    function _moveAndCalc(\n            MiningV1Data.PriceInfo memory p0,\n            MiningV1Data.PriceSheet[] storage pL,\n            uint256 priceDurationBlock\n        )\n        private\n        view\n        returns (MiningV1Data.PriceInfo memory)\n    {\n        uint256 i = p0.index + 1;\n        if (i >= pL.length) {\n            return (MiningV1Data.PriceInfo(0,0,0,0,0,int128(0),int128(0), uint128(0), 0));\n        }\n\n        uint256 h = uint256(pL[i].height);\n        if (h + priceDurationBlock >= block.number) {\n            return (MiningV1Data.PriceInfo(0,0,0,0,0,int128(0),int128(0), uint128(0), 0));\n        }\n\n        uint256 ethA1 = 0;\n        uint256 tokenA1 = 0;\n        while (i < pL.length && pL[i].height == h) { \n            uint256 _remain = uint256(pL[i].remainNum);\n            if (_remain == 0) {\n                i = i + 1;\n                continue;\n            }\n            ethA1 = ethA1 + _remain;\n            tokenA1 = tokenA1 + _remain.mul(pL[i].tokenAmountPerEth);\n            i = i + 1;\n        }\n        i = i - 1;\n\n        if (ethA1 == 0 || tokenA1 == 0) {\n            return (MiningV1Data.PriceInfo(\n                    uint32(i),  // index\n                    uint32(0),  // height\n                    uint32(0),  // ethNum\n                    uint32(0),  // _reserved\n                    uint32(0),  // tokenAmount\n                    int128(0),  // volatility_sigma_sq\n                    int128(0),  // volatility_ut_sq\n                    uint128(0),  // avgTokenAmount\n                    0           // _reserved2\n            ));\n        }\n        int128 new_sigma_sq;\n        int128 new_ut_sq;\n        {\n            if (uint256(p0.ethNum) != 0) {\n                (new_sigma_sq, new_ut_sq) = _calcVola(\n                    uint256(p0.tokenAmount).div(uint256(p0.ethNum)), \n                    uint256(tokenA1).div(uint256(ethA1)),\n                p0.volatility_sigma_sq, p0.volatility_ut_sq, \n                i - p0.index);\n            }\n        }\n        uint256 _newAvg = _calcAvg(ethA1, tokenA1, p0.avgTokenAmount); \n\n        return(MiningV1Data.PriceInfo(\n                uint32(i),          // index\n                uint32(h),          // height\n                uint32(ethA1),      // ethNum\n                uint32(0),          // _reserved\n                uint128(tokenA1),   // tokenAmount\n                new_sigma_sq,       // volatility_sigma_sq\n                new_ut_sq,          // volatility_ut_sq\n                uint128(_newAvg),   // avgTokenAmount\n                uint128(0)          // _reserved2\n        ));\n    }\n\n    /// @dev The function updates the statistics of price sheets\n    ///     It calculates from priceInfo to the newest that is effective.\n    ///     Different from `_statOneBlock()`, it may cross multiple blocks.\n    function _stat(MiningV1Data.State storage state, address token)\n        external \n    {\n        MiningV1Data.PriceInfo memory p0 = state.priceInfo[token];\n        MiningV1Data.PriceSheet[] storage pL = state.priceSheetList[token];\n\n        if (pL.length < 2) {\n            return;\n        }\n\n        if (p0.height == 0) {\n            MiningV1Data.PriceSheet memory _sheet = pL[0];\n            p0.ethNum = _sheet.ethNum;\n            p0.tokenAmount = uint128(uint256(_sheet.tokenAmountPerEth).mul(_sheet.ethNum));\n            p0.height = _sheet.height;\n            p0.volatility_sigma_sq = 0;\n            p0.volatility_ut_sq = 0;\n            p0.avgTokenAmount = uint128(_sheet.tokenAmountPerEth);\n            state.priceInfo[token] = p0;\n        }\n\n        MiningV1Data.PriceInfo memory p1;\n\n        // record the gas usage\n        uint256 startGas = gasleft();\n        uint256 gasUsed;\n\n        while (uint256(p0.index) < pL.length && uint256(p0.height) + state.priceDurationBlock < block.number){\n            gasUsed = startGas - gasleft();\n            // NOTE: check gas usage to prevent DOS attacks\n            if (gasUsed > 1_000_000) {\n                break; \n            }\n            p1 = _moveAndCalc(p0, pL, state.priceDurationBlock);\n            if (p1.index <= p0.index) {    // bootstraping\n                break;\n            } else if (p1.ethNum == 0) {   // jump cross a block with bitten prices\n                p0.index = p1.index;\n                continue;\n            } else {                       // calculate one more block\n                p0 = p1;\n            }\n        }\n\n        if (p0.index > state.priceInfo[token].index) {\n            state.priceInfo[token] = p0;\n        }\n        return;\n    }\n\n    /// @dev The function updates the statistics of price sheets across only one block.\n    function _statOneBlock(MiningV1Data.State storage state, address token) \n        external \n    {\n        MiningV1Data.PriceInfo memory p0 = state.priceInfo[token];\n        MiningV1Data.PriceSheet[] storage pL = state.priceSheetList[token];\n        if (pL.length < 2) {\n            return;\n        }\n        (MiningV1Data.PriceInfo memory p1) = _moveAndCalc(p0, state.priceSheetList[token], state.priceDurationBlock);\n        if (p1.index > p0.index && p1.ethNum != 0) {\n            state.priceInfo[token] = p1;\n        } else if (p1.index > p0.index && p1.ethNum == 0) {\n            p0.index = p1.index;\n            state.priceInfo[token] = p1;\n        }\n        return;\n    }\n\n    /// @notice Return a consecutive price list for a token \n    /// @dev \n    /// @param token The address of token contract\n    /// @param num   The length of price list\n    function _priceListOfToken(\n            MiningV1Data.State storage state, \n            address token, \n            uint8 num\n        )\n        external \n        view\n        returns (uint128[] memory data, uint256 bn) \n    {\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token];\n        uint256 len = _list.length;\n        uint256 _index = 0;\n        data = new uint128[](num * 3);\n        MiningV1Data.PriceSheet memory _sheet;\n        uint256 _ethNum;\n\n        // loop\n        uint256 _curr = 0;\n        uint256 _prev = 0;\n        for (uint i = 1; i <= len; i++) {\n            _sheet = _list[len - i];\n            _curr = uint256(_sheet.height);\n            if (_prev == 0) {\n                if (_curr + state.priceDurationBlock < block.number) {\n                    data[_index] = uint128(_curr + state.priceDurationBlock); // safe math\n                    _ethNum = uint256(_sheet.remainNum);\n                    data[_index + 1] = uint128(_ethNum.mul(1 ether));\n                    data[_index + 2] = uint128(_ethNum.mul(_sheet.tokenAmountPerEth));\n                    bn = _curr + state.priceDurationBlock;  // safe math\n                    _prev = _curr;\n                }\n            } else if (_prev == _curr) {\n                _ethNum = uint256(_sheet.remainNum);\n                data[_index + 1] += uint128(_ethNum.mul(1 ether));\n                data[_index + 2] += uint128(_ethNum.mul(_sheet.tokenAmountPerEth));\n            } else if (_prev > _curr) {\n                _index += 3;\n                if (_index >= uint256(num * 3)) {\n                    break;\n                }\n                data[_index] = uint128(_curr + state.priceDurationBlock); // safe math\n                _ethNum = uint256(_sheet.remainNum);\n                data[_index + 1] = uint128(_ethNum.mul(1 ether));\n                data[_index + 2] = uint128(_ethNum.mul(_sheet.tokenAmountPerEth));\n                _prev = _curr;\n            }\n        } \n        // require (data.length == uint256(num * 3), \"Incorrect price list length\");\n    }\n\n\n    function _priceOfTokenAtHeight(\n            MiningV1Data.State storage state, \n            address token, \n            uint64 atHeight\n        )\n        external \n        view \n        returns(uint256 ethAmount, uint256 tokenAmount, uint256 blockNum) \n    {\n\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token];\n        uint256 len = state.priceSheetList[token].length;\n        MiningV1Data.PriceSheet memory _sheet;\n        uint256 _ethNum;\n\n        if (len == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 _first = 0;\n        uint256 _prev = 0;\n        for (uint i = 1; i <= len; i++) {\n            _sheet = _list[len - i];\n            _first = uint256(_sheet.height);\n            if (_prev == 0) {\n                if (_first <= uint256(atHeight) && _first + state.priceDurationBlock < block.number) {\n                    _ethNum = uint256(_sheet.remainNum);\n                    ethAmount = _ethNum.mul(1 ether);\n                    tokenAmount = _ethNum.mul(_sheet.tokenAmountPerEth);\n                    blockNum = _first;\n                    _prev = _first;\n                }\n            } else if (_first == _prev) {\n                _ethNum = uint256(_sheet.remainNum);\n                ethAmount = ethAmount.add(_ethNum.mul(1 ether));\n                tokenAmount = tokenAmount.add(_ethNum.mul(_sheet.tokenAmountPerEth));\n            } else if (_prev > _first) {\n                break;\n            }\n        }\n    }\n\n    function _priceSheet(\n            MiningV1Data.State storage state, \n            address token, \n            uint256 index\n        ) \n        view external \n        returns (MiningV1Data.PriceSheetPub memory sheet) \n    {\n        uint256 len = state.priceSheetList[token].length;\n        require (index < len, \"Nest:Mine:!index\");\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index];\n        sheet.miner = _sheet.miner;\n        sheet.height = _sheet.height;\n        sheet.ethNum = _sheet.ethNum;\n        sheet.typ = _sheet.typ;\n        sheet.state = _sheet.state;\n        sheet.ethNumBal = _sheet.ethNumBal;\n        sheet.tokenNumBal = _sheet.tokenNumBal;\n    }\n\n    \n    function unVerifiedSheetList(\n            MiningV1Data.State storage state, \n            address token\n        ) \n        view \n        public\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \n    {\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token]; \n        uint256 len = _list.length;\n        uint256 num;\n        for (uint i = 0; i < len; i++) {\n            if (_list[len - 1 - i].height + state.priceDurationBlock < block.number) {\n                break;\n            }\n            num += 1;\n        }\n\n        sheets = new MiningV1Data.PriceSheetPub2[](num);\n        for (uint i = 0; i < num; i++) {\n            MiningV1Data.PriceSheet memory _sheet = _list[len - 1 - i];\n            if (_sheet.height + state.priceDurationBlock < block.number) {\n                break;\n            }\n            //sheets[i] = _sheet;\n            sheets[i].miner = _sheet.miner;\n            sheets[i].height = _sheet.height;\n            sheets[i].ethNum = _sheet.ethNum;\n            sheets[i].remainNum = _sheet.remainNum;\n            sheets[i].level = _sheet.level;\n            sheets[i].typ = _sheet.typ;\n            sheets[i].state = _sheet.state;\n\n            sheets[i].index = len - 1 - i;\n\n            sheets[i].nestNum1k = _sheet.nestNum1k;\n            sheets[i].tokenAmountPerEth = _sheet.tokenAmountPerEth;\n        }\n    }\n\n    function unClosedSheetListOf(\n            MiningV1Data.State storage state, \n            address miner, \n            address token, \n            uint256 fromIndex, \n            uint256 num) \n        view \n        external\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \n    {\n        sheets = new MiningV1Data.PriceSheetPub2[](num);\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token]; \n        uint256 len = _list.length;\n        require(fromIndex < len, \"Nest:Mine:!from\");\n\n        for (uint i = 0; i < num; i++) {\n            if (fromIndex < i) {\n                break;\n            }\n\n            MiningV1Data.PriceSheet memory _sheet = _list[fromIndex - i];\n            if (uint256(_sheet.miner) == uint256(miner)\n                && (_sheet.state == MiningV1Data.PRICESHEET_STATE_POSTED \n                    || _sheet.state == MiningV1Data.PRICESHEET_STATE_BITTEN)) {\n            \n            sheets[i].miner = _sheet.miner;\n            sheets[i].height = _sheet.height;\n            sheets[i].ethNum = _sheet.ethNum;\n            sheets[i].remainNum = _sheet.remainNum;\n            sheets[i].level = _sheet.level;\n            sheets[i].typ = _sheet.typ;\n            sheets[i].state = _sheet.state;\n\n            sheets[i].index = fromIndex - i;\n\n            sheets[i].nestNum1k = _sheet.nestNum1k;\n            sheets[i].tokenAmountPerEth = _sheet.tokenAmountPerEth;\n\n            }\n        }\n    }\n\n    function sheetListOf(\n           MiningV1Data.State storage state, \n           address miner, \n           address token, \n           uint256 fromIndex, \n           uint256 num\n        ) \n        view \n        external\n        returns (MiningV1Data.PriceSheetPub2[] memory sheets) \n    {\n        sheets = new MiningV1Data.PriceSheetPub2[](num);\n        MiningV1Data.PriceSheet[] storage _list = state.priceSheetList[token]; \n        uint256 len = _list.length;\n        require(fromIndex < len, \"Nest:Mine:!from\");\n\n        for (uint i = 0; i < num; i++) {\n            if (fromIndex < i) {\n                break;\n            }\n            MiningV1Data.PriceSheet memory _sheet = _list[fromIndex - i];\n            if (uint256(_sheet.miner) == uint256(miner)) {\n            \n            sheets[i].miner = _sheet.miner;\n            sheets[i].height = _sheet.height;\n            sheets[i].ethNum = _sheet.ethNum;\n            sheets[i].remainNum = _sheet.remainNum;\n            sheets[i].level = _sheet.level;\n            sheets[i].typ = _sheet.typ;\n            sheets[i].state = _sheet.state;\n\n            sheets[i].index = fromIndex - i;\n\n            sheets[i].nestNum1k = _sheet.nestNum1k;\n            sheets[i].tokenAmountPerEth = _sheet.tokenAmountPerEth;\n\n            }\n        }\n    }\n\n}"
    },
    "contracts/libminingv1/MiningV1Op.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/SafeMath.sol\";\nimport \"../lib/SafeERC20.sol\";\nimport '../lib/TransferHelper.sol';\nimport \"../lib/ABDKMath64x64.sol\";\n\nimport \"../iface/INestPool.sol\";\nimport \"../iface/INestStaking.sol\";\nimport \"../iface/INToken.sol\";\nimport \"../iface/INNRewardPool.sol\";\nimport \"../libminingv1/MiningV1Data.sol\";\n\n//import \"hardhat/console.sol\";\n\n/// @title  NestMiningV1/MiningV1Calc\n/// @author Inf Loop - \n/// @author Paradox  - \nlibrary MiningV1Op {\n\n    using SafeMath for uint256;\n\n    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\n    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\n    /// @param token The address of token(ntoken)\n    /// @param index The position of the sheet in priceSheetList[token]\n    /// @param biteNum The amount of bitting (in the unit of ETH), realAmount = biteNum * newTokenAmountPerEth\n    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\n    function _biteToken(\n            MiningV1Data.State storage state, \n            address token, \n            uint256 index, \n            uint256 biteNum, \n            uint256 newTokenAmountPerEth\n        )\n        external\n    {\n        // check parameters\n        require(token != address(0x0), \"Nest:Mine:(token)=0\"); \n        require(newTokenAmountPerEth > 0, \"Nest:Mine:(price)=0\");\n        require(biteNum >= state.miningEthUnit && biteNum % state.miningEthUnit == 0, \"Nest:Mine:!(bite)\");\n\n        // check sheet\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index]; \n        require(_sheet.height + state.priceDurationBlock >= block.number, \"Nest:Mine:!EFF(sheet)\");\n        require(_sheet.remainNum >= biteNum, \"Nest:Mine:!(remain)\");\n\n        // load address of NestPool \n        INestPool _C_NestPool = INestPool(state.C_NestPool);\n\n        // check sheet sate\n        uint256 _state = uint256(_sheet.state);\n        require(_state == MiningV1Data.PRICESHEET_STATE_POSTED \n             || _state == MiningV1Data.PRICESHEET_STATE_BITTEN,  \"Nest:Mine:!(state)\");\n\n        {\n            address _ntoken = _C_NestPool.getNTokenFromToken(token);\n            uint256 _ethFee = biteNum.mul(1 ether).mul(state.biteFeeRate).div(1000);\n\n            // save the changes into miner's virtual account\n            if (msg.value.sub(_ethFee) > 0) {\n                _C_NestPool.depositEth{value:msg.value.sub(_ethFee)}(address(msg.sender));\n            }\n\n            // pump fee into staking pool\n            if (_ethFee > 0) {\n                INestStaking(state.C_NestStaking).addETHReward{value:_ethFee}(_ntoken);\n            }\n        }\n \n        // post a new price sheet\n        { \n            // check bitting conditions\n            uint256 _newEthNum;\n            uint256 _newNestNum1k = uint256(_sheet.nestNum1k);\n            {\n                uint256 _level = uint256(_sheet.level);\n                uint256 _newLevel = _level;\n\n                if (_level > state.maxBiteNestedLevel && _level < 127) { // bitten sheet, nest doubling\n                    _newEthNum = biteNum;\n                    _newNestNum1k = _newNestNum1k.mul(state.biteNestInflateFactor * biteNum).div(_sheet.ethNum);\n                    _newLevel = _level + 1;\n                } else if (_level <= state.maxBiteNestedLevel) {  // bitten sheet, eth doubling \n                    _newEthNum = biteNum.mul(state.biteInflateFactor);\n                    _newNestNum1k = _newNestNum1k.mul(state.biteNestInflateFactor * biteNum).div(_sheet.ethNum);\n                    _newLevel = _level + 1;\n                } \n\n                _C_NestPool.freezeNest(address(msg.sender), _newNestNum1k.mul(1000 * 1e18));\n\n\n                if( _newEthNum.mul(newTokenAmountPerEth) < biteNum * _sheet.tokenAmountPerEth) {\n                    uint256 _unfreezetokenAmount;\n                    //_unfreezetokenAmount = uint256(_sheet.tokenAmountPerEth).sub(uint256(newTokenAmountPerEth)).mul(biteNum);\n                    _unfreezetokenAmount = uint256(_sheet.tokenAmountPerEth).mul(biteNum).sub((uint256(newTokenAmountPerEth)).mul(_newEthNum));               \n                    _C_NestPool.unfreezeToken(msg.sender, token, _unfreezetokenAmount);\n                    _C_NestPool.freezeEth(msg.sender, _newEthNum.add(biteNum).mul(1 ether));\n                } else {\n                    _C_NestPool.freezeEthAndToken(msg.sender, _newEthNum.add(biteNum).mul(1 ether), \n                        token, _newEthNum.mul(newTokenAmountPerEth)\n                                         .sub(biteNum * _sheet.tokenAmountPerEth));\n                }\n\n                MiningV1Data.PriceSheet[] storage _sheetOfToken = state.priceSheetList[token];\n                // append a new price sheet\n                _sheetOfToken.push(MiningV1Data.PriceSheet(\n                    uint160(msg.sender),             // miner \n                    uint32(block.number),            // atHeight\n                    uint32(_newEthNum),                 // ethNum\n                    uint32(_newEthNum),                 // remainNum\n                    uint8(_newLevel),                // level\n                    uint8(_sheet.typ),               // typ\n                    uint8(MiningV1Data.PRICESHEET_STATE_POSTED),  // state \n                    uint8(0),                        // _reserved\n                    uint32(_newEthNum),                 // ethNumBal\n                    uint32(_newEthNum),                 // tokenNumBal\n                    uint32(_newNestNum1k),           // nestNum1k\n                    uint128(newTokenAmountPerEth)    // tokenAmountPerEth\n                ));\n              \n            }\n\n            _sheet.state = MiningV1Data.PRICESHEET_STATE_BITTEN;\n            _sheet.ethNumBal = uint32(uint256(_sheet.ethNumBal).add(biteNum));\n            _sheet.tokenNumBal = uint32(uint256(_sheet.tokenNumBal).sub(biteNum));\n            _sheet.remainNum = uint32(uint256(_sheet.remainNum).sub(biteNum));\n            state.priceSheetList[token][index] = _sheet;\n            \n        }\n\n        emit MiningV1Data.TokenBought(address(msg.sender), address(token), index, biteNum.mul(1 ether), biteNum.mul(_sheet.tokenAmountPerEth));\n        return; \n\n    }\n\n    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\n    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\n    /// @param token The address of token(ntoken)\n    /// @param index The position of the sheet in priceSheetList[token]\n    /// @param biteNum The amount of bitting (in the unit of ETH), realAmount = biteNum * newTokenAmountPerEth\n    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\n    function _biteEth(\n            MiningV1Data.State storage state, \n            address token, \n            uint256 index, \n            uint256 biteNum, \n            uint256 newTokenAmountPerEth\n        )\n        external\n    {\n        require(token != address(0x0), \"Nest:Mine:(token)=0\"); \n        require(newTokenAmountPerEth > 0, \"Nest:Mine:(price)=0\");\n        require(biteNum >= state.miningEthUnit && biteNum % state.miningEthUnit == 0, \"Nest:Mine:!(bite)\");\n\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index]; \n        require(block.number.sub(_sheet.height) <= state.priceDurationBlock, \"Nest:Mine:!EFF(sheet)\");\n        require(_sheet.remainNum >= biteNum, \"Nest:Mine:!(remain)\");\n\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\n\n        uint256 _state = uint256(_sheet.state);\n        require(_state == MiningV1Data.PRICESHEET_STATE_POSTED \n            || _state == MiningV1Data.PRICESHEET_STATE_BITTEN,  \"Nest:Mine:!(state)\");\n\n        {\n            address _ntoken = _C_NestPool.getNTokenFromToken(token);\n\n            uint256 _ethFee = biteNum.mul(1 ether).mul(state.biteFeeRate).div(1000);\n\n            // save the changes into miner's virtual account\n            if (msg.value.sub(_ethFee) > 0) {\n                _C_NestPool.depositEth{value:msg.value.sub(_ethFee)}(address(msg.sender));\n            }\n\n            // pump fee into staking pool\n            INestStaking(state.C_NestStaking).addETHReward{value:_ethFee}(_ntoken);\n        }\n        \n        // post a new price sheet\n        { \n            // check bitting conditions\n            uint256 _newEthNum;\n            uint256 _newNestNum1k = uint256(_sheet.nestNum1k);\n            {\n                uint256 _level = uint256(_sheet.level);\n                uint256 _newLevel = _level;\n\n                if (_level > state.maxBiteNestedLevel && _level < 127) { // bitten sheet, nest doubling\n                    _newEthNum = biteNum;\n                    _newNestNum1k = _newNestNum1k.mul(state.biteNestInflateFactor * biteNum).div(_sheet.ethNum);\n                    _newLevel = _level + 1;\n                } else if (_level <= state.maxBiteNestedLevel) {  // bitten sheet, eth doubling \n                    _newEthNum = biteNum.mul(state.biteInflateFactor);\n                    _newNestNum1k = _newNestNum1k.mul(state.biteNestInflateFactor * biteNum).div(_sheet.ethNum);\n                    _newLevel = _level + 1;\n                }\n\n                MiningV1Data.PriceSheet[] storage _sheetOfToken = state.priceSheetList[token];\n                // append a new price sheet\n                _sheetOfToken.push(MiningV1Data.PriceSheet(\n                    uint160(msg.sender),             // miner \n                    uint32(block.number),            // atHeight\n                    uint32(_newEthNum),                 // ethNum\n                    uint32(_newEthNum),                 // remainNum\n                    uint8(_newLevel),                // level\n                    uint8(_sheet.typ),               // typ\n                    uint8(MiningV1Data.PRICESHEET_STATE_POSTED),  // state \n                    uint8(0),                        // _reserved\n                    uint32(_newEthNum),                 // ethNumBal\n                    uint32(_newEthNum),                 // tokenNumBal\n                    uint32(_newNestNum1k),           // nestNum1k\n                    uint128(newTokenAmountPerEth)    // tokenAmountPerEth\n                ));\n            }\n            _C_NestPool.freezeNest(address(msg.sender), _newNestNum1k.mul(1000 * 1e18));\n            _C_NestPool.freezeEthAndToken(msg.sender, _newEthNum.sub(biteNum).mul(1 ether), \n                token, _newEthNum.mul(newTokenAmountPerEth)\n                                    .add(biteNum * _sheet.tokenAmountPerEth));\n            _sheet.state = MiningV1Data.PRICESHEET_STATE_BITTEN;\n            _sheet.ethNumBal = uint32(uint256(_sheet.ethNumBal).sub(biteNum));\n            _sheet.tokenNumBal = uint32(uint256(_sheet.tokenNumBal).add(biteNum));\n            _sheet.remainNum = uint32(uint256(_sheet.remainNum).sub(biteNum));\n            state.priceSheetList[token][index] = _sheet;\n        }\n        emit MiningV1Data.TokenSold(address(msg.sender), address(token), index, biteNum.mul(1 ether), biteNum.mul(_sheet.tokenAmountPerEth));\n        return; \n    }\n\n    /// @notice Close a price sheet of (ETH, USDx) | (ETH, NEST) | (ETH, TOKEN) | (ETH, NTOKEN)\n    /// @dev Here we allow an empty price sheet (still in VERIFICATION-PERIOD) to be closed \n    /// @param token The address of TOKEN contract\n    /// @param index The index of the price sheet w.r.t. `token`\n    function _close(\n            MiningV1Data.State storage state, \n            address token, \n            uint256 index\n        )\n        external\n    {\n        // load sheet\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index];\n        // check if the sheet is closable\n        require(_sheet.height + state.priceDurationBlock < block.number // safe_math\n            || _sheet.remainNum == 0, \"Nest:Mine:!(height)\");\n\n        // check owner\n        require(address(_sheet.miner) == address(msg.sender), \"Nest:Mine:!(miner)\");\n        // check state flag\n        require(uint256(_sheet.state) != MiningV1Data.PRICESHEET_STATE_CLOSED, \"Nest:Mine:!unclosed\");\n\n        // load ntoken\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\n        address _ntoken = _C_NestPool.getNTokenFromToken(token);\n\n        // distribute rewards (NEST or NTOKEN)\n        {\n            uint256 h = _sheet.height;\n            if (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_USD && _sheet.level == 0) {   // for (USDT, NEST)\n                uint256 _nestH = uint256(state.minedAtHeight[token][h] / (1 << 128));\n                uint256 _ethH = uint256(state.minedAtHeight[token][h] % (1 << 128));\n                uint256 _reward = uint256(_sheet.ethNum).mul(_nestH).div(_ethH);\n                _C_NestPool.addNest(address(msg.sender), _reward);\n            } else if (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_TOKEN && _sheet.level == 0) { // for (ERC20, NTOKEN)\n                uint256 _ntokenH = uint256(state.minedAtHeight[token][h] / (1 << 128));\n                uint256 _ethH = uint256(state.minedAtHeight[token][h] % (1 << 128));\n                uint256 _reward = uint256(_sheet.ethNum).mul(_ntokenH).div(_ethH);\n                _C_NestPool.addNToken(address(msg.sender), _ntoken, _reward);\n            }\n        }\n\n        // unfreeze the assets withheld by the sheet\n        {\n            uint256 _ethAmount = uint256(_sheet.ethNumBal).mul(1 ether);\n            uint256 _tokenAmount = uint256(_sheet.tokenNumBal).mul(_sheet.tokenAmountPerEth);\n            uint256 _nestAmount = uint256(_sheet.nestNum1k).mul(1000 * 1e18);\n            _sheet.ethNumBal = 0;\n            _sheet.tokenNumBal = 0;\n            _sheet.nestNum1k = 0;\n\n            _C_NestPool.unfreezeEthAndToken(address(msg.sender), _ethAmount, token, _tokenAmount);\n            _C_NestPool.unfreezeNest(address(msg.sender), _nestAmount); \n        }\n\n        // update the state flag\n        _sheet.state = MiningV1Data.PRICESHEET_STATE_CLOSED;\n\n        // write backs\n        state.priceSheetList[token][index] = _sheet;\n\n        // emit an event\n        emit MiningV1Data.PriceClosed(address(msg.sender), token, index);\n    }\n\n    /// @notice Close a price sheet and withdraw assets for WEB users.  \n    /// @dev Contracts aren't allowed to call it.\n    /// @param token The address of TOKEN contract\n    /// @param index The index of the price sheet w.r.t. `token`\n    function _closeAndWithdraw(\n            MiningV1Data.State storage state, \n            address token, \n            uint256 index\n        ) \n        external \n    {\n        // check sheet if passing verification\n        MiningV1Data.PriceSheet memory _sheet = state.priceSheetList[token][index];\n        require(_sheet.height + state.priceDurationBlock < block.number // safe_math\n            || _sheet.remainNum == 0, \"Nest:Mine:!(height)\");\n\n        // check ownership and state\n        require(address(_sheet.miner) == address(msg.sender), \"Nest:Mine:!(miner)\");\n        require(uint256(_sheet.state) != MiningV1Data.PRICESHEET_STATE_CLOSED, \"Nest:Mine:!unclosed\");\n\n        // get ntoken\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\n        address _ntoken = _C_NestPool.getNTokenFromToken(token);\n\n        {\n            uint256 h = _sheet.height;\n            if (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_USD && _sheet.level == 0) {\n                uint256 _nestH = uint256(state.minedAtHeight[token][h] / (1 << 128));\n                uint256 _ethH = uint256(state.minedAtHeight[token][h] % (1 << 128));\n                uint256 _reward = uint256(_sheet.ethNum).mul(_nestH).div(_ethH);\n                _C_NestPool.addNest(address(msg.sender), _reward);\n            } else if (_sheet.typ == MiningV1Data.PRICESHEET_TYPE_TOKEN && _sheet.level == 0) {\n                uint256 _ntokenH = uint256(state.minedAtHeight[token][h] / (1 << 128));\n                uint256 _ethH = uint256(state.minedAtHeight[token][h] % (1 << 128));\n                uint256 _reward = uint256(_sheet.ethNum).mul(_ntokenH).div(_ethH);\n                _C_NestPool.addNToken(address(msg.sender), _ntoken, _reward);\n            }\n        }\n\n        {\n            uint256 _ethAmount = uint256(_sheet.ethNumBal).mul(1 ether);\n            uint256 _tokenAmount = uint256(_sheet.tokenNumBal).mul(_sheet.tokenAmountPerEth);\n            uint256 _nestAmount = uint256(_sheet.nestNum1k).mul(1000 * 1e18);\n            _sheet.ethNumBal = 0;\n            _sheet.tokenNumBal = 0;\n            _sheet.nestNum1k = 0;\n\n            _C_NestPool.unfreezeEthAndToken(address(msg.sender), _ethAmount, token, _tokenAmount);\n            _C_NestPool.unfreezeNest(address(msg.sender), _nestAmount); \n            _C_NestPool.withdrawEthAndToken(address(msg.sender), _ethAmount, token, _tokenAmount);\n            _C_NestPool.withdrawNest(address(msg.sender), _nestAmount);\n        }\n\n        /*  \n        - Issue #23: \n            Uncomment the following code to support withdrawing ethers cached \n        {\n            uint256 _ethAmount = _C_NestPool.balanceOfEthInPool(address(msg.sender));\n            if (_ethAmount > 0) {\n                _C_NestPool.withdrawEth(address(msg.sender), _ethAmount);\n            }\n        }\n        */\n\n        _sheet.state = MiningV1Data.PRICESHEET_STATE_CLOSED;\n\n        state.priceSheetList[token][index] = _sheet;\n\n        emit MiningV1Data.PriceClosed(address(msg.sender), token, index);    \n    }\n\n    /// @notice Close a batch of price sheets passed VERIFICATION-PHASE\n    /// @dev Empty sheets but in VERIFICATION-PHASE aren't allowed\n    /// @param token The address of TOKEN contract\n    /// @param indices A list of indices of sheets w.r.t. `token`\n    function _closeList(\n            MiningV1Data.State storage state, \n            address token, \n            uint32[] memory indices) \n        external \n    {\n        uint256 _ethAmount;\n        uint256 _tokenAmount;\n        uint256 _nestAmount;\n        uint256 _reward;\n\n        // load storage point to the list of price sheets\n        MiningV1Data.PriceSheet[] storage prices = state.priceSheetList[token];\n        \n        // loop\n        for (uint i=0; i> 128);\n                    uint256 _ethH = uint256(state.minedAtHeight[token][h] << 128 >> 128);\n                    _reward = _reward.add(uint256(_sheet.ethNum).mul(_ntokenH).div(_ethH));\n                }\n                emit MiningV1Data.PriceClosed(address(msg.sender), token, indices[i]);\n            }\n        }\n        \n        // load address of NestPool (for gas saving)\n        INestPool _C_NestPool = INestPool(state.C_NestPool);\n\n        // unfreeze assets\n        if (_ethAmount > 0 || _tokenAmount > 0) {\n            _C_NestPool.unfreezeEthAndToken(address(msg.sender), _ethAmount, token, _tokenAmount);\n        }\n        _C_NestPool.unfreezeNest(address(msg.sender), _nestAmount); \n\n        // distribute the rewards\n        {\n            uint256 _typ = prices[indices[0]].typ;\n            if  (_typ == MiningV1Data.PRICESHEET_TYPE_USD) {\n                _C_NestPool.addNest(address(msg.sender), _reward);\n            } else if (_typ == MiningV1Data.PRICESHEET_TYPE_TOKEN) {\n                address _ntoken = _C_NestPool.getNTokenFromToken(token);\n                _C_NestPool.addNToken(address(msg.sender), _ntoken, _reward);\n            }\n        }\n    }\n\n    /*\n    /// @dev This function is only for post dual-price-sheet before upgrading without assets\n    function _post2Only4Upgrade(\n            MiningV1Data.State storage state,\n            address token,\n            uint256 ethNum,\n            uint256 tokenAmountPerEth,\n            uint256 ntokenAmountPerEth\n        )\n        external \n    {\n        // check parameters \n        require(ethNum == state.miningEthUnit, \"Nest:Mine:!(ethNum)\");\n        require(tokenAmountPerEth > 0 && ntokenAmountPerEth > 0, \"Nest:Mine:!(price)\");\n        address _ntoken = INestPool(state.C_NestPool).getNTokenFromToken(token);\n\n        // no eth fee, no freezing\n\n        // push sheets\n        {\n            uint8 typ1;\n            uint8 typ2; \n            if (_ntoken == address(state.C_NestToken)) {\n                typ1 = MiningV1Data.PRICESHEET_TYPE_USD;\n                typ2 = MiningV1Data.PRICESHEET_TYPE_NEST;\n            } else {\n                typ1 = MiningV1Data.PRICESHEET_TYPE_TOKEN;\n                typ2 = MiningV1Data.PRICESHEET_TYPE_NTOKEN;\n            }\n            MiningV1Data.PriceSheet[] storage _sheetToken = state.priceSheetList[token];\n            // append a new price sheet\n            _sheetToken.push(MiningV1Data.PriceSheet(\n                uint160(msg.sender),            // miner \n                uint32(block.number),           // atHeight\n                uint32(ethNum),                 // ethNum\n                uint32(ethNum),                 // remainNum\n                uint8(0),                       // level\n                uint8(typ1),     // typ\n                uint8(MiningV1Data.PRICESHEET_STATE_CLOSED), // state \n                uint8(0),                       // _reserved\n                uint32(ethNum),                 // ethNumBal\n                uint32(ethNum),                 // tokenNumBal\n                uint32(state.nestStakedNum1k),        // nestNum1k\n                uint128(tokenAmountPerEth)      // tokenAmountPerEth\n            ));\n\n            MiningV1Data.PriceSheet[] storage _sheetNToken = state.priceSheetList[_ntoken];\n            // append a new price sheet for ntoken\n            _sheetNToken.push(MiningV1Data.PriceSheet(\n                uint160(msg.sender),            // miner \n                uint32(block.number),           // atHeight\n                uint32(ethNum),                 // ethNum\n                uint32(ethNum),                 // remainNum\n                uint8(0),                       // level\n                uint8(typ2),     // typ\n                uint8(MiningV1Data.PRICESHEET_STATE_CLOSED), // state \n                uint8(0),                       // _reserved\n                uint32(ethNum),                 // ethNumBal\n                uint32(ethNum),                 // tokenNumBal\n                uint32(state.nestStakedNum1k),        // nestNum1k\n                uint128(ntokenAmountPerEth)      // tokenAmountPerEth\n            ));\n            emit MiningV1Data.PricePosted(msg.sender, token, (_sheetToken.length - 1), ethNum.mul(1 ether), tokenAmountPerEth.mul(ethNum)); \n            emit MiningV1Data.PricePosted(msg.sender, _ntoken, (_sheetNToken.length - 1), ethNum.mul(1 ether), ntokenAmountPerEth.mul(ethNum)); \n        }\n\n        // no mining\n\n        return; \n    }\n    */\n\n}"
    },
    "contracts/lib/ABDKMath64x64.sol": {
      "content": "// SPDX-License-Identifier: Copyright © 2019 by ABDK Consulting\n\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov \n */\npragma solidity 0.6.12;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /**\n   * @dev Minimum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /**\n   * @dev Maximum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromInt (int256 x) internal pure returns (int128) {\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n    return int128 (x << 64);\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n   * rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n  function toInt (int128 x) internal pure returns (int64) {\n    return int64 (x >> 64);\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromUInt (uint256 x) internal pure returns (int128) {\n    require (x <= 0x7FFFFFFFFFFFFFFF);\n    return int128 (x << 64);\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n   * number rounding down.  Revert on underflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n  function toUInt (int128 x) internal pure returns (uint64) {\n    require (x >= 0);\n    return uint64 (x >> 64);\n  }\n\n  /**\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n   * number rounding down.  Revert on overflow.\n   *\n   * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function from128x128 (int256 x) internal pure returns (int128) {\n    int256 result = x >> 64;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n   * number.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n  function to128x128 (int128 x) internal pure returns (int256) {\n    return int256 (x) << 64;\n  }\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add (int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) + y;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate x - y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sub (int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) - y;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate x * y rounding down.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function mul (int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) * y >> 64;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n   * number and y is signed 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n  function muli (int128 x, int256 y) internal pure returns (int256) {\n    if (x == MIN_64x64) {\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n        y <= 0x1000000000000000000000000000000000000000000000000);\n      return -y << 63;\n    } else {\n      bool negativeResult = false;\n      if (x < 0) {\n        x = -x;\n        negativeResult = true;\n      }\n      if (y < 0) {\n        y = -y; // We rely on overflow behavior here\n        negativeResult = !negativeResult;\n      }\n      uint256 absoluteResult = mulu (x, uint256 (y));\n      if (negativeResult) {\n        require (absoluteResult <=\n          0x8000000000000000000000000000000000000000000000000000000000000000);\n        return -int256 (absoluteResult); // We rely on overflow behavior here\n      } else {\n        require (absoluteResult <=\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int256 (absoluteResult);\n      }\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    if (y == 0) return 0;\n\n    require (x >= 0);\n\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n    uint256 hi = uint256 (x) * (y >> 128);\n\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n    hi <<= 64;\n\n    require (hi <=\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n    return hi + lo;\n  }\n\n  /**\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function div (int128 x, int128 y) internal pure returns (int128) {\n    require (y != 0);\n    int256 result = (int256 (x) << 64) / y;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divi (int256 x, int256 y) internal pure returns (int128) {\n    require (y != 0);\n\n    bool negativeResult = false;\n    if (x < 0) {\n      x = -x; // We rely on overflow behavior here\n      negativeResult = true;\n    }\n    if (y < 0) {\n      y = -y; // We rely on overflow behavior here\n      negativeResult = !negativeResult;\n    }\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n    if (negativeResult) {\n      require (absoluteResult <= 0x80000000000000000000000000000000);\n      return -int128 (absoluteResult); // We rely on overflow behavior here\n    } else {\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return int128 (absoluteResult); // We rely on overflow behavior here\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\n    require (y != 0);\n    uint128 result = divuu (x, y);\n    require (result <= uint128 (MAX_64x64));\n    return int128 (result);\n  }\n\n  /**\n   * Calculate -x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function neg (int128 x) internal pure returns (int128) {\n    require (x != MIN_64x64);\n    return -x;\n  }\n\n  /**\n   * Calculate |x|.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function abs (int128 x) internal pure returns (int128) {\n    require (x != MIN_64x64);\n    return x < 0 ? -x : x;\n  }\n\n  /**\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function inv (int128 x) internal pure returns (int128) {\n    require (x != 0);\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function avg (int128 x, int128 y) internal pure returns (int128) {\n    return int128 ((int256 (x) + int256 (y)) >> 1);\n  }\n\n  /**\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n   * Revert on overflow or in case x * y is negative.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\n    int256 m = int256 (x) * int256 (y);\n    require (m >= 0);\n    require (m > 1));\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\n    uint256 absoluteResult;\n    bool negativeResult = false;\n    if (x >= 0) {\n      absoluteResult = powu (uint256 (x) << 63, y);\n    } else {\n      // We rely on overflow behavior here\n      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\n      negativeResult = y & 1 > 0;\n    }\n\n    absoluteResult >>= 63;\n\n    if (negativeResult) {\n      require (absoluteResult <= 0x80000000000000000000000000000000);\n      return -int128 (absoluteResult); // We rely on overflow behavior here\n    } else {\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return int128 (absoluteResult); // We rely on overflow behavior here\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sqrt (int128 x) internal pure returns (int128) {\n    require (x >= 0);\n    return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function log_2 (int128 x) internal pure returns (int128) {\n    require (x > 0);\n\n    int256 msb = 0;\n    int256 xc = x;\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n    int256 result = msb - 64 << 64;\n    uint256 ux = uint256 (x) << 127 - msb;\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n      ux *= ux;\n      uint256 b = ux >> 255;\n      ux >>= 127 + b;\n      result += bit * int256 (b);\n    }\n\n    return int128 (result);\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function ln (int128 x) internal pure returns (int128) {\n    require (x > 0);\n\n    return int128 (\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\n  }\n\n  /**\n   * Calculate binary exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp_2 (int128 x) internal pure returns (int128) {\n    require (x < 0x400000000000000000); // Overflow\n\n    if (x < -0x400000000000000000) return 0; // Underflow\n\n    uint256 result = 0x80000000000000000000000000000000;\n\n    if (x & 0x8000000000000000 > 0)\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n    if (x & 0x4000000000000000 > 0)\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n    if (x & 0x2000000000000000 > 0)\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n    if (x & 0x1000000000000000 > 0)\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n    if (x & 0x800000000000000 > 0)\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n    if (x & 0x400000000000000 > 0)\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n    if (x & 0x200000000000000 > 0)\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n    if (x & 0x100000000000000 > 0)\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n    if (x & 0x80000000000000 > 0)\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n    if (x & 0x40000000000000 > 0)\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n    if (x & 0x20000000000000 > 0)\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n    if (x & 0x10000000000000 > 0)\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n    if (x & 0x8000000000000 > 0)\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n    if (x & 0x4000000000000 > 0)\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n    if (x & 0x2000000000000 > 0)\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n    if (x & 0x1000000000000 > 0)\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n    if (x & 0x800000000000 > 0)\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n    if (x & 0x400000000000 > 0)\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n    if (x & 0x200000000000 > 0)\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n    if (x & 0x100000000000 > 0)\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n    if (x & 0x80000000000 > 0)\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n    if (x & 0x40000000000 > 0)\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n    if (x & 0x20000000000 > 0)\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n    if (x & 0x10000000000 > 0)\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n    if (x & 0x8000000000 > 0)\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n    if (x & 0x4000000000 > 0)\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n    if (x & 0x2000000000 > 0)\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n    if (x & 0x1000000000 > 0)\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n    if (x & 0x800000000 > 0)\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n    if (x & 0x400000000 > 0)\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n    if (x & 0x200000000 > 0)\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n    if (x & 0x100000000 > 0)\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n    if (x & 0x80000000 > 0)\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n    if (x & 0x40000000 > 0)\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n    if (x & 0x20000000 > 0)\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n    if (x & 0x10000000 > 0)\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n    if (x & 0x8000000 > 0)\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n    if (x & 0x4000000 > 0)\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n    if (x & 0x2000000 > 0)\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n    if (x & 0x1000000 > 0)\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n    if (x & 0x800000 > 0)\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n    if (x & 0x400000 > 0)\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n    if (x & 0x200000 > 0)\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n    if (x & 0x100000 > 0)\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n    if (x & 0x80000 > 0)\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n    if (x & 0x40000 > 0)\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n    if (x & 0x20000 > 0)\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n    if (x & 0x10000 > 0)\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n    if (x & 0x8000 > 0)\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n    if (x & 0x4000 > 0)\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n    if (x & 0x2000 > 0)\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n    if (x & 0x1000 > 0)\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n    if (x & 0x800 > 0)\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n    if (x & 0x400 > 0)\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n    if (x & 0x200 > 0)\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n    if (x & 0x100 > 0)\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n    if (x & 0x80 > 0)\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n    if (x & 0x40 > 0)\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n    if (x & 0x20 > 0)\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n    if (x & 0x10 > 0)\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n    if (x & 0x8 > 0)\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n    if (x & 0x4 > 0)\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n    if (x & 0x2 > 0)\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n    if (x & 0x1 > 0)\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n\n    result >>= 63 - (x >> 64);\n    require (result <= uint256 (MAX_64x64));\n\n    return int128 (result);\n  }\n\n  /**\n   * Calculate natural exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp (int128 x) internal pure returns (int128) {\n    require (x < 0x400000000000000000); // Overflow\n\n    if (x < -0x400000000000000000) return 0; // Underflow\n\n    return exp_2 (\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n    require (y != 0);\n\n    uint256 result;\n\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n      result = (x << 64) / y;\n    else {\n      uint256 msb = 192;\n      uint256 xc = x >> 192;\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n      uint256 hi = result * (y >> 128);\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n      uint256 xh = x >> 192;\n      uint256 xl = x << 64;\n\n      if (xl < lo) xh -= 1;\n      xl -= lo; // We rely on overflow behavior here\n      lo = hi << 128;\n      if (xl < lo) xh -= 1;\n      xl -= lo; // We rely on overflow behavior here\n\n      assert (xh == hi >> 128);\n\n      result += xl / y;\n    }\n\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n    return uint128 (result);\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x unsigned 129.127-bit fixed point number\n   * @param y uint256 value\n   * @return unsigned 129.127-bit fixed point number\n   */\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\n    if (y == 0) return 0x80000000000000000000000000000000;\n    else if (x == 0) return 0;\n    else {\n      int256 msb = 0;\n      uint256 xc = x;\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      int256 xe = msb - 127;\n      if (xe > 0) x >>= xe;\n      else x <<= -xe;\n\n      uint256 result = 0x80000000000000000000000000000000;\n      int256 re = 0;\n\n      while (y > 0) {\n        if (y & 1 > 0) {\n          result = result * x;\n          y -= 1;\n          re += xe;\n          if (result >=\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\n            result >>= 128;\n            re += 1;\n          } else result >>= 127;\n          if (re < -127) return 0; // Underflow\n          require (re < 128); // Overflow\n        } else {\n          x = x * x;\n          y >>= 1;\n          xe <<= 1;\n          if (x >=\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\n            x >>= 128;\n            xe += 1;\n          } else x >>= 127;\n          if (xe < -127) return 0; // Underflow\n          require (xe < 128); // Overflow\n        }\n      }\n\n      if (re > 0) result <<= re;\n      else if (re < 0) result >>= -re;\n\n      return result;\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n   * number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\n    if (x == 0) return 0;\n    else {\n      require (r > 0);\n      while (true) {\n        uint256 rr = x / r;\n        if (r == rr || r + 1 == rr) return uint128 (r);\n        else if (r == rr + 1) return uint128 (rr);\n        r = r + rr + 1 >> 1;\n      }\n    }\n  }\n}"
    },
    "contracts/iface/INTokenLegacy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\ninterface INTokenLegacy {\n    function increaseTotal(uint256 value) external;\n\n    // the block height where the ntoken was created\n    function checkBlockInfo() external view returns(uint256 createBlock, uint256 recentlyUsedBlock);\n    // the owner (auction winner) of the ntoken\n    function checkBidder() external view returns(address);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/NestDAO.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/TransferHelper.sol\";\nimport \"./lib/ReentrancyGuard.sol\";\n\n\nimport \"./iface/INestMining.sol\";\nimport \"./iface/INToken.sol\";\nimport \"./iface/INestPool.sol\";\nimport \"./iface/INestDAO.sol\";\nimport \"./iface/INestStaking.sol\";\nimport \"./iface/INestQuery.sol\";\n\n// import \"hardhat/console.sol\";\n\n/// @dev The contract is for redeeming nest token and getting ETH in return\ncontract NestDAO is INestDAO, ReentrancyGuard {\n\n    using SafeMath for uint256;\n\n    /* ========== STATE ============== */\n\n    uint8 public flag; \n\n    /// @dev the block height where DAO was started\n    uint32  public startedBlock;\n    uint32  public lastCollectingBlock;\n    uint184 private _reserved;\n\n    uint8 constant DAO_FLAG_UNINITIALIZED    = 0;\n    uint8 constant DAO_FLAG_INITIALIZED      = 1;\n    uint8 constant DAO_FLAG_ACTIVE           = 2;\n    uint8 constant DAO_FLAG_NO_STAKING       = 3;\n    uint8 constant DAO_FLAG_PAUSED           = 4;\n    uint8 constant DAO_FLAG_SHUTDOWN         = 127;\n\n    struct Ledger {\n        uint128 rewardedAmount;\n        uint128 redeemedAmount;\n        uint128 quotaAmount;\n        uint32  lastBlock;\n        uint96  _reserved;\n    }\n\n    /// @dev Mapping from ntoken => amount (of ntokens owned by DAO)\n    mapping(address => Ledger) public ntokenLedger;\n\n    /// @dev Mapping from ntoken => amount (of ethers owned by DAO)\n    mapping(address => uint256) public ethLedger;\n\n    /* ========== PARAMETERS ============== */\n\n    uint256 public ntokenRepurchaseThreshold;\n    uint256 public collectInterval;\n\n    uint256 constant DAO_REPURCHASE_PRICE_DEVIATION = 5;  // price deviation < 5% \n    uint256 constant DAO_REPURCHASE_NTOKEN_TOTALSUPPLY = 5_000_000;  // total supply > 5 million \n\n    uint256 constant DAO_COLLECT_INTERVAL = 5_760;  // 24 hour * 60 min * 4 block/min ~= 1 day\n\n    uint256 constant _ethFee = 0.01 ether;\n\n    /* ========== ADDRESSES ============== */\n\n    address public governance;\n\n    address private C_NestPool;\n    address private C_NestToken;\n    address private C_NestMining;\n    address private C_NestStaking;\n    address private C_NestQuery;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    receive() external payable {}\n\n    // NOTE: to support open-zeppelin/upgrades, leave it blank\n    constructor() public { }\n\n    /// @dev It is called by the proxy (open-zeppelin/upgrades), only ONCE!\n    function initialize(address NestPool) external \n    {\n        require(flag == DAO_FLAG_UNINITIALIZED, \"Nest:DAO:!flag\");\n        governance = msg.sender;\n        flag = DAO_FLAG_INITIALIZED;\n        C_NestPool = NestPool;\n        ntokenRepurchaseThreshold = DAO_REPURCHASE_NTOKEN_TOTALSUPPLY;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyGovernance() \n    {\n        require(msg.sender == governance, \"Nest:DAO:!governance\");\n        _;\n    }\n\n    modifier onlyGovOrBy(address _contract) \n    {\n        require(msg.sender == governance || msg.sender == _contract, \"Nest:DAO:!sender\");\n        _;\n    }\n\n    modifier whenActive() \n    {\n        require(flag == DAO_FLAG_ACTIVE, \"Nest:DAO:!flag\");\n        _;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    /// @dev Ensure that all governance-addresses be consistent with each other\n    function loadGovernance() override external \n    { \n        governance = INestPool(C_NestPool).governance();\n    }\n\n    /// @dev The function loads all nest-contracts, it is supposed to be called by NestPool\n    function loadContracts() override external onlyGovOrBy(C_NestPool)\n    {\n        C_NestToken = INestPool(C_NestPool).addrOfNestToken();\n        C_NestStaking = INestPool(C_NestPool).addrOfNestStaking();\n        C_NestQuery = INestPool(C_NestPool).addrOfNestQuery();\n        C_NestMining = INestPool(C_NestPool).addrOfNestMining();\n    }\n\n    function start() override external onlyGovernance\n    {  \n        require(flag == DAO_FLAG_INITIALIZED, \"Nest:DAO:!flag\");\n        ERC20(C_NestToken).approve(C_NestStaking, uint(-1));\n        startedBlock = uint32(block.number);\n        lastCollectingBlock = uint32(block.number);\n        flag = DAO_FLAG_ACTIVE;\n        collectInterval = DAO_COLLECT_INTERVAL;\n        emit FlagSet(address(msg.sender), uint256(DAO_FLAG_ACTIVE));\n    }\n\n    /// @dev Stop service for emergency\n    function pause() external onlyGovernance\n    {\n        require(flag == DAO_FLAG_ACTIVE, \"Nest:DAO:!flag\");\n        flag = DAO_FLAG_PAUSED;\n        emit FlagSet(address(msg.sender), uint256(DAO_FLAG_PAUSED));\n    }\n\n    /// @dev Resume service \n    function resume() external onlyGovernance\n    {\n        require(flag == DAO_FLAG_ACTIVE || flag == DAO_FLAG_PAUSED, \"Nest:DAO:!flag\");\n        flag = DAO_FLAG_ACTIVE;\n        emit FlagSet(address(msg.sender), uint256(DAO_FLAG_ACTIVE));\n    }\n\n    function setParams(uint256 _ntokenRepurchaseThreshold, uint256 _collectInterval) external onlyGovernance\n    {\n        emit ParamsSetup(address(msg.sender), ntokenRepurchaseThreshold, _ntokenRepurchaseThreshold);\n        ntokenRepurchaseThreshold = _ntokenRepurchaseThreshold;\n        emit ParamsSetup(address(msg.sender), collectInterval, _collectInterval);\n        collectInterval = _collectInterval;\n    }\n\n    function totalETHRewards(address ntoken)\n        external view returns (uint256) \n    {\n       return  ethLedger[ntoken];\n    }\n\n    /// @notice Migrate ethers to a new NestDAO\n    /// @param newDAO_ The address of the new contract\n    /// @param ntokenL_ The list of ntokens whose ethers are going to be migrated\n    function migrateTo(address newDAO_, address[] memory ntokenL_) external onlyGovernance\n    {\n        require(flag == DAO_FLAG_PAUSED, \"Nest:DAO:!flag\");\n        uint256 _len = ntokenL_.length;\n        for (uint256 i; i < _len; i++) {\n            address _ntoken = ntokenL_[i];\n            uint256 _blncs = ethLedger[_ntoken];\n\n            INestDAO(newDAO_).addETHReward{value:_blncs}(_ntoken);\n            \n            ethLedger[_ntoken] = 0;\n\n            uint256 _staked = INestStaking(C_NestStaking).stakedBalanceOf(_ntoken, address(this));\n            if (_staked > 0) {\n                INestStaking(C_NestStaking).unstake(_ntoken, _staked);\n            }\n\n            uint256 _ntokenAmount = ERC20(_ntoken).balanceOf(address(this));\n\n            if (_ntokenAmount > 0) {\n                ERC20(_ntoken).transfer(newDAO_, _ntokenAmount);\n\n            }\n        }\n    }\n\n    /// @dev The function shall be called when ethers are taken from Nestv3.0\n    function initEthLedger(address ntoken, uint256 amount) \n        override external\n        onlyGovernance \n    {\n        require (flag == DAO_FLAG_INITIALIZED, \"Nest:DAO:!flag\");\n        ethLedger[ntoken] = amount;\n\n    }\n\n    /* ========== MAIN ========== */\n\n    /// @notice Pump eth rewards to NestDAO for repurchasing `ntoken`\n    /// @param ntoken The address of ntoken in the ether Ledger\n    function addETHReward(address ntoken) \n        override\n        external\n        payable\n    {\n        ethLedger[ntoken] = ethLedger[ntoken].add(msg.value);\n    }\n\n    /// @dev Called by NestMining\n    function addNestReward(uint256 amount) \n        override \n        external \n        onlyGovOrBy(C_NestMining)\n    {\n        Ledger storage it = ntokenLedger[C_NestToken];\n        it.rewardedAmount = uint128(uint256(it.rewardedAmount).add(amount));\n    }\n\n    /// @dev Collect ethers from NestPool\n    function collectNestReward() public returns(uint256)\n    {\n        // withdraw NEST from NestPool (mined by miners)\n        uint256 nestAmount = INestPool(C_NestPool).balanceOfTokenInPool(address(this), C_NestToken);\n        if (nestAmount == 0) {\n            return 0;\n        }\n\n        INestPool(C_NestPool).withdrawNest(address(this), nestAmount);\n\n        return nestAmount;\n    }\n\n\n    /// @dev Collect ethers from NestStaking\n    function collectETHReward(address ntoken) public returns (uint256)\n    {\n        // check if ntoken is a NTOKEN\n        address _ntoken = INestPool(C_NestPool).getNTokenFromToken(ntoken);\n        require (_ntoken == ntoken, \"Nest:DAO:!ntoken\");\n\n        uint256 ntokenAmount = ERC20(ntoken).balanceOf(address(this));\n\n        // if (ntokenAmount == 0) {\n        //     return 0;\n        // }\n        // // stake new NEST/NTOKENs into StakingPool\n        // INestStaking(C_NestStaking).stake(ntoken, ntokenAmount);\n\n        if (ntokenAmount != 0) {\n            // stake new NEST/NTOKENs into StakingPool\n            INestStaking(C_NestStaking).stake(ntoken, ntokenAmount);\n        }\n\n        // claim rewards from StakingPool \n        uint256 _rewards = INestStaking(C_NestStaking).claim(ntoken);\n        ethLedger[ntoken] = ethLedger[ntoken].add(_rewards);\n\n        return _rewards;\n    }\n\n    function _collect(address ntoken) internal\n    {\n        if (block.number < uint256(lastCollectingBlock).add(collectInterval)) {\n            return;\n        }\n\n        uint256 ethAmount = collectETHReward(ntoken);\n        \n        uint256 nestAmount = collectNestReward();\n        \n        lastCollectingBlock = uint32(block.number);\n        emit AssetsCollected(address(msg.sender), ethAmount, nestAmount);\n    }\n\n    /// @dev Redeem ntokens for ethers\n    function redeem(address ntoken, uint256 amount) \n        external payable nonReentrant whenActive\n    {\n        // check if ntoken is a NTOKEN\n        address _ntoken = INestPool(C_NestPool).getNTokenFromToken(ntoken);\n        require (_ntoken == ntoken, \"Nest:DAO:!ntoken\");\n\n        require (msg.value >= _ethFee, \"Nest:DAO:!ethFee\");\n\n        require(INToken(ntoken).totalSupply() >= ntokenRepurchaseThreshold, \"Nest:DAO:!total\");\n\n        // check if there is sufficient ethers for repurchase\n        uint256 bal = ethLedger[ntoken];\n        require(bal > 0, \"Nest:DAO:!bal\");\n\n        // check the repurchasing quota\n        uint256 quota = quotaOf(ntoken);\n\n        // check if the price is steady\n        uint256 price;\n        bool isDeviated;\n        \n        \n        {\n            (uint256 ethAmount, uint256 tokenAmount,) = INestMining(C_NestMining).latestPriceOf(ntoken);\n            (, uint256 avg, ,) = INestMining(C_NestMining).priceAvgAndSigmaOf(ntoken);\n            price = tokenAmount.mul(1e18).div(ethAmount);\n\n            uint256 diff = price > avg? (price - avg) : (avg - price);\n            isDeviated = (diff.mul(100) < avg.mul(DAO_REPURCHASE_PRICE_DEVIATION))? false : true;\n\n            if(msg.value > _ethFee){\n                TransferHelper.safeTransferETH(msg.sender, msg.value.sub(_ethFee));\n            }\n            this.addETHReward{value:_ethFee}(address(ntoken));\n\n        }\n\n        require(isDeviated == false, \"Nest:DAO:!price\");\n\n        // check if there is sufficient quota for repurchase\n        require (amount <= quota, \"Nest:DAO:!quota\");\n        // amount.mul(1e18).div(price) < bal\n        require (amount.mul(1e18) <= bal.mul(price), \"Nest:DAO:!bal2\");\n\n        // update the ledger\n        Ledger memory it = ntokenLedger[ntoken];\n\n        it.redeemedAmount = uint128(amount.add(it.redeemedAmount));\n        it.quotaAmount = uint128(quota.sub(amount));\n        it.lastBlock = uint32(block.number);\n        ntokenLedger[ntoken] = it;\n\n        // transactions\n        ethLedger[ntoken] = ethLedger[ntoken].sub(amount.mul(1e18).div(price));\n\n        ERC20(ntoken).transferFrom(address(msg.sender), address(this), amount);\n        TransferHelper.safeTransferETH(msg.sender, amount.mul(1e18).div(price));\n\n        _collect(ntoken); \n    }\n\n    // function _price(address ntoken) internal view \n    //     returns (uint256 price, uint256 avg, bool isDeviated)\n    // {\n    //     (price, avg, , ) = \n    //         INestQuery(C_NestQuery).queryPriceAvgVola(ntoken, );\n    //     uint256 diff = price > avg? (price - avg) : (avg - price);\n    //     isDeviated = (diff.mul(100) < avg.mul(DAO_REPURCHASE_PRICE_DEVIATION))? false : true;\n    // }\n\n    function _quota(address ntoken) internal view returns (uint256 quota) \n    {\n        if (INToken(ntoken).totalSupply() < ntokenRepurchaseThreshold) {\n            return 0;\n        }\n\n        //  calculate the accumulated amount of NEST/NTOKEN available to repurchasing\n        Ledger memory it = ntokenLedger[ntoken];\n        uint256 _acc;\n        uint256 n;\n        if(ntoken == C_NestToken){\n             n = 1000;\n            uint256 intv = (it.lastBlock == 0) ? \n                (block.number).sub(startedBlock) : (block.number).sub(uint256(it.lastBlock));\n            _acc = (n * intv > 300_000)? 300_000 : (n * intv);\n        }else{\n            n = 10;\n            uint256 intv = (it.lastBlock == 0) ? \n                (block.number).sub(startedBlock) : (block.number).sub(uint256(it.lastBlock));\n            _acc = (n * intv > 3000)? 3000 : (n * intv);\n        }\n\n        uint256 total;\n         total = _acc.mul(1e18).add(it.quotaAmount);\n        if(ntoken == C_NestToken){\n            if(total > uint256(300_000).mul(1e18)){\n                quota = uint256(300_000).mul(1e18);\n            }else{\n                quota = total;\n            }   \n        }else{\n            if(total > uint256(3000).mul(1e18)){\n                quota = uint256(3000).mul(1e18);\n            }else{\n                quota = total;\n            }   \n        }\n        \n    }\n\n    /* ========== VIEWS ========== */\n\n    function quotaOf(address ntoken) public view returns (uint256 quota) \n    {\n       // check if ntoken is a NTOKEN\n        address _ntoken = INestPool(C_NestPool).getNTokenFromToken(ntoken);\n        require (_ntoken == ntoken, \"Nest:DAO:!ntoken\");\n\n        return _quota(ntoken);\n    }\n}"
    },
    "contracts/test/DeFiMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport \"../iface/INestQuery.sol\";\n\ncontract DeFiMock {\n\n    INestQuery _NestQuery;\n\n    struct PriceInfo {\n        address token;\n        uint256 atHeight;\n        uint256 ethAmount;\n        uint256 tokenAmount;\n    }\n    PriceInfo[] public prices;\n\n    constructor(address Oracle) public {\n        _NestQuery = INestQuery(Oracle);\n    }\n\n    function simu() public {\n        return;\n    }\n\n    function query(address token) payable public {\n        (uint256 ethAmount, uint256 tokenAmount, uint256 bn) = _NestQuery.query{value:msg.value}(token, msg.sender);\n        prices.push(PriceInfo(token, bn, ethAmount, tokenAmount));\n    }\n\n    // function queryOracle(address token) payable public {\n    //     uint128[] memory data = _NestOracle.queryPriceList{value:msg.value}(token, uint8(4), msg.sender);\n    //     for (uint256 i=0; i uint256) private _balances;                                 //  账本\n    mapping (address => mapping (address => uint256)) private _allowed;             //  授权账本\n    uint256 private _totalSupply = 1e9 ether;                                       //  总量\n    string public name;                                                             //  名称\n    string public symbol;                                                           //  简称\n    uint8 public decimals = 18;                                                     //  精度\n    uint256 public _createBlock;                                                    //  创建区块\n    uint256 public _recentlyUsedBlock;                                              //  最近使用区块\n    address _voteFactory;                                                           //  投票合约\n    // Nest_3_VoteFactory _voteFactory;                                                //  投票合约\n    address _bidder;                                                                //  拥有者\n    address offerMain;\n\n    constructor (uint256 total, string memory _name, string memory _symbol, address bidder) public \n    {\n        _totalSupply = total;\n        _bidder = bidder;\n        name = _name;\n        _createBlock = block.number;\n        _recentlyUsedBlock = block.number;\n        _balances[bidder] = _totalSupply;\n    }\n\n    function setOfferMain(address _offerMain) public {\n        offerMain = _offerMain;\n    }\n\n    // constructor (string memory _name, string memory _symbol, address voteFactory, address bidder) public {\n    // \tname = _name;                                                               \n    // \tsymbol = _symbol;\n    // \t_createBlock = block.number;\n    // \t_recentlyUsedBlock = block.number;\n    // \t_voteFactory = address(voteFactory);\n    // \t// _voteFactory = Nest_3_VoteFactory(address(voteFactory));\n    // \t_bidder = bidder;\n    //     _balances[bidder] = _totalSupply;\n    // }\n    \n    /**\n    * @dev 重置投票合约方法\n    * @param voteFactory 投票合约地址\n    */\n    function changeMapping (address voteFactory) public onlyOwner {\n    \t_voteFactory = address(voteFactory);\n    \t// _voteFactory = Nest_3_VoteFactory(address(voteFactory));\n    }\n    \n    /**\n    * @dev 增发\n    * @param value 增发数量\n    */\n    function increaseTotal(uint256 value) override public {\n        // address offerMain = address(_voteFactory.checkAddress(\"nest.nToken.offerMain\"));\n        // require(address(msg.sender) == offerMain, \"No authority\");\n        _balances[offerMain] = _balances[offerMain].add(value);\n        _totalSupply = _totalSupply.add(value);\n        _recentlyUsedBlock = block.number;\n    }\n\n    // TODO: only for debugging\n    function increaseTotal2(uint256 value, address offerMain) public {\n        // address offerMain = address(_voteFactory.checkAddress(\"nest.nToken.offerMain\"));\n        // require(address(msg.sender) == offerMain, \"No authority\");\n        _balances[offerMain] = _balances[offerMain].add(value);\n        _totalSupply = _totalSupply.add(value);\n        _recentlyUsedBlock = block.number;\n    }\n\n    /**\n    * @dev 查询token总量\n    * @return token总量\n    */\n    function totalSupply() override public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n    * @dev 查询地址余额\n    * @param owner 要查询的地址\n    * @return 返回对应地址的余额\n    */\n    function balanceOf(address owner) override public view returns (uint256) {\n        return _balances[owner];\n    }\n    \n    /**\n    * @dev 查询区块信息\n    * @return createBlock 初始区块数\n    * @return recentlyUsedBlock 最近挖矿增发区块\n    */\n    function checkBlockInfo() override public view returns(uint256 createBlock, uint256 recentlyUsedBlock) {\n        return (_createBlock, _recentlyUsedBlock);\n    }\n\n    /**\n     * @dev 查询 owner 对 spender 的授权额度\n     * @param owner 发起授权的地址\n     * @param spender 被授权的地址\n     * @return 已授权的金额\n     */\n    function allowance(address owner, address spender) override public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n    * @dev 转账方法\n    * @param to 转账目标\n    * @param value 转账金额\n    * @return 转账是否成功\n    */\n    function transfer(address to, uint256 value) override public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev 授权方法\n     * @param spender 授权目标\n     * @param value 授权数量\n     * @return 授权是否成功\n     */\n    function approve(address spender, uint256 value) override public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev 已授权状态下，从 from地址转账到to地址\n     * @param from 转出的账户地址 \n     * @param to 转入的账户地址\n     * @param value 转账金额\n     * @return 授权转账是否成功\n     */\n    function transferFrom(address from, address to, uint256 value) override public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    /**\n     * @dev 增加授权额度\n     * @param spender 授权目标\n     * @param addedValue 增加的额度\n     * @return 增加授权额度是否成功\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev 减少授权额度\n     * @param spender 授权目标\n     * @param subtractedValue 减少的额度\n     * @return 减少授权额度是否成功\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n    * @dev 转账方法\n    * @param to 转账目标\n    * @param value 转账金额\n    */\n    function _transfer(address from, address to, uint256 value) internal {\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n    \n    /**\n    * @dev 查询创建者\n    * @return 创建者地址\n    */\n    function checkBidder() override public view returns(address) {\n        return _bidder;\n    }\n    \n    /**\n    * @dev 转让创建者\n    * @param bidder 新创建者地址\n    */\n    function changeBidder(address bidder) public {\n        require(address(msg.sender) == _bidder);\n        _bidder = bidder; \n    }\n    \n    // 仅限管理员操作\n    modifier onlyOwner(){\n        // require(_voteFactory.checkOwners(msg.sender));\n        _;\n    }\n}"
    },
    "contracts/legacy/SuperMan.sol": {
      "content": "pragma solidity 0.6.12;\n\nimport \"../lib/SafeMath.sol\";\nimport \"../iface/INNRewardPool.sol\";\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract SuperMan is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n    \n    IBMapping mappingContract;  //映射合约\n\n    uint256 private _totalSupply = 1500;\n    string public name = \"NestNode\";\n    string public symbol = \"NN\";\n    uint8 public decimals = 0;\n\n    constructor (address map) public {\n    \t_balances[msg.sender] = _totalSupply;\n    \tmappingContract = IBMapping(map); \n    }\n    \n    function changeMapping(address map) public onlyOwner{\n        mappingContract = IBMapping(map);\n    }\n    \n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() override public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address owner) override public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) override public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function transfer(address to, uint256 value) override public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) override public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) override public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        \n        INNRewardPool nodeAssignment = INNRewardPool(address(mappingContract.checkAddress(\"nodeAssignment\")));\n        nodeAssignment.nodeCount(from, to);\n        \n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n        \n        \n    }\n    \n    //  仅限管理员\n    modifier onlyOwner(){\n        require(mappingContract.checkOwners(msg.sender) == true);\n        _;\n    }\n}\n\n//  映射合约\ncontract IBMapping {\n    mapping(string => address) _contractAddress;                    //  投票合约映射\n\n    //  查询地址\n    function checkAddress(string memory name) public view returns (address contractAddress) {\n        return _contractAddress[name];\n    }\n    \n    // //  添加合约映射地址\n    // function addContractAddress(string memory name, address contractAddress) public onlyOwner {\n    //     _contractAddress[name] = contractAddress;\n    // }\n\n\t//  查看是否管理员 //TODO: \n\tfunction checkOwners(address man) public view returns (bool) {\n        return true;\n    }\n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}
