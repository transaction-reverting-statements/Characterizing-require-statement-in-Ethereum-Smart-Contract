{"IterableMapping.sol":{"content":"pragma solidity ^0.5.8;\r\nimport \"./SafeMath.sol\";\r\nlibrary IterableMapping\r\n{\r\n    using SafeMath for uint;\r\n    struct itmap\r\n    {\r\n        mapping(uint =\u003e IndexValue) data;\r\n        KeyFlag[] keys;\r\n        uint size;\r\n    }\r\n    struct IndexValue { uint keyIndex; uint value; }\r\n    struct KeyFlag { uint key; bool deleted; }\r\n    function insert(itmap storage self, uint key, uint value) public returns (bool replaced)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        self.data[key].value = value;\r\n        if (keyIndex \u003e 0)\r\n            return true;\r\n        else\r\n        {\r\n            keyIndex = self.keys.length++;\r\n            self.data[key].keyIndex = keyIndex + 1;\r\n            self.keys[keyIndex].key = key;\r\n            self.size++;\r\n            return false;\r\n        }\r\n    }\r\n    function add_or_insert(itmap storage self, uint key, uint value) public returns (bool added)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n\r\n        if (keyIndex \u003e 0)\r\n        {\r\n            self.data[key].value = self.data[key].value.add(value);\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            self.data[key].value = value;\r\n            keyIndex = self.keys.length++;\r\n            self.data[key].keyIndex = keyIndex + 1;\r\n            self.keys[keyIndex].key = key;\r\n            self.size++;\r\n            return false;\r\n        }\r\n    }\r\n    function sub(itmap storage self, uint key, uint value) public returns (bool subbed)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n\r\n        if (keyIndex \u003e 0)\r\n        {\r\n            self.data[key].value = self.data[key].value.sub(value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function remove(itmap storage self, uint key) public returns (bool success)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        if (keyIndex == 0)\r\n            return false;\r\n        delete self.data[key];\r\n        self.keys[keyIndex - 1].deleted = true;\r\n        self.size --;\r\n    }\r\n\r\n    function clear(itmap storage self) public\r\n    {\r\n        uint len = self.keys.length;\r\n        for(uint i = 0; i\u003clen; i++)\r\n        {\r\n            if(!self.keys[i].deleted)\r\n            {\r\n                delete self.data[self.keys[i].key];\r\n            }\r\n        }\r\n        self.keys.length = 0;\r\n        self.size = 0;\r\n    }\r\n    function contains(itmap storage self, uint key) public view returns (bool)\r\n    {\r\n        return self.data[key].keyIndex \u003e 0;\r\n    }\r\n    function iterate_start(itmap storage self) public view returns (uint keyIndex)\r\n    {\r\n        return iterate_next(self, uint(-1));\r\n    }\r\n    function iterate_valid(itmap storage self, uint keyIndex) public view returns (bool)\r\n    {\r\n        return keyIndex \u003c self.keys.length;\r\n    }\r\n    function iterate_next(itmap storage self, uint keyIndex) public view returns (uint r_keyIndex)\r\n    {\r\n        keyIndex++;\r\n        while (keyIndex \u003c self.keys.length \u0026\u0026 self.keys[keyIndex].deleted)\r\n            keyIndex++;\r\n        return keyIndex;\r\n    }\r\n    function iterate_get(itmap storage self, uint keyIndex) public view returns (uint key, uint value)\r\n    {\r\n        key = self.keys[keyIndex].key;\r\n        value = self.data[key].value;\r\n    }\r\n}\r\n"},"ReentrancyGuard.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n * available, which can be aplied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"},"WeFairPlayInvestment.sol":{"content":"pragma solidity ^0.5.8;\r\nimport \"./SafeMath.sol\";\r\nimport \"./IterableMapping.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\ncontract WeFairPlayInvestment is ReentrancyGuard{\r\n    using SafeMath for uint;\r\n    using IterableMapping for IterableMapping.itmap;\r\n    modifier onlyBagholders() {\r\n        require(myTokens() \u003e 0,\u0027msg.sender should have tokens.\u0027);\r\n        _;\r\n    }\r\n    modifier onlyOwner()\r\n    {\r\n        require(owner == msg.sender,\u0027msg.sender is not owner.\u0027);\r\n        _;\r\n    }\r\n    modifier onlyAdministrator(){\r\n        require(owner == msg.sender || administrators[keccak256(abi.encodePacked(msg.sender))]\r\n            ,\u0027msg.sender is not owner or admin.\u0027);\r\n        _;\r\n    }\r\n    modifier onlyOperators(){\r\n        require(mapOperatorStocks_.contains(uint(msg.sender))\r\n        \u0026\u0026 mapOperatorStocks_.data[uint(msg.sender)].value \u003e 0,\u0027msg.sender should have stocks.\u0027);\r\n        _;\r\n    }\r\n    modifier notEarlyWhale(){\r\n        require(!onlyAmbassadors,\u0027now should not early whale stage.\u0027);\r\n        _;\r\n    }\r\n    modifier notEndStage(){\r\n        require(!isEndStage,\u0027now should not end stage.\u0027);\r\n        _;\r\n    }\r\n    modifier antiEarlyWhale(uint256 _amountOfEthereum){\r\n        if(!onlyAmbassadors)\r\n        {\r\n            _;\r\n            return;\r\n        }\r\n        address _customerAddress = msg.sender;\r\n        if( onlyAmbassadors \u0026\u0026 ((address(this).balance - originalBalance) \u003c ambassadorQuota_ )){\r\n            require(\r\n                ambassadors_[_customerAddress] == true \u0026\u0026\r\n                (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) \u003c= ambassadorMaxPurchase_\r\n                ,\u0027msg.sender is not a ambassador or has reach buy limit.\u0027\r\n            );\r\n            ambassadorAccumulatedQuota_[_customerAddress] = ambassadorAccumulatedQuota_[_customerAddress].add(_amountOfEthereum);\r\n            _;\r\n        } else {\r\n            onlyAmbassadors = false;\r\n            _;\r\n        }\r\n    }\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted\r\n    );\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned\r\n    );\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n    string public name = \"WeFairPlayCoin\";\r\n    string public symbol = \"WFP\";\r\n    uint8 constant public decimals = 18;\r\n    uint8 constant internal dividendFee_ = 20;\r\n    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\r\n    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\r\n    mapping(address =\u003e bool) internal ambassadors_;\r\n    uint256 constant internal ambassadorMaxPurchase_ = 1 ether;\r\n    uint256 constant internal ambassadorQuota_ = 10 ether;\r\n    uint originalBalance;\r\n    mapping(address =\u003e uint256) internal tokenBalanceLedger_;\r\n    mapping(address =\u003e uint256) internal ambassadorAccumulatedQuota_;\r\n    uint256 internal tokenSupply_ = 0;\r\n    IterableMapping.itmap mapOperatorRewards_;\r\n    IterableMapping.itmap mapOperatorStocks_;\r\n    uint totalOperatorRewards;\r\n    uint256 constant public totalStocks_ = 10000;\r\n    uint constant internal stockLockTime = 1 days;\r\n    struct StockTransInfo { uint stocks; uint price; uint endTime;}\r\n    mapping(address =\u003e mapping(address =\u003e StockTransInfo)) mapStockTrans;\r\n    mapping(address =\u003e uint) mapLockStocks;\r\n    uint lastActiveTime;\r\n    uint constant internal ENTER_END_DURATION = 2 * 4 weeks;//2 * 4 weeks;\r\n    bool public isEndStage;\r\n    uint public enterEndTime;\r\n    uint constant internal END_STAGE_DURATION = 4 weeks;//4 weeks;\r\n    address owner;\r\n    mapping(bytes32 =\u003e bool) public administrators;\r\n    bool public onlyAmbassadors = true;\r\n    constructor()\r\n    public\r\n    {\r\n        owner = msg.sender;\r\n        administrators[0x6e87e5c3130679f898089256718f36b117cb685debd8d2511298b3f0dabadf1e] = true;\r\n        ambassadors_[0x1Fd11576EAbe588115aA47E52904C3221E4c0a95] = true;\r\n        ambassadors_[0x1DC93b1bE8b97959f5B07d6113A909F9C89D3361] = true;\r\n        ambassadors_[0x135de610Bd907e9B6aB3d93753d6E59De6ef886B] = true;\r\n        ambassadors_[0x5f5B2BB60EBDa86C9efc9a4cA01a7756554c2Fe5] = true;\r\n        ambassadors_[0x89EE32611CcFa44044cc1F0d0ECC53E53Aa3C634] = true;\r\n        ambassadors_[0x16B0e5F320Cd30028caFf791aC08dF830B52e61d] = true;\r\n        ambassadors_[0xA9d47178067568A5C84c0849A7e1b47139DA6a7c] = true;\r\n        ambassadors_[0x0d7e1a43e666714A1B7B8F4e5eD9Ac86597078A0] = true;\r\n        ambassadors_[0xc33F6Ca865D8Ec8fE00037f64B8dbe6cBD751555] = true;\r\n        ambassadors_[0x324bC683445fa86CFc85b49c1eD4d2bdDc6409aE] = true;\r\n        mapOperatorStocks_.add_or_insert(uint(owner),totalStocks_);\r\n        originalBalance = address(this).balance;\r\n    }\r\n    function ambassadorLeftLimit()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        require(ambassadors_[msg.sender] == true,\u0027msg.sender is not a ambassador.\u0027);\r\n        return ambassadorMaxPurchase_.sub(ambassadorAccumulatedQuota_[msg.sender]);\r\n    }\r\n    function isAmbassador()\r\n    view\r\n    public\r\n    returns(bool)\r\n    {\r\n        return ambassadors_[msg.sender];\r\n    }\r\n    function buy()\r\n    public\r\n    payable\r\n    {\r\n        purchaseTokens(msg.value);\r\n    }\r\n    function()\r\n    payable\r\n    external\r\n    {\r\n        purchaseTokens(msg.value);\r\n    }\r\n    function exit()\r\n    public\r\n    {\r\n        uint256 _tokens = tokenBalanceLedger_[msg.sender];\r\n        if(_tokens \u003e 0) sell(_tokens);\r\n    }\r\n    function sell(uint256 _amountOfTokens)\r\n    nonReentrant()\r\n    notEarlyWhale()\r\n    onlyBagholders()\r\n    public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        require(_amountOfTokens \u003c= tokenBalanceLedger_[_customerAddress],\u0027seller have not enough tokens.\u0027);\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 _ethereum = tokensToEthereum_(_tokens);\r\n        uint256 _dividends = _ethereum.div(dividendFee_);\r\n        uint256 _taxedEthereum = _ethereum.sub(_dividends);\r\n        sendOperatorRewards_(_dividends);\r\n        tokenSupply_ = tokenSupply_.sub( _tokens);\r\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress].sub( _tokens);\r\n        lastActiveTime = now;\r\n        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);\r\n        msg.sender.transfer(_taxedEthereum);\r\n    }\r\n    function _transfer(address _from, address _toAddress, uint _amountOfTokens)\r\n    notEarlyWhale()\r\n    notEndStage()\r\n    internal\r\n    {\r\n        address _customerAddress = _from;\r\n        require(_amountOfTokens \u003c= tokenBalanceLedger_[_customerAddress],\u0027seller have not enough tokens.\u0027);\r\n        uint256 _tokenFee = _amountOfTokens.div(dividendFee_);\r\n        uint256 _taxedTokens = _amountOfTokens.sub(_tokenFee);\r\n        uint256 _dividends = tokensToEthereum_(_tokenFee);\r\n        tokenSupply_ = tokenSupply_.sub(_tokenFee);\r\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress].sub( _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = tokenBalanceLedger_[_toAddress].add( _taxedTokens);\r\n        sendOperatorRewards_(_dividends);\r\n        lastActiveTime = now;\r\n        emit Transfer(_customerAddress, _toAddress, _taxedTokens);\r\n    }\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n    onlyBagholders()\r\n    public\r\n    returns(bool)\r\n    {\r\n        _transfer(msg.sender, _toAddress, _amountOfTokens);\r\n        return true;\r\n    }\r\n    function isAdministrator()\r\n    view\r\n    public\r\n    returns(bool)\r\n    {\r\n        return (owner == msg.sender || administrators[keccak256(abi.encodePacked(msg.sender))]);\r\n    }\r\n    function disableInitialStage()\r\n    onlyOwner()\r\n    public\r\n    {\r\n        onlyAmbassadors = false;\r\n    }\r\n    function setAdministrator(bytes32 _identifier, bool _status)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        administrators[_identifier] = _status;\r\n    }\r\n    function setOwner(address payable newOwner) onlyOwner public\r\n    {\r\n        owner = newOwner;\r\n    }\r\n    function canEnterEndStage() view public returns(bool)\r\n    {\r\n        return (lastActiveTime \u003e 0 \u0026\u0026 now - lastActiveTime \u003e ENTER_END_DURATION);\r\n    }\r\n    function enterEndStage() onlyOwner public\r\n    {\r\n        require(lastActiveTime \u003e 0 \u0026\u0026 now - lastActiveTime \u003e ENTER_END_DURATION,\"Last transaction should be 8 weeks ago.\");\r\n        isEndStage = true;\r\n        enterEndTime = now;\r\n    }\r\n    function restEndTime() view public returns(int)\r\n    {\r\n        if(isEndStage \u0026\u0026 enterEndTime \u003e 0)\r\n        {\r\n            uint endTimestamp = enterEndTime.add(END_STAGE_DURATION);\r\n            if(now \u003c endTimestamp)\r\n            {\r\n                return int(endTimestamp.sub(now));\r\n            }\r\n            else\r\n            {\r\n                return 0;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n    function kill() onlyOwner public\r\n    {\r\n        require(isEndStage \u0026\u0026 enterEndTime \u003e 0 \u0026\u0026 now - enterEndTime \u003e END_STAGE_DURATION\r\n            ,\u0027now is not end stage or not enter end stage or now is not reach end stage duration.\u0027);\r\n        selfdestruct(toPayable(owner));\r\n    }\r\n    function setName(string memory _name)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        name = _name;\r\n    }\r\n    function setSymbol(string memory _symbol)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        symbol = _symbol;\r\n    }\r\n    function totalEthereumBalance()\r\n    public\r\n    view\r\n    returns(uint)\r\n    {\r\n        return address(this).balance.sub(totalOperatorRewards);\r\n    }\r\n    function totalSupply()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return tokenSupply_;\r\n    }\r\n    function myTokens()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return balanceOf(msg.sender);\r\n    }\r\n    function balanceOf(address _customerAddress)\r\n    view\r\n    public\r\n    returns(uint256)\r\n    {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n    function sellPrice()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = _ethereum.div( dividendFee_  );\r\n            uint256 _taxedEthereum = _ethereum.sub( _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n    function buyPrice()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _taxedEthereum = _ethereum.mul(dividendFee_).div(dividendFee_-1);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n    function calculateTokensReceived(uint256 _ethereumToSpend)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 _dividends = _ethereumToSpend.div( dividendFee_);\r\n        uint256 _taxedEthereum = _ethereumToSpend.sub( _dividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        return _amountOfTokens;\r\n    }\r\n    function calculateEthereumReceived(uint256 _tokensToSell)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        require(_tokensToSell \u003c= tokenSupply_,\u0027token to sell should less than total tokens.\u0027);\r\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\r\n        uint256 _dividends = _ethereum.div( dividendFee_);\r\n        uint256 _taxedEthereum = _ethereum.sub( _dividends);\r\n        return _taxedEthereum;\r\n    }\r\n    function purchaseTokens(uint256 _incomingEthereum)\r\n    antiEarlyWhale(_incomingEthereum)\r\n    notEndStage()\r\n    internal\r\n    returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = _incomingEthereum.div( dividendFee_);\r\n        uint256 _taxedEthereum = _incomingEthereum.sub( _dividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        require(_amountOfTokens \u003e 0 \u0026\u0026 (_amountOfTokens.add(tokenSupply_) \u003e tokenSupply_)\r\n            ,\u0027to buy tokens should \u003e0 and not cause total token overflow max uint.\u0027);\r\n        sendOperatorRewards_(_dividends);\r\n        if(tokenSupply_ \u003e 0){\r\n            tokenSupply_ = tokenSupply_.add( _amountOfTokens);\r\n        } else {\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress].add( _amountOfTokens);\r\n        lastActiveTime = now;\r\n        emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens);\r\n        return _amountOfTokens;\r\n    }\r\n    function sendOperatorRewards_(uint256 _ethereum)\r\n    internal\r\n    {\r\n        uint restRewards = _ethereum;\r\n        for(uint i = mapOperatorStocks_.iterate_start(); mapOperatorStocks_.iterate_valid(i) \u0026\u0026 restRewards\u003e0; i = mapOperatorStocks_.iterate_next(i))\r\n        {\r\n            (uint addrOperator,uint stocks) = mapOperatorStocks_.iterate_get(i);\r\n            if(stocks == 0)\r\n            {\r\n                continue;\r\n            }\r\n            uint256 rewards = _ethereum.mul(stocks).div(totalStocks_);\r\n            if(rewards \u003e restRewards)\r\n            {\r\n                rewards = restRewards;\r\n            }\r\n            restRewards = restRewards.sub(rewards);\r\n            mapOperatorRewards_.add_or_insert(addrOperator,rewards);\r\n            totalOperatorRewards = totalOperatorRewards.add(rewards);\r\n        }\r\n    }\r\n    function getOperatorStocks_()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        return mapOperatorStocks_.data[uint(msg.sender)].value;\r\n    }\r\n    function getOperatorRewards_()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        return mapOperatorRewards_.data[uint(msg.sender)].value;\r\n    }\r\n    function withDrawRewards_()\r\n    nonReentrant()\r\n    notEarlyWhale()\r\n    onlyOperators()\r\n    public\r\n    {\r\n        uint player = uint(msg.sender);\r\n        require(mapOperatorRewards_.contains(player),\u0027stock holder should has rewards.\u0027);\r\n        uint totalRewards = mapOperatorRewards_.data[player].value;\r\n        require(totalRewards\u003e0 \u0026\u0026 totalRewards \u003c= totalOperatorRewards \u0026\u0026 totalRewards \u003c= address(this).balance\r\n            ,\u0027rewards should \u003e0 and less than total rewards and less than contract balance.\u0027);\r\n        mapOperatorRewards_.sub(player,totalRewards);\r\n        totalOperatorRewards = totalOperatorRewards.sub(totalRewards);\r\n        msg.sender.transfer(totalRewards);\r\n    }\r\n    function transferStocks_(address receiver,uint amountStock)\r\n    nonReentrant()\r\n    onlyOperators()\r\n    notEarlyWhale()\r\n    notEndStage()\r\n    public\r\n    {\r\n        uint sender = uint(msg.sender);\r\n        uint restStocks = uint(mapOperatorStocks_.data[sender].value).sub(mapLockStocks[msg.sender]);\r\n        require(amountStock \u003c= restStocks\r\n            ,\u0027to transfer stock amount should less than player stocks except locked stocks.\u0027);\r\n        mapOperatorStocks_.add_or_insert(uint(receiver),amountStock);\r\n        mapOperatorStocks_.sub(sender,amountStock);\r\n        if(mapOperatorStocks_.data[sender].value == 0)\r\n        {\r\n            uint totalRewards = mapOperatorRewards_.data[sender].value;\r\n            mapOperatorStocks_.remove(sender);\r\n            mapOperatorRewards_.remove(sender);\r\n            if(totalRewards \u003e 0)\r\n            {\r\n                if(totalRewards \u003e totalOperatorRewards)\r\n                {\r\n                    totalRewards = totalOperatorRewards;\r\n                }\r\n                totalOperatorRewards = totalOperatorRewards.sub(totalRewards);\r\n                address(sender).transfer(totalRewards);\r\n            }\r\n        }\r\n    }\r\n    function createStockTransaction(address _receiver, uint _stocks, uint _price)\r\n    notEarlyWhale()\r\n    notEndStage()\r\n    public\r\n    {\r\n        uint restStocks = uint(mapOperatorStocks_.data[uint(msg.sender)].value).sub(mapLockStocks[msg.sender]);\r\n        require(_stocks \u003e 0 \u0026\u0026 _stocks \u003c= restStocks\r\n            ,\u0027stock to transact should \u003e0 and less than player stocks except locked stocks.\u0027);\r\n        require(_price \u003e 0,\u0027price should \u003e0.\u0027);\r\n        StockTransInfo storage info = mapStockTrans[msg.sender][_receiver];\r\n        require(info.stocks == 0,\u0027transaction to receiver has exist.\u0027);\r\n        mapLockStocks[msg.sender] = mapLockStocks[msg.sender].add(_stocks);\r\n        info.stocks = _stocks;\r\n        info.price = _price;\r\n        info.endTime = now + stockLockTime;\r\n    }\r\n    function getMyLockStocks()\r\n    public\r\n    view\r\n    returns(uint)\r\n    {\r\n        return mapLockStocks[msg.sender];\r\n    }\r\n    function queryStocksTransactionTo(address receiver)\r\n    public\r\n    view\r\n    returns(uint _stocks, uint _price, uint _endTime)\r\n    {\r\n        StockTransInfo storage info = mapStockTrans[msg.sender][receiver];\r\n        _stocks = info.stocks;\r\n        _price = info.price;\r\n        _endTime = info.endTime;\r\n    }\r\n    function queryStocksTransactionFrom(address seller)\r\n    public\r\n    view\r\n    returns(uint _stocks, uint _price, uint _endTime)\r\n    {\r\n        StockTransInfo storage info = mapStockTrans[seller][msg.sender];\r\n        _stocks = info.stocks;\r\n        _price = info.price;\r\n        _endTime = info.endTime;\r\n    }\r\n    function confirmStocksTransaction(address payable seller, bool agreed)\r\n    nonReentrant()\r\n    notEarlyWhale()\r\n    payable\r\n    public\r\n    {\r\n        StockTransInfo storage info = mapStockTrans[seller][msg.sender];\r\n        require(info.stocks \u003e 0 \u0026\u0026 now \u003c info.endTime,\u0027transact stocks is not \u003e0 or now has reached end time.\u0027);\r\n        if(agreed)\r\n        {\r\n            require(msg.value == info.price,\u0027msg.sender paid ether is not equal to the price.\u0027);\r\n            mapOperatorStocks_.add_or_insert(uint(msg.sender),info.stocks);\r\n            mapOperatorStocks_.sub(uint(seller),info.stocks);\r\n        }\r\n        mapLockStocks[seller] = mapLockStocks[seller].sub(info.stocks);\r\n        if(mapLockStocks[seller] == 0)\r\n        {\r\n            delete mapLockStocks[seller];\r\n        }\r\n        delete mapStockTrans[seller][msg.sender];\r\n        if(agreed)\r\n        {\r\n            uint sender = uint(seller);\r\n            uint transValue = msg.value;\r\n            if(mapOperatorStocks_.data[sender].value == 0)\r\n            {\r\n                uint totalRewards = mapOperatorRewards_.data[sender].value;\r\n                mapOperatorStocks_.remove(sender);\r\n                mapOperatorRewards_.remove(sender);\r\n                if(totalRewards \u003e 0)\r\n                {\r\n                    if(totalRewards \u003e totalOperatorRewards)\r\n                    {\r\n                        totalRewards = totalOperatorRewards;\r\n                    }\r\n                    totalOperatorRewards = totalOperatorRewards.sub(totalRewards);\r\n                    transValue = transValue.add(totalRewards);\r\n                }\r\n            }\r\n            seller.transfer(transValue);\r\n        }\r\n    }\r\n    function retrieveStocksBack(address receiver)\r\n    notEarlyWhale()\r\n    public\r\n    {\r\n        address seller = msg.sender;\r\n        StockTransInfo storage info = mapStockTrans[seller][receiver];\r\n        require(info.stocks \u003e 0 \u0026\u0026 now \u003e info.endTime,\u0027transact stocks is not \u003e0 or now has not reach end time.\u0027);\r\n        mapLockStocks[seller] = mapLockStocks[seller].sub(info.stocks);\r\n        if(mapLockStocks[seller] == 0)\r\n        {\r\n            delete mapLockStocks[seller];\r\n        }\r\n        delete mapStockTrans[seller][msg.sender];\r\n    }\r\n    function ethereumToTokens_(uint256 _ethereum)\r\n    internal\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived =\r\n        (\r\n        (sqrt\r\n        (\r\n            (_tokenPriceInitial**2)\r\n            +\r\n            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\r\n            +\r\n            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\r\n            +\r\n            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\r\n        )\r\n        ).sub( _tokenPriceInitial\r\n        )\r\n        /(tokenPriceIncremental_)\r\n        )-(tokenSupply_)\r\n        ;\r\n        return _tokensReceived;\r\n    }\r\n    function tokensToEthereum_(uint256 _tokens)\r\n    internal\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n        (\r\n        (\r\n        (\r\n        (\r\n        tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\r\n        )-tokenPriceIncremental_\r\n        )*(tokens_ - 1e18)\r\n        ).sub((tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\r\n        )\r\n        /1e18);\r\n        return _etherReceived;\r\n    }\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z \u003c y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n"}}
