{"IterableMapping.sol":{"content":"pragma solidity ^0.5.8;\r\nimport \"./SafeMath.sol\";\r\n/// @dev Models a uint -\u003e uint mapping where it is possible to iterate over all keys.\r\nlibrary IterableMapping\r\n{\r\n    using SafeMath for uint;\r\n    struct itmap\r\n    {\r\n        mapping(uint =\u003e IndexValue) data;\r\n        KeyFlag[] keys;\r\n        uint size;\r\n    }\r\n    struct IndexValue { uint keyIndex; uint value; }\r\n    struct KeyFlag { uint key; bool deleted; }\r\n    function insert(itmap storage self, uint key, uint value) public returns (bool replaced)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        self.data[key].value = value;\r\n        if (keyIndex \u003e 0)\r\n            return true;\r\n        else\r\n        {\r\n            keyIndex = self.keys.length++;\r\n            self.data[key].keyIndex = keyIndex + 1;\r\n            self.keys[keyIndex].key = key;\r\n            self.size++;\r\n            return false;\r\n        }\r\n    }\r\n    function add_or_insert(itmap storage self, uint key, uint value) public returns (bool added)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n\r\n        if (keyIndex \u003e 0)\r\n        {\r\n            self.data[key].value = self.data[key].value.add(value);\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            self.data[key].value = value;\r\n            keyIndex = self.keys.length++;\r\n            self.data[key].keyIndex = keyIndex + 1;\r\n            self.keys[keyIndex].key = key;\r\n            self.size++;\r\n            return false;\r\n        }\r\n    }\r\n    function sub(itmap storage self, uint key, uint value) public returns (bool subbed)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n\r\n        if (keyIndex \u003e 0)\r\n        {\r\n            self.data[key].value = self.data[key].value.sub(value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function remove(itmap storage self, uint key) public returns (bool success)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        if (keyIndex == 0)\r\n            return false;\r\n        delete self.data[key];\r\n        self.keys[keyIndex - 1].deleted = true;\r\n        self.size --;\r\n    }\r\n\r\n    function clear(itmap storage self) public\r\n    {\r\n        uint len = self.keys.length;\r\n        for(uint i = 0; i\u003clen; i++)\r\n        {\r\n            if(!self.keys[i].deleted)\r\n            {\r\n                delete self.data[self.keys[i].key];\r\n            }\r\n        }\r\n        self.keys.length = 0;\r\n        self.size = 0;\r\n    }\r\n    function contains(itmap storage self, uint key) public view returns (bool)\r\n    {\r\n        return self.data[key].keyIndex \u003e 0;\r\n    }\r\n    function iterate_start(itmap storage self) public view returns (uint keyIndex)\r\n    {\r\n        return iterate_next(self, uint(-1));\r\n    }\r\n    function iterate_valid(itmap storage self, uint keyIndex) public view returns (bool)\r\n    {\r\n        return keyIndex \u003c self.keys.length;\r\n    }\r\n    function iterate_next(itmap storage self, uint keyIndex) public view returns (uint r_keyIndex)\r\n    {\r\n        keyIndex++;\r\n        while (keyIndex \u003c self.keys.length \u0026\u0026 self.keys[keyIndex].deleted)\r\n            keyIndex++;\r\n        return keyIndex;\r\n    }\r\n    function iterate_get(itmap storage self, uint keyIndex) public view returns (uint key, uint value)\r\n    {\r\n        key = self.keys[keyIndex].key;\r\n        value = self.data[key].value;\r\n    }\r\n}\r\n"},"ReentrancyGuard.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n * available, which can be aplied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"},"WeFairPlayInvestment.sol":{"content":"pragma solidity ^0.5.8;\r\nimport \"./SafeMath.sol\";\r\nimport \"./IterableMapping.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\ncontract WeFairPlayInvestment is ReentrancyGuard{\r\n    using SafeMath for uint;\r\n    using IterableMapping for IterableMapping.itmap;\r\n    modifier onlyBagholders() {\r\n        require(myTokens() \u003e 0);\r\n        _;\r\n    }\r\n    modifier onlyStronghands() {\r\n        require(myDividends(true) \u003e 0);\r\n        _;\r\n    }\r\n    modifier onlyOwner()\r\n    {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n    modifier onlyAdministrator(){\r\n        require(owner == msg.sender || administrators[keccak256(abi.encodePacked(msg.sender))]);\r\n        _;\r\n    }\r\n    modifier onlyOperators(){\r\n        require(mapOperatorStocks_.contains(uint(msg.sender))\r\n            \u0026\u0026 mapOperatorStocks_.data[uint(msg.sender)].value \u003e 0);\r\n        _;\r\n    }\r\n    modifier notEarlyWhale(){\r\n        require(!onlyAmbassadors);\r\n        _;\r\n    }\r\n    modifier notEndStage(){\r\n        require(!isEndStage);\r\n        _;\r\n    }\r\n    modifier antiEarlyWhale(uint256 _amountOfEthereum){\r\n        if(!onlyAmbassadors) {\r\n            _;\r\n            return;\r\n        }\r\n        address _customerAddress = msg.sender;\r\n          if( onlyAmbassadors \u0026\u0026 (totalEthereumBalance() \u003c ambassadorQuota_ )){\r\n            require(\r\n                ambassadors_[_customerAddress] == true \u0026\u0026\r\n                (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) \u003c= ambassadorMaxPurchase_);\r\n                ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);\r\n            _;\r\n        } else {\r\n            onlyAmbassadors = false;\r\n            _;\r\n        }\r\n\r\n    }\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy\r\n    );\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned\r\n    );\r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensMinted\r\n    );\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n    string public name = \"WeFairPlayCoin\";\r\n    string public symbol = \"WFP\";\r\n    uint8 constant public decimals = 18;\r\n    uint8 constant internal operatorFee_ = 10;\r\n    uint8 constant internal dividendFee_ = 10;\r\n    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\r\n    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\r\n    uint256 constant internal magnitude = 2**64;\r\n    uint256 public stakingRequirement = 100e18;\r\n    mapping(address =\u003e bool) internal ambassadors_;\r\n    uint256 constant internal ambassadorMaxPurchase_ = 1 ether;\r\n    uint256 constant internal ambassadorQuota_ = 10 ether;\r\n    mapping(address =\u003e uint256) internal tokenBalanceLedger_;\r\n    mapping(address =\u003e uint256) internal referralBalance_;\r\n    mapping(address =\u003e int256) internal payoutsTo_;\r\n    mapping(address =\u003e uint256) internal ambassadorAccumulatedQuota_;\r\n    uint256 internal tokenSupply_ = 0;\r\n    uint256 internal profitPerShare_;\r\n    mapping(bytes32 =\u003e bool) public administrators;\r\n    bool public onlyAmbassadors = true;\r\n    IterableMapping.itmap mapOperatorRewards_;\r\n    IterableMapping.itmap mapOperatorStocks_;\r\n    uint totalOperatorRewards;\r\n    uint256 constant public totalStocks_ = 10000;\r\n    uint lastActiveTime;\r\n    uint constant internal ENTER_END_DURATION = 2 * 4 weeks;//10 minutes;//2 * 4 weeks;\r\n    bool public isEndStage;\r\n    uint public enterEndTime;\r\n    uint constant internal END_STAGE_DURATION = 4 weeks;//10 minutes;//4 weeks;\r\n    address owner;\r\n    constructor()\r\n    public\r\n    {\r\n        owner = msg.sender;\r\n         administrators[0x6e87e5c3130679f898089256718f36b117cb685debd8d2511298b3f0dabadf1e] = true;\r\n        ambassadors_[0x1Fd11576EAbe588115aA47E52904C3221E4c0a95] = true;\r\n        ambassadors_[0x1DC93b1bE8b97959f5B07d6113A909F9C89D3361] = true;\r\n        ambassadors_[0x135de610Bd907e9B6aB3d93753d6E59De6ef886B] = true;\r\n        ambassadors_[0x5f5B2BB60EBDa86C9efc9a4cA01a7756554c2Fe5] = true;\r\n        ambassadors_[0x89EE32611CcFa44044cc1F0d0ECC53E53Aa3C634] = true;\r\n        ambassadors_[0x16B0e5F320Cd30028caFf791aC08dF830B52e61d] = true;\r\n        ambassadors_[0xA9d47178067568A5C84c0849A7e1b47139DA6a7c] = true;\r\n        ambassadors_[0x0d7e1a43e666714A1B7B8F4e5eD9Ac86597078A0] = true;\r\n        ambassadors_[0xc33F6Ca865D8Ec8fE00037f64B8dbe6cBD751555] = true;\r\n        ambassadors_[0x324bC683445fa86CFc85b49c1eD4d2bdDc6409aE] = true;\r\n        mapOperatorStocks_.add_or_insert(uint(owner),totalStocks_);\r\n    }\r\n    function ambassadorLeftLimit()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        if(ambassadors_[msg.sender]) {\r\n            return ambassadorMaxPurchase_.sub(ambassadorAccumulatedQuota_[msg.sender]);\r\n        }\r\n        return 0;\r\n    }\r\n    function isAmbassador()\r\n    view\r\n    public\r\n    returns(bool)\r\n    {\r\n        return ambassadors_[msg.sender];\r\n    }\r\n    function buy(address _referredBy)\r\n    public\r\n    payable\r\n    {\r\n        purchaseTokens(msg.value, _referredBy);\r\n    }\r\n    function()\r\n    payable\r\n    external\r\n    {\r\n        purchaseTokens(msg.value, address(0x0));\r\n    }\r\n    function reinvest()\r\n    onlyStronghands()\r\n    public\r\n    {\r\n        uint256 _dividends = myDividends(false); // retrieve ref. bonus later in the code\r\n        address _customerAddress = msg.sender;\r\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\r\n        _dividends += referralBalance_[_customerAddress];\r\n        referralBalance_[_customerAddress] = 0;\r\n        uint256 _tokens = purchaseTokens(_dividends, address(0x0));\r\n        emit onReinvestment(_customerAddress, _dividends, _tokens);\r\n    }\r\n    function exit()\r\n    public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\r\n        if(_tokens \u003e 0) sell(_tokens);\r\n        withdraw();\r\n    }\r\n    function withdraw()\r\n    nonReentrant()\r\n    onlyStronghands()\r\n    notEarlyWhale()\r\n    public\r\n    {\r\n        address payable _customerAddress = msg.sender;\r\n        uint256 _dividends = myDividends(false);\r\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\r\n        _dividends += referralBalance_[_customerAddress];\r\n        referralBalance_[_customerAddress] = 0;\r\n        _customerAddress.transfer(_dividends);\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    function sell(uint256 _amountOfTokens)\r\n    notEarlyWhale()\r\n    onlyBagholders()\r\n    public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        require(_amountOfTokens \u003c= tokenBalanceLedger_[_customerAddress]);\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 _ethereum = tokensToEthereum_(_tokens);\r\n        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\r\n        uint256 operatorDividends = SafeMath.div(_dividends, operatorFee_);\r\n        sendOperatorRewards_(operatorDividends);\r\n        _dividends = _dividends - operatorDividends;\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\r\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n        if (tokenSupply_ \u003e 0) {\r\n            profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\r\n        }\r\n\r\n        lastActiveTime = now;\r\n        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);\r\n    }\r\n    function _transfer(address _from, address _toAddress, uint _amountOfTokens)\r\n    notEarlyWhale()\r\n    notEndStage()\r\n    internal\r\n    {\r\n        address _customerAddress = _from;\r\n        require(_amountOfTokens \u003c= tokenBalanceLedger_[_customerAddress]);\r\n        if(myDividends(true) \u003e 0) withdraw();\r\n        uint256 _tokenFee = SafeMath.div(_amountOfTokens, dividendFee_);\r\n        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\r\n        uint256 _dividends = tokensToEthereum_(_tokenFee);\r\n        uint256 operatorDividends = SafeMath.div(_dividends, operatorFee_);\r\n        sendOperatorRewards_(operatorDividends);\r\n        _dividends = _dividends - operatorDividends;\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\r\n        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);\r\n        profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\r\n        lastActiveTime = now;\r\n        emit Transfer(_customerAddress, _toAddress, _taxedTokens);\r\n    }\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n    onlyBagholders()\r\n    public\r\n    returns(bool)\r\n    {\r\n        _transfer(msg.sender, _toAddress, _amountOfTokens);\r\n        return true;\r\n    }\r\n    function isAdministrator()\r\n    view\r\n    public\r\n    returns(bool)\r\n    {\r\n        return (owner == msg.sender || administrators[keccak256(abi.encodePacked(msg.sender))]);\r\n    }\r\n    function disableInitialStage()\r\n    onlyOwner()\r\n    public\r\n    {\r\n        onlyAmbassadors = false;\r\n    }\r\n    function setAdministrator(bytes32 _identifier, bool _status)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        administrators[_identifier] = _status;\r\n    }\r\n    function setOwner(address payable newOwner) onlyOwner public\r\n    {\r\n        owner = newOwner;\r\n    }\r\n    function canEnterEndStage() view public returns(bool)\r\n    {\r\n        return (!isEndStage \u0026\u0026 lastActiveTime \u003e 0 \u0026\u0026 now - lastActiveTime \u003e ENTER_END_DURATION);\r\n    }\r\n    function enterEndStage() onlyOwner public\r\n    {\r\n        require(!isEndStage);\r\n        require(lastActiveTime \u003e 0 \u0026\u0026 now - lastActiveTime \u003e ENTER_END_DURATION);\r\n        isEndStage = true;\r\n        enterEndTime = now;\r\n    }\r\n    function restEndTime() view public returns(int)\r\n    {\r\n        if(isEndStage \u0026\u0026 enterEndTime \u003e 0)\r\n        {\r\n            uint endTimestamp = enterEndTime.add(END_STAGE_DURATION);\r\n            if(now \u003c endTimestamp)\r\n            {\r\n                return int(endTimestamp.sub(now));\r\n            }\r\n            else\r\n            {\r\n                return 0;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n    function kill() onlyOwner public\r\n    {\r\n        require(isEndStage \u0026\u0026 enterEndTime \u003e 0 \u0026\u0026 now - enterEndTime \u003e END_STAGE_DURATION);\r\n        selfdestruct(toPayable(owner));\r\n    }\r\n    function setStakingRequirement(uint256 _amountOfTokens)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        stakingRequirement = _amountOfTokens;\r\n    }\r\n    function setName(string memory _name)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        name = _name;\r\n    }\r\n    function setSymbol(string memory _symbol)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        symbol = _symbol;\r\n    }\r\n    function totalEthereumBalance()\r\n    public\r\n    view\r\n    returns(uint)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n    function totalSupply()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return tokenSupply_;\r\n    }\r\n    function myTokens()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n    function myDividends(bool _includeReferralBonus)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\r\n    }\r\n    function balanceOf(address _customerAddress)\r\n    view\r\n    public\r\n    returns(uint256)\r\n    {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n    function dividendsOf(address _customerAddress)\r\n    view\r\n    public\r\n    returns(uint256)\r\n    {\r\n        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\r\n    }\r\n    function sellPrice()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );\r\n            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n    function buyPrice()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = _ethereum.div( dividendFee_  );\r\n            uint256 _taxedEthereum = _ethereum.add( _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n    function calculateTokensReceived(uint256 _ethereumToSpend)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        return _amountOfTokens;\r\n    }\r\n    function calculateEthereumReceived(uint256 _tokensToSell)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        require(_tokensToSell \u003c= tokenSupply_);\r\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\r\n        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\r\n        return _taxedEthereum;\r\n    }\r\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy)\r\n    antiEarlyWhale(_incomingEthereum)\r\n    notEndStage()\r\n    internal\r\n    returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        uint256 _undividedDividends = SafeMath.div(_incomingEthereum, dividendFee_);\r\n        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\r\n        sendOperatorRewards_(SafeMath.div(_undividedDividends, operatorFee_));\r\n        _undividedDividends = _undividedDividends - SafeMath.div(_undividedDividends, operatorFee_);\r\n        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\r\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        uint256 _fee = _dividends * magnitude;\r\n        require(_amountOfTokens \u003e 0 \u0026\u0026 (SafeMath.add(_amountOfTokens,tokenSupply_) \u003e tokenSupply_));\r\n        if(\r\n            _referredBy != address(0x0000000000000000000000000000000000000000) \u0026\u0026\r\n            _referredBy != _customerAddress \u0026\u0026\r\n        tokenBalanceLedger_[_referredBy] \u003e= stakingRequirement\r\n        ){\r\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\r\n        } else {\r\n            _dividends = SafeMath.add(_dividends, _referralBonus);\r\n            _fee = _dividends * magnitude;\r\n        }\r\n        if(tokenSupply_ \u003e 0){\r\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\r\n            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\r\n            _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\r\n        } else {\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\r\n        payoutsTo_[_customerAddress] += _updatedPayouts;\r\n        lastActiveTime = now;\r\n        emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);\r\n        return _amountOfTokens;\r\n    }\r\n    function ethereumToTokens_(uint256 _ethereum)\r\n    internal\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived =\r\n        (\r\n        (\r\n        SafeMath.sub(\r\n            (sqrt\r\n        (\r\n            (_tokenPriceInitial**2)\r\n            +\r\n            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\r\n            +\r\n            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\r\n            +\r\n            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\r\n        )\r\n            ), _tokenPriceInitial\r\n        )\r\n        )/(tokenPriceIncremental_)\r\n        )-(tokenSupply_)\r\n        ;\r\n        return _tokensReceived;\r\n    }\r\n    function tokensToEthereum_(uint256 _tokens)\r\n    internal\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n        (\r\n        SafeMath.sub(\r\n            (\r\n            (\r\n            (\r\n            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\r\n            )-tokenPriceIncremental_\r\n            )*(tokens_ - 1e18)\r\n            ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\r\n        )\r\n        /1e18);\r\n        return _etherReceived;\r\n    }\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z \u003c y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n    function sendOperatorRewards_(uint256 _ethereum)\r\n    internal\r\n    {\r\n        uint restRewards = _ethereum;\r\n        for(uint i = mapOperatorStocks_.iterate_start(); mapOperatorStocks_.iterate_valid(i) \u0026\u0026 restRewards\u003e0; i = mapOperatorStocks_.iterate_next(i))\r\n        {\r\n            (uint addrOperator,uint stocks) = mapOperatorStocks_.iterate_get(i);\r\n            if(stocks == 0)\r\n            {\r\n                continue;\r\n            }\r\n            uint256 rewards = _ethereum.mul(stocks).div(totalStocks_);\r\n            if(rewards \u003e restRewards)\r\n            {\r\n                rewards = restRewards;\r\n            }\r\n            restRewards = restRewards.sub(rewards);\r\n            mapOperatorRewards_.add_or_insert(addrOperator,rewards);\r\n            totalOperatorRewards = totalOperatorRewards.add(rewards);\r\n        }\r\n    }\r\n    function getOperatorStocks_()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        return mapOperatorStocks_.data[uint(msg.sender)].value;\r\n    }\r\n    function getOperatorRewards_()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        return mapOperatorRewards_.data[uint(msg.sender)].value;\r\n    }\r\n    function withDrawRewards_()\r\n    nonReentrant()\r\n    notEarlyWhale()\r\n    onlyOperators()\r\n    public\r\n    {\r\n        uint player = uint(msg.sender);\r\n        require(mapOperatorRewards_.contains(player));\r\n        uint totalRewards = mapOperatorRewards_.data[player].value;\r\n        require(totalRewards\u003e0 \u0026\u0026 totalRewards \u003c= totalOperatorRewards \u0026\u0026 totalRewards \u003c= address(this).balance);\r\n        mapOperatorRewards_.sub(player,totalRewards);\r\n        totalOperatorRewards = totalOperatorRewards.sub(totalRewards);\r\n        msg.sender.transfer(totalRewards);\r\n    }\r\n    function transferStocks_(address receiver,uint amountStock)\r\n    nonReentrant()\r\n    onlyOperators()\r\n    notEarlyWhale()\r\n    notEndStage()\r\n    public\r\n    {\r\n        uint sender = uint(msg.sender);\r\n        uint restStocks = uint(mapOperatorStocks_.data[sender].value);\r\n        require(amountStock \u003c= restStocks);\r\n        mapOperatorStocks_.add_or_insert(uint(receiver),amountStock);\r\n        mapOperatorStocks_.sub(sender,amountStock);\r\n        if(mapOperatorStocks_.data[sender].value == 0)\r\n        {\r\n            uint totalRewards = mapOperatorRewards_.data[sender].value;\r\n            mapOperatorStocks_.remove(sender);\r\n            mapOperatorRewards_.remove(sender);\r\n            if(totalRewards \u003e 0)\r\n            {\r\n                if(totalRewards \u003e totalOperatorRewards)\r\n                {\r\n                    totalRewards = totalOperatorRewards;\r\n                }\r\n                totalOperatorRewards = totalOperatorRewards.sub(totalRewards);\r\n                address(sender).transfer(totalRewards);\r\n            }\r\n        }\r\n    }\r\n}\r\n"}}
