{"Address.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Collection of functions related to the address type,\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract\u0027s constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * \u003e It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n}\n"},"BigOrSmall.sol":{"content":"pragma solidity ^0.5.8;\r\nimport \"./SafeMath.sol\";\r\nimport \"./IterableMapping.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\nimport \"./Address.sol\";\r\nimport \"./WeFairPlayInvestment.sol\";\r\ncontract BigOrSmall is ReentrancyGuard {\r\n    using SafeMath for uint;\r\n    using IterableMapping for IterableMapping.itmap;\r\n    uint8 constant MIN_DUR_BLOCKS = 5;\r\n    uint8 constant MIN_LIMIT_BLOCKS = 4;\r\n    uint8 constant MIN_INTERVAL_BLOCKS = 1;\r\n    uint32 constant MAX_TIME_PER_GAME = 1 days;\r\n    uint32 constant DESTROY_DURATION = 30 days;//30 days;\r\n    uint constant POOL_MIN = 1e18;//1e18;\r\n    uint constant POOL_MAX = 100e18;//100e18;\r\n\r\n    enum BetTypes {\r\n        Big,\r\n        Small,\r\n        Triple,\r\n        EachDouble,\r\n        Sum,\r\n        OneNum,\r\n        TwoNum,\r\n        BetTypeCnt\r\n    }\r\n    address owner;\r\n    bytes32 adminKey;\r\n    bool public noAdminMode;\r\n    address payable addrInvest;\r\n    uint public poolCache = 1e18;\r\n    uint public totalCanGetRewards;\r\n    uint public totalOweRewards;\r\n    IterableMapping.itmap mapBig;\r\n    IterableMapping.itmap mapSmall;\r\n    IterableMapping.itmap[7] mapTriple;\r\n    IterableMapping.itmap[6] mapDouble;\r\n    IterableMapping.itmap[14] mapSum;\r\n    uint8[14] rateSum = [uint8(50),18,14,12,8,6,6,6,6,8,12,14,18,50];\r\n    IterableMapping.itmap[6] mapOne;\r\n    IterableMapping.itmap[15] mapTwo;\r\n    IterableMapping.itmap mapPlayerRewards;\r\n    IterableMapping.itmap mapCanGetRewards;\r\n    IterableMapping.itmap mapOweRewards;\r\n    uint public totalGameBets;\r\n    uint public systemBalance;\r\n    uint totalWinBets;\r\n    uint public bigBets;\r\n    uint public smallBets;\r\n    uint public startBlockNum;\r\n    uint startTime;\r\n    uint32 public gameDurationBlocks;\r\n    uint public endBlockNum;\r\n    uint32 public gameLimitBlocks;\r\n    uint public betLimitBlockNum;\r\n    bytes32 serverRandomHash;\r\n    uint public lastBetTime;\r\n    bool isInvested;\r\n    uint public round;\r\n    uint8 public gameState;\r\n    event PlayerBet(address player,uint round,uint ret,uint numBet,uint bet);\r\n    event EndGame(uint round,uint one,uint two,uint three);\r\n    modifier onlyAdministrator()\r\n    {\r\n        require(owner == msg.sender || adminKey == keccak256(abi.encodePacked(msg.sender)));\r\n        _;\r\n    }\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    modifier onlyBetting(){ require((block.number \u003c= betLimitBlockNum) || gameState == 2); _;}\r\n    constructor(address payable investAddress,uint32 gameDurBlocks,uint32 bLimitBlocks,bytes32 serverRandom) public\r\n    {\r\n        owner = msg.sender;\r\n        adminKey = 0x6e87e5c3130679f898089256718f36b117cb685debd8d2511298b3f0dabadf1e;\r\n        addrInvest = investAddress;\r\n        serverRandomHash = serverRandom;\r\n        if(gameDurBlocks \u003c MIN_DUR_BLOCKS)\r\n            gameDurBlocks = MIN_DUR_BLOCKS;\r\n        gameDurationBlocks = gameDurBlocks;\r\n        if(bLimitBlocks \u003c MIN_LIMIT_BLOCKS)\r\n            bLimitBlocks = MIN_LIMIT_BLOCKS;\r\n        if(bLimitBlocks \u003e gameDurBlocks - MIN_INTERVAL_BLOCKS)\r\n            bLimitBlocks = gameDurBlocks - MIN_INTERVAL_BLOCKS;\r\n        gameLimitBlocks = bLimitBlocks;\r\n        gameState = 3;\r\n    }\r\n    function getTwoNumIdxByCalced(uint8 calced)\r\n    internal\r\n    pure\r\n    returns(uint8)\r\n    {\r\n        if(12 == calced){return 0;}\r\n        else if(13 == calced){return 1;}\r\n        else if(14 == calced){return 2;}\r\n        else if(15 == calced){return 3;}\r\n        else if(16 == calced){return 4;}\r\n        else if(23 == calced){return 5;}\r\n        else if(24 == calced){return 6;}\r\n        else if(25 == calced){return 7;}\r\n        else if(26 == calced){return 8;}\r\n        else if(34 == calced){return 9;}\r\n        else if(35 == calced){return 10;}\r\n        else if(36 == calced){return 11;}\r\n        else if(45 == calced){return 12;}\r\n        else if(46 == calced){return 13;}\r\n        else if(56 == calced){return 14;}\r\n        else {return 15;}\r\n    }\r\n    function isAdministrator()\r\n    view\r\n    public\r\n    returns(bool)\r\n    {\r\n        return (owner == msg.sender || adminKey == keccak256(abi.encodePacked(msg.sender)));\r\n    }\r\n    function setAdministrator(bytes32 _identifier, bool _status) onlyAdministrator  public\r\n    {\r\n        if(_status)\r\n        {\r\n            adminKey = _identifier;\r\n        }\r\n        else if(_identifier == adminKey)\r\n        {\r\n            adminKey = 0;\r\n        }\r\n        noAdminMode = false;\r\n    }\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n    function kill() onlyOwner public\r\n    {\r\n        require(totalOweRewards == 0);\r\n        require(lastBetTime \u003e 0 \u0026\u0026 now.sub(lastBetTime) \u003e DESTROY_DURATION);\r\n        selfdestruct(toPayable(owner));\r\n    }\r\n    function setDurAndBetLimit(uint32 gameDurBlocks,uint32 bLimitBlocks) onlyAdministrator onlyBetting public\r\n    {\r\n        require(gameDurBlocks \u003e= MIN_DUR_BLOCKS\r\n            \u0026\u0026 bLimitBlocks \u003e= MIN_LIMIT_BLOCKS\r\n            \u0026\u0026 gameDurBlocks-MIN_INTERVAL_BLOCKS \u003e= bLimitBlocks\r\n            );\r\n        gameDurationBlocks = gameDurBlocks;\r\n        gameLimitBlocks = bLimitBlocks;\r\n    }\r\n    function launchGame() onlyAdministrator public\r\n    {\r\n        require(gameState == 3);\r\n        startNextRound();\r\n    }\r\n    function systemOweMyRewards()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        return mapOweRewards.data[uint(msg.sender)].value;\r\n    }\r\n    function myCanGetRewards()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        return mapCanGetRewards.data[uint(msg.sender)].value;\r\n    }\r\n    function bet(uint8 btype,uint8 numBet) onlyBetting payable public\r\n    {\r\n        require(msg.value \u003e= 1e16);\r\n        require(btype \u003e= 0 \u0026\u0026  btype \u003c uint8(BetTypes.BetTypeCnt));\r\n        if(gameState == 2)\r\n        {\r\n            startNextRound();\r\n        }\r\n        totalGameBets = totalGameBets.add(msg.value);\r\n        BetTypes betType = BetTypes(btype);\r\n        if(betType == BetTypes.Big)\r\n        {\r\n            mapBig.add_or_insert(uint(msg.sender),msg.value);\r\n            bigBets = bigBets.add(msg.value);\r\n        }\r\n        else if(betType == BetTypes.Small)\r\n        {\r\n            mapSmall.add_or_insert(uint(msg.sender),msg.value);\r\n            smallBets = smallBets.add(msg.value);\r\n        }\r\n        else if(betType == BetTypes.Triple)\r\n        {\r\n            require(numBet\u003c7);\r\n            mapTriple[numBet].add_or_insert(uint(msg.sender),msg.value);\r\n        }\r\n        else if(betType == BetTypes.EachDouble)\r\n        {\r\n            require(numBet\u003e0 \u0026\u0026 numBet\u003c7);\r\n            mapDouble[numBet-1].add_or_insert(uint(msg.sender),msg.value);\r\n        }\r\n        else if(betType == BetTypes.Sum)\r\n        {\r\n            require(numBet\u003e=4 \u0026\u0026 numBet\u003c=17);\r\n            mapSum[numBet-4].add_or_insert(uint(msg.sender),msg.value);\r\n        }\r\n        else if(betType == BetTypes.OneNum)\r\n        {\r\n            require(numBet\u003e0 \u0026\u0026 numBet\u003c7);\r\n            mapOne[numBet-1].add_or_insert(uint(msg.sender),msg.value);\r\n        }\r\n        else if(betType == BetTypes.TwoNum)\r\n        {\r\n            require(numBet\u003e=1 \u0026\u0026 numBet\u003c=15);\r\n            mapTwo[numBet-1].add_or_insert(uint(msg.sender),msg.value);\r\n        }\r\n        systemBalance = address(this).balance;\r\n        lastBetTime = now;\r\n        startTime = now;\r\n        emit PlayerBet(msg.sender,round,btype,numBet,msg.value);\r\n    }\r\n    function calcBetTwoResult(uint8 small ,uint8 big) internal\r\n    {\r\n        if(small \u003e big)\r\n        {\r\n            uint8 temp = small;\r\n            small = big;\r\n            big = temp;\r\n        }\r\n        uint8 calced = uint8(small*10+big);\r\n        uint8 idx = getTwoNumIdxByCalced(calced);\r\n        IterableMapping.itmap storage mapWin = mapTwo[idx];\r\n        for (uint i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n        {\r\n            (uint key, uint value) = mapWin.iterate_get(i);\r\n            mapPlayerRewards.add_or_insert(key,value*6);\r\n            totalWinBets = totalWinBets.add(value*6);\r\n        }\r\n    }\r\n    function calcBetOneResult(uint8 one,uint8 two,uint8 three) internal\r\n    {\r\n        uint i = 0;\r\n        uint key = 0;\r\n        uint value = 0;\r\n        if(one == two \u0026\u0026 one == three)\r\n        {\r\n            IterableMapping.itmap storage mapWin = mapOne[one-1];\r\n            for (i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                ( key,  value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*4);\r\n                totalWinBets = totalWinBets.add(value*4);\r\n            }\r\n        }\r\n        bool bTwoSame = false;\r\n        uint8 sameNum = 0;\r\n        uint8 other = 0;\r\n        if(one == two \u0026\u0026 one != three)\r\n        {\r\n            bTwoSame = true;\r\n            sameNum = one;\r\n            other = three;\r\n        }\r\n        else if(two == three \u0026\u0026 one != three)\r\n        {\r\n            bTwoSame = true;\r\n            other = one;\r\n            sameNum = two;\r\n        }\r\n        else if(one == three \u0026\u0026 one != two)\r\n        {\r\n            bTwoSame = true;\r\n            sameNum = one;\r\n            other = two;\r\n        }\r\n        if(bTwoSame)\r\n        {\r\n            IterableMapping.itmap storage mapWin = mapOne[sameNum-1];\r\n            for (i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                (key, value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*3);\r\n                totalWinBets = totalWinBets.add(value*3);\r\n            }\r\n\r\n            mapWin = mapOne[other-1];\r\n            for (i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                (key, value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*2);\r\n                totalWinBets = totalWinBets.add(value*2);\r\n            }\r\n        }\r\n        if(one!=two \u0026\u0026 one!=three \u0026\u0026 two!=three)\r\n        {\r\n            uint8[3] memory arrNums = [one,two,three];\r\n            for(uint8 j = 0;j\u003c3; j++)\r\n            {\r\n                uint8 num = arrNums[j];\r\n                IterableMapping.itmap storage mapWin = mapOne[num-1];\r\n                for (i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n                {\r\n                    (key, value) = mapWin.iterate_get(i);\r\n                    mapPlayerRewards.add_or_insert(key,value*2);\r\n                    totalWinBets = totalWinBets.add(value*2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function calcBetTwoOrBigSmallResult(uint8 one,uint8 two,uint8 three) internal\r\n    {\r\n        uint i = 0;\r\n        uint key = 0;\r\n        uint value = 0;\r\n        uint8 sum = one + two + three;\r\n        if(!(one == two \u0026\u0026 one == three))\r\n        {\r\n            if(sum\u003e=4 \u0026\u0026 sum\u003c=10)\r\n            {\r\n                for ( i = mapSmall.iterate_start(); mapSmall.iterate_valid(i); i = mapSmall.iterate_next(i))\r\n                {\r\n                    ( key,  value) = mapSmall.iterate_get(i);\r\n                    mapPlayerRewards.add_or_insert(key,value*2);\r\n                    totalWinBets = totalWinBets.add(value*2);\r\n                }\r\n            }\r\n            else if(sum\u003e=11 \u0026\u0026 sum\u003c=17)\r\n            {\r\n                for (i = mapBig.iterate_start(); mapBig.iterate_valid(i); i = mapBig.iterate_next(i))\r\n                {\r\n                    (key, value) = mapBig.iterate_get(i);\r\n                    mapPlayerRewards.add_or_insert(key,value*2);\r\n                    totalWinBets = totalWinBets.add(value*2);\r\n                }\r\n            }\r\n            if(one != two \u0026\u0026 one != three \u0026\u0026 two != three)\r\n            {\r\n                calcBetTwoResult(one,two);\r\n                calcBetTwoResult(one,three);\r\n                calcBetTwoResult(two,three);\r\n            }\r\n            bool bTwoSame = false;\r\n            uint8 small = 0;\r\n            uint8 big = 0;\r\n            if(one == two || two == three)\r\n            {\r\n                bTwoSame = true;\r\n                small = one;\r\n                big = three;\r\n            }\r\n            else if(one == three)\r\n            {\r\n                bTwoSame = true;\r\n                small = one;\r\n                big = two;\r\n            }\r\n            if(bTwoSame)\r\n            {\r\n                calcBetTwoResult(small,big);\r\n            }\r\n        }\r\n    }\r\n    function calcBetSumResult(uint8 sum) internal\r\n    {\r\n        if(sum \u003e= 4 \u0026\u0026 sum \u003c= 17)\r\n        {\r\n            uint8 idx = sum - 4;\r\n            IterableMapping.itmap storage mapWin = mapSum[idx];\r\n            uint8 rate = rateSum[idx];\r\n            for (uint i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                (uint key, uint value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*(rate+1));\r\n                totalWinBets = totalWinBets.add(value*(rate+1));\r\n            }\r\n        }\r\n    }\r\n    function calcBetDoubleResult(uint8 one,uint8 two,uint8 three) internal\r\n    {\r\n        bool isDouble = false;\r\n        uint8 sameNum = 0;\r\n        if(one == two || one == three)\r\n        {\r\n            isDouble = true;\r\n            sameNum = one;\r\n        }\r\n        else if(two == three)\r\n        {\r\n            isDouble = true;\r\n            sameNum = two;\r\n        }\r\n        if(isDouble)\r\n        {\r\n            IterableMapping.itmap storage mapWin = mapDouble[sameNum-1];\r\n            for (uint i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                (uint key, uint value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*9);\r\n                totalWinBets = totalWinBets.add(value*9);\r\n            }\r\n        }\r\n    }\r\n    function calcBetTripleResult(uint8 one,uint8 two,uint8 three) internal\r\n    {\r\n        uint i = 0;\r\n        uint key = 0;\r\n        uint value = 0;\r\n        if(one == two \u0026\u0026 one == three)\r\n        {\r\n            IterableMapping.itmap storage mapWin = mapTriple[0];\r\n            for ( i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                ( key,  value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*25);\r\n                totalWinBets = totalWinBets.add(value*25);\r\n            }\r\n            mapWin = mapTriple[one];\r\n            for (i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                (key, value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*151);\r\n                totalWinBets = totalWinBets.add(value*151);\r\n            }\r\n        }\r\n    }\r\n    function end(string memory curServerSeed,bytes32 nextServerRandom) public\r\n    {\r\n        require((block.number-1) \u003e= endBlockNum,\u0027block number should \u003e= endBlock+1\u0027);\r\n        require(gameState == 0,\u0027gameState is not 0\u0027);\r\n        if(noAdminMode)\r\n        {\r\n            if(owner == msg.sender || adminKey == keccak256(abi.encodePacked(msg.sender)))\r\n            {\r\n                noAdminMode = false;\r\n            }\r\n            else if(now \u003c= startTime + MAX_TIME_PER_GAME)\r\n            {\r\n                require(bytes32(keccak256(abi.encodePacked(curServerSeed))) == serverRandomHash,\u0027server hash is not right.\u0027);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if(now \u003e startTime + MAX_TIME_PER_GAME)\r\n            {\r\n                noAdminMode = true;\r\n            }\r\n            else\r\n            {\r\n                require(owner == msg.sender || adminKey == keccak256(abi.encodePacked(msg.sender)),\u0027msg.sender is not owner or admin.\u0027);\r\n                require(bytes32(keccak256(abi.encodePacked(curServerSeed))) == serverRandomHash,\u0027server hash is not right.\u0027);\r\n            }\r\n        }\r\n        gameState = 1;\r\n        uint checkBlockNum = (endBlockNum + betLimitBlockNum)/2;\r\n        uint base1 = uint(keccak256(abi.encodePacked(uint(blockhash(checkBlockNum)),curServerSeed , totalGameBets)));\r\n        uint8 one = uint8((base1 % 6) + 1);\r\n        uint base2 = uint(keccak256(abi.encodePacked(base1,totalGameBets)));\r\n        uint8 two = uint8((base2 % 6) + 1);\r\n        uint8 three = uint8((uint(keccak256(abi.encodePacked(base2,totalGameBets))) % 6) + 1);\r\n        if(totalGameBets == 0)\r\n        {\r\n            emit EndGame(round,one,two,three);\r\n            clearGameState(nextServerRandom);\r\n            return;\r\n        }\r\n        calcBetOneResult(one,two,three);\r\n        calcBetTwoOrBigSmallResult(one,two,three);\r\n        calcBetSumResult(one + two + three);\r\n        calcBetDoubleResult(one,two,three);\r\n        calcBetTripleResult(one,two,three);\r\n        uint totalCanUse = (address(this).balance \u003e totalCanGetRewards) ?\r\n            (address(this).balance).sub(totalCanGetRewards) : 0;\r\n        if(totalWinBets \u003e 0)\r\n        {\r\n            uint lastWinBets = totalWinBets;\r\n            if(lastWinBets \u003e totalCanUse)\r\n            {\r\n                lastWinBets = totalCanUse;\r\n            }\r\n            calcPlayerRewards(lastWinBets);\r\n        }\r\n        if(totalOweRewards \u003e 0 \u0026\u0026 totalCanUse \u003e totalWinBets \u0026\u0026 totalCanGetRewards \u003c= address(this).balance)\r\n        {\r\n            uint totalCanRepay = (address(this).balance).sub(totalCanGetRewards);\r\n            if(totalCanRepay \u003e poolCache)\r\n            {\r\n                totalCanRepay = poolCache;\r\n            }\r\n            paybackOwePlayerRewards(totalCanRepay);\r\n        }\r\n        paybackBankerProfits();\r\n        retrieveInvest();\r\n        emit EndGame(round,one,two,three);\r\n        clearGameState(nextServerRandom);\r\n        systemBalance = address(this).balance;\r\n    }\r\n    function calcPlayerRewards(uint lastWinBets)\r\n    internal\r\n    {\r\n        for (uint i = mapPlayerRewards.iterate_start(); mapPlayerRewards.iterate_valid(i); i = mapPlayerRewards.iterate_next(i))\r\n        {\r\n            (uint addrWin,uint betCnt) = mapPlayerRewards.iterate_get(i);\r\n            uint canGetReward = 0;\r\n            uint oweReward = 0;\r\n            if(lastWinBets \u003c totalWinBets)\r\n            {\r\n                canGetReward = betCnt.mul(lastWinBets).div(totalWinBets);\r\n                oweReward = betCnt.sub(canGetReward);\r\n            }\r\n            else\r\n            {\r\n                canGetReward = betCnt;\r\n            }\r\n            if(canGetReward \u003e 0)\r\n            {\r\n                mapCanGetRewards.add_or_insert(addrWin,canGetReward);\r\n                totalCanGetRewards = totalCanGetRewards.add(canGetReward);\r\n            }\r\n            if(oweReward \u003e 0)\r\n            {\r\n                mapOweRewards.add_or_insert(addrWin,oweReward);\r\n                totalOweRewards = totalOweRewards.add(oweReward);\r\n            }\r\n        }\r\n    }\r\n    function paybackOwePlayerRewards(uint totalCanRepay)\r\n    internal\r\n    {\r\n        uint canBackReward = totalOweRewards;\r\n        if(canBackReward \u003e totalCanRepay)\r\n        {\r\n            canBackReward = totalCanRepay;\r\n        }\r\n        uint totalOweCount = totalOweRewards;\r\n        uint16 j = 0;\r\n        for(uint i = mapOweRewards.iterate_start(); mapOweRewards.iterate_valid(i); i = mapOweRewards.iterate_next(i))\r\n        {\r\n            if(j \u003e 200)\r\n            {\r\n                break;\r\n            }\r\n            (uint addrPlayer,uint oweCount) = mapOweRewards.iterate_get(i);\r\n            if(oweCount == 0)\r\n            {\r\n                continue;\r\n            }\r\n            uint backCount = 0;\r\n            if(canBackReward \u003c totalOweCount)\r\n            {\r\n                backCount = oweCount.mul(canBackReward).div(totalOweCount);\r\n                if(backCount \u003e oweCount)\r\n                {\r\n                    backCount = oweCount;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                backCount = oweCount;\r\n            }\r\n            if(backCount \u003e totalOweRewards)\r\n            {\r\n                backCount = totalOweRewards;\r\n            }\r\n            mapCanGetRewards.add_or_insert(addrPlayer,backCount);\r\n            mapOweRewards.sub(addrPlayer,backCount);\r\n            totalOweRewards = totalOweRewards.sub(backCount);\r\n            totalCanGetRewards = totalCanGetRewards.add(backCount);\r\n            j++;\r\n        }\r\n    }\r\n    function paybackBankerProfits()\r\n    internal\r\n    {\r\n        uint lastRestBalance = (address(this).balance \u003c totalCanGetRewards) ? 0 :\r\n                (address(this).balance).sub(totalCanGetRewards);\r\n        bool needDec = false;\r\n        if(lastRestBalance \u003e 0)\r\n        {\r\n            if(lastRestBalance \u003e poolCache)\r\n            {\r\n                if(Address.isContract(addrInvest))\r\n                {\r\n                    bytes memory payload = abi.encodeWithSignature(\"buy()\");\r\n                    (bool bSuc,) = addrInvest.call.value(lastRestBalance.sub(poolCache))(payload);\r\n                    if(bSuc)\r\n                    {\r\n                        isInvested = true;\r\n                    }\r\n                }\r\n                if(poolCache.add(1e18) \u003c= POOL_MAX)\r\n                {\r\n                    poolCache = poolCache.add(1e18);\r\n                }\r\n            }\r\n            else if((lastRestBalance + 1e18) \u003c= poolCache)\r\n            {\r\n                needDec = true;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            needDec = true;\r\n        }\r\n        if(needDec \u0026\u0026 poolCache.sub(1e18) \u003e= POOL_MIN)\r\n        {\r\n            poolCache = poolCache.sub(1e18);\r\n        }\r\n    }\r\n    function retrieveInvest()\r\n    internal\r\n    {\r\n        if(totalOweRewards \u003e 0 \u0026\u0026 isInvested \u0026\u0026 Address.isContract(addrInvest))\r\n        {\r\n            bytes memory payload = abi.encodeWithSignature(\"exit()\");\r\n            (bool bSuc,) = addrInvest.call(payload);\r\n            if(bSuc)\r\n            {\r\n                isInvested = false;\r\n            }\r\n        }\r\n    }\r\n    function extractPlayerRewards(uint rewards, bool all) nonReentrant() public\r\n    {\r\n        uint addrPlayer = uint(msg.sender);\r\n        uint canGetRewards = mapCanGetRewards.data[addrPlayer].value;\r\n        if(all)\r\n        {\r\n            rewards = canGetRewards;\r\n        }\r\n        require(rewards \u003e 0 \u0026\u0026 rewards \u003c= canGetRewards);\r\n        if(rewards \u003e totalCanGetRewards)\r\n        {\r\n            rewards = totalCanGetRewards;\r\n        }\r\n        mapCanGetRewards.sub(addrPlayer,rewards);\r\n        if(rewards == canGetRewards)\r\n        {\r\n            mapCanGetRewards.remove(addrPlayer);\r\n        }\r\n        totalCanGetRewards = totalCanGetRewards.sub(rewards);\r\n        systemBalance = address(this).balance - rewards;\r\n        msg.sender.transfer(rewards);\r\n    }\r\n    function clearGameState(bytes32 nextServerRandom) internal\r\n    {\r\n        mapBig.clear();\r\n        mapSmall.clear();\r\n        uint8 i = 0;\r\n        for(i=0; i\u003c7; i++)\r\n        {\r\n            mapTriple[i].clear();\r\n        }\r\n        for(i=0; i\u003c6; i++)\r\n        {\r\n            mapDouble[i].clear();\r\n        }\r\n        for(i=0; i\u003c14; i++)\r\n        {\r\n            mapSum[i].clear();\r\n        }\r\n        for(i=0; i\u003c6; i++)\r\n        {\r\n            mapOne[i].clear();\r\n        }\r\n        for(i=0; i\u003c15; i++)\r\n        {\r\n            mapTwo[i].clear();\r\n        }\r\n        mapPlayerRewards.clear();\r\n        totalGameBets = 0;\r\n        totalWinBets = 0;\r\n        bigBets = 0;\r\n        smallBets = 0;\r\n        serverRandomHash = nextServerRandom;\r\n        gameState = 2;\r\n        round++;\r\n    }\r\n    function startNextRound() internal\r\n    {\r\n        startBlockNum = block.number;\r\n        startTime = now;\r\n        endBlockNum = startBlockNum + gameDurationBlocks;\r\n        betLimitBlockNum = startBlockNum + gameLimitBlocks;\r\n        gameState = 0;\r\n    }\r\n    function () payable external\r\n    {\r\n        require(msg.sender == addrInvest);\r\n    }\r\n}\r\n"},"IterableMapping.sol":{"content":"pragma solidity ^0.5.8;\r\nimport \"./SafeMath.sol\";\r\nlibrary IterableMapping\r\n{\r\n    using SafeMath for uint;\r\n    struct itmap\r\n    {\r\n        mapping(uint =\u003e IndexValue) data;\r\n        KeyFlag[] keys;\r\n        uint size;\r\n    }\r\n    struct IndexValue { uint keyIndex; uint value; }\r\n    struct KeyFlag { uint key; bool deleted; }\r\n    function insert(itmap storage self, uint key, uint value) public returns (bool replaced)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        self.data[key].value = value;\r\n        if (keyIndex \u003e 0)\r\n            return true;\r\n        else\r\n        {\r\n            keyIndex = self.keys.length++;\r\n            self.data[key].keyIndex = keyIndex + 1;\r\n            self.keys[keyIndex].key = key;\r\n            self.size++;\r\n            return false;\r\n        }\r\n    }\r\n    function add_or_insert(itmap storage self, uint key, uint value) public returns (bool added)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n\r\n        if (keyIndex \u003e 0)\r\n        {\r\n            self.data[key].value = self.data[key].value.add(value);\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            self.data[key].value = value;\r\n            keyIndex = self.keys.length++;\r\n            self.data[key].keyIndex = keyIndex + 1;\r\n            self.keys[keyIndex].key = key;\r\n            self.size++;\r\n            return false;\r\n        }\r\n    }\r\n    function sub(itmap storage self, uint key, uint value) public returns (bool subbed)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n\r\n        if (keyIndex \u003e 0)\r\n        {\r\n            self.data[key].value = self.data[key].value.sub(value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function remove(itmap storage self, uint key) public returns (bool success)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        if (keyIndex == 0)\r\n            return false;\r\n        delete self.data[key];\r\n        self.keys[keyIndex - 1].deleted = true;\r\n        self.size --;\r\n    }\r\n\r\n    function clear(itmap storage self) public\r\n    {\r\n        uint len = self.keys.length;\r\n        for(uint i = 0; i\u003clen; i++)\r\n        {\r\n            if(!self.keys[i].deleted)\r\n            {\r\n                delete self.data[self.keys[i].key];\r\n            }\r\n        }\r\n        self.keys.length = 0;\r\n        self.size = 0;\r\n    }\r\n    function contains(itmap storage self, uint key) public view returns (bool)\r\n    {\r\n        return self.data[key].keyIndex \u003e 0;\r\n    }\r\n    function iterate_start(itmap storage self) public view returns (uint keyIndex)\r\n    {\r\n        return iterate_next(self, uint(-1));\r\n    }\r\n    function iterate_valid(itmap storage self, uint keyIndex) public view returns (bool)\r\n    {\r\n        return keyIndex \u003c self.keys.length;\r\n    }\r\n    function iterate_next(itmap storage self, uint keyIndex) public view returns (uint r_keyIndex)\r\n    {\r\n        keyIndex++;\r\n        while (keyIndex \u003c self.keys.length \u0026\u0026 self.keys[keyIndex].deleted)\r\n            keyIndex++;\r\n        return keyIndex;\r\n    }\r\n    function iterate_get(itmap storage self, uint keyIndex) public view returns (uint key, uint value)\r\n    {\r\n        key = self.keys[keyIndex].key;\r\n        value = self.data[key].value;\r\n    }\r\n}\r\n"},"ReentrancyGuard.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n * available, which can be aplied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"},"WeFairPlayInvestment.sol":{"content":"pragma solidity ^0.5.8;\r\nimport \"./SafeMath.sol\";\r\nimport \"./IterableMapping.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\ncontract WeFairPlayInvestment is ReentrancyGuard{\r\n    using SafeMath for uint;\r\n    using IterableMapping for IterableMapping.itmap;\r\n    modifier onlyBagholders() {\r\n        require(myTokens() \u003e 0,\u0027msg.sender should have tokens.\u0027);\r\n        _;\r\n    }\r\n    modifier onlyOwner()\r\n    {\r\n        require(owner == msg.sender,\u0027msg.sender is not owner.\u0027);\r\n        _;\r\n    }\r\n    modifier onlyAdministrator(){\r\n        require(owner == msg.sender || administrators[keccak256(abi.encodePacked(msg.sender))]\r\n            ,\u0027msg.sender is not owner or admin.\u0027);\r\n        _;\r\n    }\r\n    modifier onlyOperators(){\r\n        require(mapOperatorStocks_.contains(uint(msg.sender))\r\n        \u0026\u0026 mapOperatorStocks_.data[uint(msg.sender)].value \u003e 0,\u0027msg.sender should have stocks.\u0027);\r\n        _;\r\n    }\r\n    modifier notEarlyWhale(){\r\n        require(!onlyAmbassadors,\u0027now should not early whale stage.\u0027);\r\n        _;\r\n    }\r\n    modifier notEndStage(){\r\n        require(!isEndStage,\u0027now should not end stage.\u0027);\r\n        _;\r\n    }\r\n    modifier antiEarlyWhale(uint256 _amountOfEthereum){\r\n        if(!onlyAmbassadors)\r\n        {\r\n            _;\r\n            return;\r\n        }\r\n        address _customerAddress = msg.sender;\r\n        if( onlyAmbassadors \u0026\u0026 ((address(this).balance - originalBalance) \u003c ambassadorQuota_ )){\r\n            require(\r\n                ambassadors_[_customerAddress] == true \u0026\u0026\r\n                (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) \u003c= ambassadorMaxPurchase_\r\n                ,\u0027msg.sender is not a ambassador or has reach buy limit.\u0027\r\n            );\r\n            ambassadorAccumulatedQuota_[_customerAddress] = ambassadorAccumulatedQuota_[_customerAddress].add(_amountOfEthereum);\r\n            _;\r\n        } else {\r\n            onlyAmbassadors = false;\r\n            _;\r\n        }\r\n    }\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted\r\n    );\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned\r\n    );\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n    string public name = \"WeFairPlayCoin\";\r\n    string public symbol = \"WFP\";\r\n    uint8 constant public decimals = 18;\r\n    uint8 constant internal dividendFee_ = 20;\r\n    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\r\n    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\r\n    mapping(address =\u003e bool) internal ambassadors_;\r\n    uint256 constant internal ambassadorMaxPurchase_ = 1 ether;\r\n    uint256 constant internal ambassadorQuota_ = 10 ether;\r\n    uint originalBalance;\r\n    mapping(address =\u003e uint256) internal tokenBalanceLedger_;\r\n    mapping(address =\u003e uint256) internal ambassadorAccumulatedQuota_;\r\n    uint256 internal tokenSupply_ = 0;\r\n    IterableMapping.itmap mapOperatorRewards_;\r\n    IterableMapping.itmap mapOperatorStocks_;\r\n    uint totalOperatorRewards;\r\n    uint256 constant public totalStocks_ = 10000;\r\n    uint constant internal stockLockTime = 1 days;\r\n    struct StockTransInfo { uint stocks; uint price; uint endTime;}\r\n    mapping(address =\u003e mapping(address =\u003e StockTransInfo)) mapStockTrans;\r\n    mapping(address =\u003e uint) mapLockStocks;\r\n    uint lastActiveTime;\r\n    uint constant internal ENTER_END_DURATION = 2 * 4 weeks;//2 * 4 weeks;\r\n    bool public isEndStage;\r\n    uint public enterEndTime;\r\n    uint constant internal END_STAGE_DURATION = 4 weeks;//4 weeks;\r\n    address owner;\r\n    mapping(bytes32 =\u003e bool) public administrators;\r\n    bool public onlyAmbassadors = true;\r\n    constructor()\r\n    public\r\n    {\r\n        owner = msg.sender;\r\n        administrators[0x6e87e5c3130679f898089256718f36b117cb685debd8d2511298b3f0dabadf1e] = true;\r\n        ambassadors_[0x1Fd11576EAbe588115aA47E52904C3221E4c0a95] = true;\r\n        ambassadors_[0x1DC93b1bE8b97959f5B07d6113A909F9C89D3361] = true;\r\n        ambassadors_[0x135de610Bd907e9B6aB3d93753d6E59De6ef886B] = true;\r\n        ambassadors_[0x5f5B2BB60EBDa86C9efc9a4cA01a7756554c2Fe5] = true;\r\n        ambassadors_[0x89EE32611CcFa44044cc1F0d0ECC53E53Aa3C634] = true;\r\n        ambassadors_[0x16B0e5F320Cd30028caFf791aC08dF830B52e61d] = true;\r\n        ambassadors_[0xA9d47178067568A5C84c0849A7e1b47139DA6a7c] = true;\r\n        ambassadors_[0x0d7e1a43e666714A1B7B8F4e5eD9Ac86597078A0] = true;\r\n        ambassadors_[0xc33F6Ca865D8Ec8fE00037f64B8dbe6cBD751555] = true;\r\n        ambassadors_[0x324bC683445fa86CFc85b49c1eD4d2bdDc6409aE] = true;\r\n        mapOperatorStocks_.add_or_insert(uint(owner),totalStocks_);\r\n        originalBalance = address(this).balance;\r\n    }\r\n    function ambassadorLeftLimit()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        require(ambassadors_[msg.sender] == true,\u0027msg.sender is not a ambassador.\u0027);\r\n        return ambassadorMaxPurchase_.sub(ambassadorAccumulatedQuota_[msg.sender]);\r\n    }\r\n    function isAmbassador()\r\n    view\r\n    public\r\n    returns(bool)\r\n    {\r\n        return ambassadors_[msg.sender];\r\n    }\r\n    function buy()\r\n    public\r\n    payable\r\n    {\r\n        purchaseTokens(msg.value);\r\n    }\r\n    function()\r\n    payable\r\n    external\r\n    {\r\n        purchaseTokens(msg.value);\r\n    }\r\n    function exit()\r\n    public\r\n    {\r\n        uint256 _tokens = tokenBalanceLedger_[msg.sender];\r\n        if(_tokens \u003e 0) sell(_tokens);\r\n    }\r\n    function sell(uint256 _amountOfTokens)\r\n    nonReentrant()\r\n    notEarlyWhale()\r\n    onlyBagholders()\r\n    public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        require(_amountOfTokens \u003c= tokenBalanceLedger_[_customerAddress],\u0027seller have not enough tokens.\u0027);\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 _ethereum = tokensToEthereum_(_tokens);\r\n        uint256 _dividends = _ethereum.div(dividendFee_);\r\n        uint256 _taxedEthereum = _ethereum.sub(_dividends);\r\n        sendOperatorRewards_(_dividends);\r\n        tokenSupply_ = tokenSupply_.sub( _tokens);\r\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress].sub( _tokens);\r\n        lastActiveTime = now;\r\n        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);\r\n        msg.sender.transfer(_taxedEthereum);\r\n    }\r\n    function _transfer(address _from, address _toAddress, uint _amountOfTokens)\r\n    notEarlyWhale()\r\n    notEndStage()\r\n    internal\r\n    {\r\n        address _customerAddress = _from;\r\n        require(_amountOfTokens \u003c= tokenBalanceLedger_[_customerAddress],\u0027seller have not enough tokens.\u0027);\r\n        uint256 _tokenFee = _amountOfTokens.div(dividendFee_);\r\n        uint256 _taxedTokens = _amountOfTokens.sub(_tokenFee);\r\n        uint256 _dividends = tokensToEthereum_(_tokenFee);\r\n        tokenSupply_ = tokenSupply_.sub(_tokenFee);\r\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress].sub( _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = tokenBalanceLedger_[_toAddress].add( _taxedTokens);\r\n        sendOperatorRewards_(_dividends);\r\n        lastActiveTime = now;\r\n        emit Transfer(_customerAddress, _toAddress, _taxedTokens);\r\n    }\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n    onlyBagholders()\r\n    public\r\n    returns(bool)\r\n    {\r\n        _transfer(msg.sender, _toAddress, _amountOfTokens);\r\n        return true;\r\n    }\r\n    function isAdministrator()\r\n    view\r\n    public\r\n    returns(bool)\r\n    {\r\n        return (owner == msg.sender || administrators[keccak256(abi.encodePacked(msg.sender))]);\r\n    }\r\n    function disableInitialStage()\r\n    onlyOwner()\r\n    public\r\n    {\r\n        onlyAmbassadors = false;\r\n    }\r\n    function setAdministrator(bytes32 _identifier, bool _status)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        administrators[_identifier] = _status;\r\n    }\r\n    function setOwner(address payable newOwner) onlyOwner public\r\n    {\r\n        owner = newOwner;\r\n    }\r\n    function canEnterEndStage() view public returns(bool)\r\n    {\r\n        return (lastActiveTime \u003e 0 \u0026\u0026 now - lastActiveTime \u003e ENTER_END_DURATION);\r\n    }\r\n    function enterEndStage() onlyOwner public\r\n    {\r\n        require(lastActiveTime \u003e 0 \u0026\u0026 now - lastActiveTime \u003e ENTER_END_DURATION,\"Last transaction should be 8 weeks ago.\");\r\n        isEndStage = true;\r\n        enterEndTime = now;\r\n    }\r\n    function restEndTime() view public returns(int)\r\n    {\r\n        if(isEndStage \u0026\u0026 enterEndTime \u003e 0)\r\n        {\r\n            uint endTimestamp = enterEndTime.add(END_STAGE_DURATION);\r\n            if(now \u003c endTimestamp)\r\n            {\r\n                return int(endTimestamp.sub(now));\r\n            }\r\n            else\r\n            {\r\n                return 0;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n    function kill() onlyOwner public\r\n    {\r\n        require(isEndStage \u0026\u0026 enterEndTime \u003e 0 \u0026\u0026 now - enterEndTime \u003e END_STAGE_DURATION\r\n            ,\u0027now is not end stage or not enter end stage or now is not reach end stage duration.\u0027);\r\n        selfdestruct(toPayable(owner));\r\n    }\r\n    function setName(string memory _name)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        name = _name;\r\n    }\r\n    function setSymbol(string memory _symbol)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        symbol = _symbol;\r\n    }\r\n    function totalEthereumBalance()\r\n    public\r\n    view\r\n    returns(uint)\r\n    {\r\n        return address(this).balance.sub(totalOperatorRewards);\r\n    }\r\n    function totalSupply()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return tokenSupply_;\r\n    }\r\n    function myTokens()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return balanceOf(msg.sender);\r\n    }\r\n    function balanceOf(address _customerAddress)\r\n    view\r\n    public\r\n    returns(uint256)\r\n    {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n    function sellPrice()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = _ethereum.div( dividendFee_  );\r\n            uint256 _taxedEthereum = _ethereum.sub( _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n    function buyPrice()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _taxedEthereum = _ethereum.mul(dividendFee_).div(dividendFee_-1);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n    function calculateTokensReceived(uint256 _ethereumToSpend)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 _dividends = _ethereumToSpend.div( dividendFee_);\r\n        uint256 _taxedEthereum = _ethereumToSpend.sub( _dividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        return _amountOfTokens;\r\n    }\r\n    function calculateEthereumReceived(uint256 _tokensToSell)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        require(_tokensToSell \u003c= tokenSupply_,\u0027token to sell should less than total tokens.\u0027);\r\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\r\n        uint256 _dividends = _ethereum.div( dividendFee_);\r\n        uint256 _taxedEthereum = _ethereum.sub( _dividends);\r\n        return _taxedEthereum;\r\n    }\r\n    function purchaseTokens(uint256 _incomingEthereum)\r\n    antiEarlyWhale(_incomingEthereum)\r\n    notEndStage()\r\n    internal\r\n    returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = _incomingEthereum.div( dividendFee_);\r\n        uint256 _taxedEthereum = _incomingEthereum.sub( _dividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        require(_amountOfTokens \u003e 0 \u0026\u0026 (_amountOfTokens.add(tokenSupply_) \u003e tokenSupply_)\r\n            ,\u0027to buy tokens should \u003e0 and not cause total token overflow max uint.\u0027);\r\n        sendOperatorRewards_(_dividends);\r\n        if(tokenSupply_ \u003e 0){\r\n            tokenSupply_ = tokenSupply_.add( _amountOfTokens);\r\n        } else {\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress].add( _amountOfTokens);\r\n        lastActiveTime = now;\r\n        emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens);\r\n        return _amountOfTokens;\r\n    }\r\n    function sendOperatorRewards_(uint256 _ethereum)\r\n    internal\r\n    {\r\n        uint restRewards = _ethereum;\r\n        for(uint i = mapOperatorStocks_.iterate_start(); mapOperatorStocks_.iterate_valid(i) \u0026\u0026 restRewards\u003e0; i = mapOperatorStocks_.iterate_next(i))\r\n        {\r\n            (uint addrOperator,uint stocks) = mapOperatorStocks_.iterate_get(i);\r\n            if(stocks == 0)\r\n            {\r\n                continue;\r\n            }\r\n            uint256 rewards = _ethereum.mul(stocks).div(totalStocks_);\r\n            if(rewards \u003e restRewards)\r\n            {\r\n                rewards = restRewards;\r\n            }\r\n            restRewards = restRewards.sub(rewards);\r\n            mapOperatorRewards_.add_or_insert(addrOperator,rewards);\r\n            totalOperatorRewards = totalOperatorRewards.add(rewards);\r\n        }\r\n    }\r\n    function getOperatorStocks_()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        return mapOperatorStocks_.data[uint(msg.sender)].value;\r\n    }\r\n    function getOperatorRewards_()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        return mapOperatorRewards_.data[uint(msg.sender)].value;\r\n    }\r\n    function withDrawRewards_()\r\n    nonReentrant()\r\n    notEarlyWhale()\r\n    onlyOperators()\r\n    public\r\n    {\r\n        uint player = uint(msg.sender);\r\n        require(mapOperatorRewards_.contains(player),\u0027stock holder should has rewards.\u0027);\r\n        uint totalRewards = mapOperatorRewards_.data[player].value;\r\n        require(totalRewards\u003e0 \u0026\u0026 totalRewards \u003c= totalOperatorRewards \u0026\u0026 totalRewards \u003c= address(this).balance\r\n            ,\u0027rewards should \u003e0 and less than total rewards and less than contract balance.\u0027);\r\n        mapOperatorRewards_.sub(player,totalRewards);\r\n        totalOperatorRewards = totalOperatorRewards.sub(totalRewards);\r\n        msg.sender.transfer(totalRewards);\r\n    }\r\n    function transferStocks_(address receiver,uint amountStock)\r\n    nonReentrant()\r\n    onlyOperators()\r\n    notEarlyWhale()\r\n    notEndStage()\r\n    public\r\n    {\r\n        uint sender = uint(msg.sender);\r\n        uint restStocks = uint(mapOperatorStocks_.data[sender].value).sub(mapLockStocks[msg.sender]);\r\n        require(amountStock \u003c= restStocks\r\n            ,\u0027to transfer stock amount should less than player stocks except locked stocks.\u0027);\r\n        mapOperatorStocks_.add_or_insert(uint(receiver),amountStock);\r\n        mapOperatorStocks_.sub(sender,amountStock);\r\n        if(mapOperatorStocks_.data[sender].value == 0)\r\n        {\r\n            uint totalRewards = mapOperatorRewards_.data[sender].value;\r\n            mapOperatorStocks_.remove(sender);\r\n            mapOperatorRewards_.remove(sender);\r\n            if(totalRewards \u003e 0)\r\n            {\r\n                if(totalRewards \u003e totalOperatorRewards)\r\n                {\r\n                    totalRewards = totalOperatorRewards;\r\n                }\r\n                totalOperatorRewards = totalOperatorRewards.sub(totalRewards);\r\n                address(sender).transfer(totalRewards);\r\n            }\r\n        }\r\n    }\r\n    function createStockTransaction(address _receiver, uint _stocks, uint _price)\r\n    notEarlyWhale()\r\n    notEndStage()\r\n    public\r\n    {\r\n        uint restStocks = uint(mapOperatorStocks_.data[uint(msg.sender)].value).sub(mapLockStocks[msg.sender]);\r\n        require(_stocks \u003e 0 \u0026\u0026 _stocks \u003c= restStocks\r\n            ,\u0027stock to transact should \u003e0 and less than player stocks except locked stocks.\u0027);\r\n        require(_price \u003e 0,\u0027price should \u003e0.\u0027);\r\n        StockTransInfo storage info = mapStockTrans[msg.sender][_receiver];\r\n        require(info.stocks == 0,\u0027transaction to receiver has exist.\u0027);\r\n        mapLockStocks[msg.sender] = mapLockStocks[msg.sender].add(_stocks);\r\n        info.stocks = _stocks;\r\n        info.price = _price;\r\n        info.endTime = now + stockLockTime;\r\n    }\r\n    function getMyLockStocks()\r\n    public\r\n    view\r\n    returns(uint)\r\n    {\r\n        return mapLockStocks[msg.sender];\r\n    }\r\n    function queryStocksTransactionTo(address receiver)\r\n    public\r\n    view\r\n    returns(uint _stocks, uint _price, uint _endTime)\r\n    {\r\n        StockTransInfo storage info = mapStockTrans[msg.sender][receiver];\r\n        _stocks = info.stocks;\r\n        _price = info.price;\r\n        _endTime = info.endTime;\r\n    }\r\n    function queryStocksTransactionFrom(address seller)\r\n    public\r\n    view\r\n    returns(uint _stocks, uint _price, uint _endTime)\r\n    {\r\n        StockTransInfo storage info = mapStockTrans[seller][msg.sender];\r\n        _stocks = info.stocks;\r\n        _price = info.price;\r\n        _endTime = info.endTime;\r\n    }\r\n    function confirmStocksTransaction(address payable seller, bool agreed)\r\n    nonReentrant()\r\n    notEarlyWhale()\r\n    payable\r\n    public\r\n    {\r\n        StockTransInfo storage info = mapStockTrans[seller][msg.sender];\r\n        require(info.stocks \u003e 0 \u0026\u0026 now \u003c info.endTime,\u0027transact stocks is not \u003e0 or now has reached end time.\u0027);\r\n        if(agreed)\r\n        {\r\n            require(msg.value == info.price,\u0027msg.sender paid ether is not equal to the price.\u0027);\r\n            mapOperatorStocks_.add_or_insert(uint(msg.sender),info.stocks);\r\n            mapOperatorStocks_.sub(uint(seller),info.stocks);\r\n        }\r\n        mapLockStocks[seller] = mapLockStocks[seller].sub(info.stocks);\r\n        if(mapLockStocks[seller] == 0)\r\n        {\r\n            delete mapLockStocks[seller];\r\n        }\r\n        delete mapStockTrans[seller][msg.sender];\r\n        if(agreed)\r\n        {\r\n            uint sender = uint(seller);\r\n            uint transValue = msg.value;\r\n            if(mapOperatorStocks_.data[sender].value == 0)\r\n            {\r\n                uint totalRewards = mapOperatorRewards_.data[sender].value;\r\n                mapOperatorStocks_.remove(sender);\r\n                mapOperatorRewards_.remove(sender);\r\n                if(totalRewards \u003e 0)\r\n                {\r\n                    if(totalRewards \u003e totalOperatorRewards)\r\n                    {\r\n                        totalRewards = totalOperatorRewards;\r\n                    }\r\n                    totalOperatorRewards = totalOperatorRewards.sub(totalRewards);\r\n                    transValue = transValue.add(totalRewards);\r\n                }\r\n            }\r\n            seller.transfer(transValue);\r\n        }\r\n    }\r\n    function retrieveStocksBack(address receiver)\r\n    notEarlyWhale()\r\n    public\r\n    {\r\n        address seller = msg.sender;\r\n        StockTransInfo storage info = mapStockTrans[seller][receiver];\r\n        require(info.stocks \u003e 0 \u0026\u0026 now \u003e info.endTime,\u0027transact stocks is not \u003e0 or now has not reach end time.\u0027);\r\n        mapLockStocks[seller] = mapLockStocks[seller].sub(info.stocks);\r\n        if(mapLockStocks[seller] == 0)\r\n        {\r\n            delete mapLockStocks[seller];\r\n        }\r\n        delete mapStockTrans[seller][msg.sender];\r\n    }\r\n    function ethereumToTokens_(uint256 _ethereum)\r\n    internal\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived =\r\n        (\r\n        (sqrt\r\n        (\r\n            (_tokenPriceInitial**2)\r\n            +\r\n            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\r\n            +\r\n            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\r\n            +\r\n            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\r\n        )\r\n        ).sub( _tokenPriceInitial\r\n        )\r\n        /(tokenPriceIncremental_)\r\n        )-(tokenSupply_)\r\n        ;\r\n        return _tokensReceived;\r\n    }\r\n    function tokensToEthereum_(uint256 _tokens)\r\n    internal\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n        (\r\n        (\r\n        (\r\n        (\r\n        tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\r\n        )-tokenPriceIncremental_\r\n        )*(tokens_ - 1e18)\r\n        ).sub((tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\r\n        )\r\n        /1e18);\r\n        return _etherReceived;\r\n    }\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z \u003c y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n"}}
