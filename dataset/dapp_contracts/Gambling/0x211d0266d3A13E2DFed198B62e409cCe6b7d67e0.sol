{"Address.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Collection of functions related to the address type,\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract\u0027s constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * \u003e It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n}\n"},"BigOrSmall.sol":{"content":"pragma solidity ^0.5.8;\r\nimport \"./SafeMath.sol\";\r\nimport \"./IterableMapping.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\nimport \"./Address.sol\";\r\nimport \"./WeFairPlayInvestment.sol\";\r\ncontract BigOrSmall is ReentrancyGuard {\r\n    using SafeMath for uint;\r\n    using IterableMapping for IterableMapping.itmap;\r\n    enum BetTypes {\r\n        Big,\r\n        Small,\r\n        Triple,\r\n        EachDouble,\r\n        Sum,\r\n        OneNum,\r\n        TwoNum,\r\n        BetTypeCnt\r\n    }\r\n    address owner;\r\n    mapping(bytes32 =\u003e bool) public administrators;\r\n    bool public noAdminMode;\r\n    address payable addrInvest;\r\n    uint public poolCache = 1e18;//1e18;\r\n    uint public totalCanGetRewards;\r\n    uint public totalOweRewards;\r\n    IterableMapping.itmap mapBig;\r\n    IterableMapping.itmap mapSmall;\r\n    IterableMapping.itmap[7] mapTriple;\r\n    IterableMapping.itmap[6] mapDouble;\r\n    IterableMapping.itmap[14] mapSum;\r\n    uint8[14] rateSum = [uint8(50),18,14,12,8,6,6,6,6,8,12,14,18,50];\r\n    IterableMapping.itmap[6] mapOne;\r\n    IterableMapping.itmap[15] mapTwo;\r\n    IterableMapping.itmap mapPlayerRewards;\r\n    IterableMapping.itmap mapCanGetRewards;\r\n    IterableMapping.itmap mapOweRewards;\r\n    uint public totalGameBets;\r\n    uint totalWinBets;\r\n    uint public bigBets;\r\n    uint public smallBets;\r\n    uint public startBlockNum;\r\n    uint startTime;\r\n    uint32 public gameDurationBlocks;\r\n    uint public endBlockNum;\r\n    uint32 public gameLimitBlocks;\r\n    uint public betLimitBlockNum;\r\n    bytes32 serverRandomHash;\r\n    uint public lastBetTime;\r\n    bool isInvested;\r\n    uint public round;\r\n    uint8 public gameState;\r\n    event PlayerBet(address player,uint round,uint ret,uint numBet,uint bet);\r\n    event EndGame(uint round,uint one,uint two,uint three);\r\n    modifier onlyAdministrator()\r\n    {\r\n        require(owner == msg.sender || administrators[keccak256(abi.encodePacked(msg.sender))]);\r\n        _;\r\n    }\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    modifier onlyBetting(){ require((block.number \u003c= betLimitBlockNum) || gameState == 2); _;}\r\n    modifier betsLimit(){ require(msg.value \u003e= 1e16 \u0026\u0026 msg.value \u003c= 5e18); _;}\r\n    constructor(address payable investAddress,uint32 gameDurBlocks,uint32 bLimitBlocks,bytes32 serverRandom) public\r\n    {\r\n        owner = msg.sender;\r\n        administrators[0x6e87e5c3130679f898089256718f36b117cb685debd8d2511298b3f0dabadf1e] = true;\r\n        administrators[0xd15ad95903261a76dd9fe16d4a45a4a6088e12cc3da609e9f9d5735fdc9f462e] = true;\r\n        addrInvest = investAddress;\r\n        serverRandomHash = serverRandom;\r\n        if(gameDurBlocks \u003c 5)\r\n            gameDurBlocks = 5;\r\n        gameDurationBlocks = gameDurBlocks;\r\n        if(bLimitBlocks \u003c 4)\r\n            bLimitBlocks = 4;\r\n        if(bLimitBlocks \u003e gameDurBlocks - 1)\r\n            bLimitBlocks = gameDurBlocks - 1;\r\n        gameLimitBlocks = bLimitBlocks;\r\n        gameState = 3;\r\n    }\r\n    function getTwoNumIdxByCalced(uint8 calced)\r\n    internal\r\n    pure\r\n    returns(uint8)\r\n    {\r\n        if(12 == calced){return 0;}\r\n        else if(13 == calced){return 1;}\r\n        else if(14 == calced){return 2;}\r\n        else if(15 == calced){return 3;}\r\n        else if(16 == calced){return 4;}\r\n        else if(23 == calced){return 5;}\r\n        else if(24 == calced){return 6;}\r\n        else if(25 == calced){return 7;}\r\n        else if(26 == calced){return 8;}\r\n        else if(34 == calced){return 9;}\r\n        else if(35 == calced){return 10;}\r\n        else if(36 == calced){return 11;}\r\n        else if(45 == calced){return 12;}\r\n        else if(46 == calced){return 13;}\r\n        else if(56 == calced){return 14;}\r\n        else {return 15;}\r\n    }\r\n    function isAdministrator()\r\n    view\r\n    public\r\n    returns(bool)\r\n    {\r\n        return (owner == msg.sender || administrators[keccak256(abi.encodePacked(msg.sender))]);\r\n    }\r\n    function setAdministrator(bytes32 _identifier, bool _status) onlyAdministrator  public\r\n    {\r\n        administrators[_identifier] = _status;\r\n        noAdminMode = false;\r\n    }\r\n    function setOwner(address payable newOwner) onlyOwner public\r\n    {\r\n        owner = newOwner;\r\n    }\r\n    function setInvestAddr(address payable addr) onlyOwner public\r\n    {\r\n        address addrOld = addrInvest;\r\n        require(!Address.isContract(addrOld));\r\n        require(Address.isContract(addr));\r\n        addrInvest = addr;\r\n    }\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n    function kill() onlyOwner public\r\n    {\r\n        require(totalOweRewards == 0);\r\n        require(lastBetTime \u003e 0 \u0026\u0026 now.sub(lastBetTime) \u003e 30 days);\r\n        selfdestruct(toPayable(owner));\r\n    }\r\n    function setDurAndBetLimit(uint32 gameDurBlocks,uint32 bLimitBlocks) onlyAdministrator onlyBetting public\r\n    {\r\n        require(gameDurBlocks \u003e= 5\r\n        \u0026\u0026 bLimitBlocks \u003e= 4\r\n            \u0026\u0026 gameDurBlocks-1 \u003e= bLimitBlocks\r\n        );\r\n        gameDurationBlocks = gameDurBlocks;\r\n        gameLimitBlocks = bLimitBlocks;\r\n    }\r\n    function launchGame() onlyAdministrator public\r\n    {\r\n        require(gameState == 3);\r\n        startNextRound();\r\n    }\r\n    function systemOweMyRewards()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        return mapOweRewards.data[uint(msg.sender)].value;\r\n    }\r\n    function myCanGetRewards()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        return mapCanGetRewards.data[uint(msg.sender)].value;\r\n    }\r\n    function bet(uint8 btype,uint8 numBet) onlyBetting betsLimit payable public\r\n    {\r\n        require(btype \u003e= 0 \u0026\u0026  btype \u003c uint8(BetTypes.BetTypeCnt));\r\n        if(gameState == 2)\r\n        {\r\n            startNextRound();\r\n        }\r\n        totalGameBets = totalGameBets.add(msg.value);\r\n        BetTypes betType = BetTypes(btype);\r\n        if(betType == BetTypes.Big)\r\n        {\r\n            mapBig.add_or_insert(uint(msg.sender),msg.value);\r\n            bigBets = bigBets.add(msg.value);\r\n        }\r\n        else if(betType == BetTypes.Small)\r\n        {\r\n            mapSmall.add_or_insert(uint(msg.sender),msg.value);\r\n            smallBets = smallBets.add(msg.value);\r\n        }\r\n        else if(betType == BetTypes.Triple)\r\n        {\r\n            require(numBet\u003c7);\r\n            mapTriple[numBet].add_or_insert(uint(msg.sender),msg.value);\r\n        }\r\n        else if(betType == BetTypes.EachDouble)\r\n        {\r\n            require(numBet\u003e0 \u0026\u0026 numBet\u003c7);\r\n            mapDouble[numBet-1].add_or_insert(uint(msg.sender),msg.value);\r\n        }\r\n        else if(betType == BetTypes.Sum)\r\n        {\r\n            require(numBet\u003e=4 \u0026\u0026 numBet\u003c=17);\r\n            mapSum[numBet-4].add_or_insert(uint(msg.sender),msg.value);\r\n        }\r\n        else if(betType == BetTypes.OneNum)\r\n        {\r\n            require(numBet\u003e0 \u0026\u0026 numBet\u003c7);\r\n            mapOne[numBet-1].add_or_insert(uint(msg.sender),msg.value);\r\n        }\r\n        else if(betType == BetTypes.TwoNum)\r\n        {\r\n            require(numBet\u003e=1 \u0026\u0026 numBet\u003c=15);\r\n            mapTwo[numBet-1].add_or_insert(uint(msg.sender),msg.value);\r\n        }\r\n//        systemBalance = address(this).balance;\r\n        lastBetTime = now;\r\n        startTime = now;\r\n        emit PlayerBet(msg.sender,round,btype,numBet,msg.value);\r\n    }\r\n    function calcBetTwoResult(uint8 small ,uint8 big) internal\r\n    {\r\n        if(small \u003e big)\r\n        {\r\n            uint8 temp = small;\r\n            small = big;\r\n            big = temp;\r\n        }\r\n        uint8 idx = getTwoNumIdxByCalced(uint8(small*10+big));\r\n        IterableMapping.itmap storage mapWin = mapTwo[idx];\r\n        for (uint i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n        {\r\n            (uint key, uint value) = mapWin.iterate_get(i);\r\n            mapPlayerRewards.add_or_insert(key,value*6);\r\n            totalWinBets = totalWinBets.add(value*6);\r\n        }\r\n    }\r\n    function calcBetOneResult(uint8 one,uint8 two,uint8 three) internal\r\n    {\r\n        uint i = 0;\r\n        uint key = 0;\r\n        uint value = 0;\r\n        if(one == two \u0026\u0026 one == three)\r\n        {\r\n            IterableMapping.itmap storage mapWin = mapOne[one-1];\r\n            for (i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                ( key,  value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*4);\r\n                totalWinBets = totalWinBets.add(value*4);\r\n            }\r\n        }\r\n        bool bTwoSame = false;\r\n        uint8 sameNum = 0;\r\n        uint8 other = 0;\r\n        if(one == two \u0026\u0026 one != three)\r\n        {\r\n            bTwoSame = true;\r\n            sameNum = one;\r\n            other = three;\r\n        }\r\n        else if(two == three \u0026\u0026 one != three)\r\n        {\r\n            bTwoSame = true;\r\n            other = one;\r\n            sameNum = two;\r\n        }\r\n        else if(one == three \u0026\u0026 one != two)\r\n        {\r\n            bTwoSame = true;\r\n            sameNum = one;\r\n            other = two;\r\n        }\r\n        if(bTwoSame)\r\n        {\r\n            IterableMapping.itmap storage mapWin = mapOne[sameNum-1];\r\n            for (i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                (key, value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*3);\r\n                totalWinBets = totalWinBets.add(value*3);\r\n            }\r\n\r\n            mapWin = mapOne[other-1];\r\n            for (i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                (key, value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*2);\r\n                totalWinBets = totalWinBets.add(value*2);\r\n            }\r\n        }\r\n        if(one!=two \u0026\u0026 one!=three \u0026\u0026 two!=three)\r\n        {\r\n            uint8[3] memory arrNums = [one,two,three];\r\n            for(uint8 j = 0;j\u003c3; j++)\r\n            {\r\n                uint8 num = arrNums[j];\r\n                IterableMapping.itmap storage mapWin = mapOne[num-1];\r\n                for (i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n                {\r\n                    (key, value) = mapWin.iterate_get(i);\r\n                    mapPlayerRewards.add_or_insert(key,value*2);\r\n                    totalWinBets = totalWinBets.add(value*2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function calcBetTwoOrBigSmallResult(uint8 one,uint8 two,uint8 three) internal\r\n    {\r\n        uint i = 0;\r\n        uint key = 0;\r\n        uint value = 0;\r\n        uint8 sum = one + two + three;\r\n        if(!(one == two \u0026\u0026 one == three))\r\n        {\r\n            if(sum\u003e=4 \u0026\u0026 sum\u003c=10)\r\n            {\r\n                for ( i = mapSmall.iterate_start(); mapSmall.iterate_valid(i); i = mapSmall.iterate_next(i))\r\n                {\r\n                    ( key,  value) = mapSmall.iterate_get(i);\r\n                    mapPlayerRewards.add_or_insert(key,value*2);\r\n                    totalWinBets = totalWinBets.add(value*2);\r\n                }\r\n            }\r\n            else if(sum\u003e=11 \u0026\u0026 sum\u003c=17)\r\n            {\r\n                for (i = mapBig.iterate_start(); mapBig.iterate_valid(i); i = mapBig.iterate_next(i))\r\n                {\r\n                    (key, value) = mapBig.iterate_get(i);\r\n                    mapPlayerRewards.add_or_insert(key,value*2);\r\n                    totalWinBets = totalWinBets.add(value*2);\r\n                }\r\n            }\r\n            if(one != two \u0026\u0026 one != three \u0026\u0026 two != three)\r\n            {\r\n                calcBetTwoResult(one,two);\r\n                calcBetTwoResult(one,three);\r\n                calcBetTwoResult(two,three);\r\n            }\r\n            bool bTwoSame = false;\r\n            uint8 small = 0;\r\n            uint8 big = 0;\r\n            if(one == two || two == three)\r\n            {\r\n                bTwoSame = true;\r\n                small = one;\r\n                big = three;\r\n            }\r\n            else if(one == three)\r\n            {\r\n                bTwoSame = true;\r\n                small = one;\r\n                big = two;\r\n            }\r\n            if(bTwoSame)\r\n            {\r\n                calcBetTwoResult(small,big);\r\n            }\r\n        }\r\n    }\r\n    function calcBetSumResult(uint8 sum) internal\r\n    {\r\n        if(sum \u003e= 4 \u0026\u0026 sum \u003c= 17)\r\n        {\r\n            uint8 idx = sum - 4;\r\n            IterableMapping.itmap storage mapWin = mapSum[idx];\r\n            uint8 rate = rateSum[idx];\r\n            for (uint i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                (uint key, uint value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*(rate+1));\r\n                totalWinBets = totalWinBets.add(value*(rate+1));\r\n            }\r\n        }\r\n    }\r\n    function calcBetDoubleResult(uint8 one,uint8 two,uint8 three) internal\r\n    {\r\n        bool isDouble = false;\r\n        uint8 sameNum = 0;\r\n        if(one == two || one == three)\r\n        {\r\n            isDouble = true;\r\n            sameNum = one;\r\n        }\r\n        else if(two == three)\r\n        {\r\n            isDouble = true;\r\n            sameNum = two;\r\n        }\r\n        if(isDouble)\r\n        {\r\n            IterableMapping.itmap storage mapWin = mapDouble[sameNum-1];\r\n            for (uint i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                (uint key, uint value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*9);\r\n                totalWinBets = totalWinBets.add(value*9);\r\n            }\r\n        }\r\n    }\r\n    function calcBetTripleResult(uint8 one,uint8 two,uint8 three) internal\r\n    {\r\n        uint i = 0;\r\n        uint key = 0;\r\n        uint value = 0;\r\n        if(one == two \u0026\u0026 one == three)\r\n        {\r\n            IterableMapping.itmap storage mapWin = mapTriple[0];\r\n            for ( i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                ( key,  value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*25);\r\n                totalWinBets = totalWinBets.add(value*25);\r\n            }\r\n            mapWin = mapTriple[one];\r\n            for (i = mapWin.iterate_start(); mapWin.iterate_valid(i); i = mapWin.iterate_next(i))\r\n            {\r\n                (key, value) = mapWin.iterate_get(i);\r\n                mapPlayerRewards.add_or_insert(key,value*151);\r\n                totalWinBets = totalWinBets.add(value*151);\r\n            }\r\n        }\r\n    }\r\n    function end(uint curServerSeed,bytes32 nextServerRandom) public\r\n    {\r\n        require((block.number-1) \u003e= endBlockNum);\r\n        require(gameState == 0);\r\n        if(noAdminMode)\r\n        {\r\n            if(owner == msg.sender || administrators[keccak256(abi.encodePacked(msg.sender))])\r\n            {\r\n                noAdminMode = false;\r\n            }\r\n            else if(now \u003c= startTime + (1 days))\r\n            {\r\n                require(bytes32(keccak256(abi.encodePacked(curServerSeed))) == serverRandomHash);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if(now \u003e startTime + (1 days))\r\n            {\r\n                noAdminMode = true;\r\n            }\r\n            else\r\n            {\r\n                require(owner == msg.sender || administrators[keccak256(abi.encodePacked(msg.sender))]);\r\n                require(bytes32(keccak256(abi.encodePacked(curServerSeed))) == serverRandomHash);\r\n            }\r\n        }\r\n        gameState = 1;\r\n        uint checkBlockNum = (endBlockNum + betLimitBlockNum)/2;\r\n        uint hash = uint(blockhash(checkBlockNum));\r\n        uint base1 = hash + curServerSeed + totalGameBets;\r\n        uint8 one = uint8((base1 % 6) + 1);\r\n        uint base2 = hash.div(10) + curServerSeed.div(10) + totalGameBets;\r\n        uint8 two = uint8((base2 % 6) + 1);\r\n        uint8 three = uint8(((hash.div(100) + curServerSeed.div(100) + totalGameBets) % 6) + 1);\r\n        if(totalGameBets == 0)\r\n        {\r\n            emit EndGame(round,one,two,three);\r\n            clearGameState(nextServerRandom);\r\n            return;\r\n        }\r\n        calcBetOneResult(one,two,three);\r\n        calcBetTwoOrBigSmallResult(one,two,three);\r\n        calcBetSumResult(one + two + three);\r\n        calcBetDoubleResult(one,two,three);\r\n        calcBetTripleResult(one,two,three);\r\n        uint totalCanUse = (address(this).balance \u003e totalCanGetRewards) ?\r\n            (address(this).balance).sub(totalCanGetRewards) : 0;\r\n        if(totalWinBets \u003e 0)\r\n        {\r\n            uint lastWinBets = totalWinBets;\r\n            if(lastWinBets \u003e totalCanUse)\r\n            {\r\n                lastWinBets = totalCanUse;\r\n            }\r\n            calcPlayerRewards(lastWinBets);\r\n        }\r\n        if(totalOweRewards \u003e 0 \u0026\u0026 totalCanUse \u003e totalWinBets \u0026\u0026 totalCanGetRewards \u003c= address(this).balance)\r\n        {\r\n            uint totalCanRepay = (address(this).balance).sub(totalCanGetRewards);\r\n            if(totalCanRepay \u003e poolCache)\r\n            {\r\n                totalCanRepay = poolCache;\r\n            }\r\n            paybackOwePlayerRewards(totalCanRepay);\r\n        }\r\n        if(noAdminMode)\r\n        {\r\n            if((address(this).balance).sub(totalCanGetRewards) \u003e 1e16)\r\n            {\r\n                msg.sender.transfer(1e16);\r\n            }\r\n        }\r\n        paybackBankerProfits();\r\n        retrieveInvest();\r\n        emit EndGame(round,one,two,three);\r\n        clearGameState(nextServerRandom);\r\n    }\r\n    function calcPlayerRewards(uint lastWinBets)\r\n    internal\r\n    {\r\n        for (uint i = mapPlayerRewards.iterate_start(); mapPlayerRewards.iterate_valid(i); i = mapPlayerRewards.iterate_next(i))\r\n        {\r\n            (uint addrWin,uint betCnt) = mapPlayerRewards.iterate_get(i);\r\n            uint canGetReward = 0;\r\n            uint oweReward = 0;\r\n            if(lastWinBets \u003c totalWinBets)\r\n            {\r\n                canGetReward = betCnt.mul(lastWinBets).div(totalWinBets);\r\n                oweReward = betCnt.sub(canGetReward);\r\n            }\r\n            else\r\n            {\r\n                canGetReward = betCnt;\r\n            }\r\n            if(canGetReward \u003e 0)\r\n            {\r\n                mapCanGetRewards.add_or_insert(addrWin,canGetReward);\r\n                totalCanGetRewards = totalCanGetRewards.add(canGetReward);\r\n            }\r\n            if(oweReward \u003e 0)\r\n            {\r\n                mapOweRewards.add_or_insert(addrWin,oweReward);\r\n                totalOweRewards = totalOweRewards.add(oweReward);\r\n            }\r\n        }\r\n    }\r\n    function paybackOwePlayerRewards(uint totalCanRepay)\r\n    internal\r\n    {\r\n        uint canBackReward = totalOweRewards;\r\n        if(canBackReward \u003e totalCanRepay)\r\n        {\r\n            canBackReward = totalCanRepay;\r\n        }\r\n        uint totalOweCount = totalOweRewards;\r\n        uint16 j = 0;\r\n        for(uint i = mapOweRewards.iterate_start(); mapOweRewards.iterate_valid(i); i = mapOweRewards.iterate_next(i))\r\n        {\r\n            if(j \u003e 200)\r\n            {\r\n                break;\r\n            }\r\n            (uint addrPlayer,uint oweCount) = mapOweRewards.iterate_get(i);\r\n            if(oweCount == 0)\r\n            {\r\n                continue;\r\n            }\r\n            uint backCount = 0;\r\n            if(canBackReward \u003c totalOweCount)\r\n            {\r\n                backCount = oweCount.mul(canBackReward).div(totalOweCount);\r\n                if(backCount \u003e oweCount)\r\n                {\r\n                    backCount = oweCount;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                backCount = oweCount;\r\n            }\r\n            if(backCount \u003e totalOweRewards)\r\n            {\r\n                backCount = totalOweRewards;\r\n            }\r\n            mapCanGetRewards.add_or_insert(addrPlayer,backCount);\r\n            mapOweRewards.sub(addrPlayer,backCount);\r\n            totalOweRewards = totalOweRewards.sub(backCount);\r\n            totalCanGetRewards = totalCanGetRewards.add(backCount);\r\n            j++;\r\n        }\r\n    }\r\n    function paybackBankerProfits()\r\n    internal\r\n    {\r\n        uint lastRestBalance = (address(this).balance \u003c totalCanGetRewards) ? 0 :\r\n                (address(this).balance).sub(totalCanGetRewards);\r\n        bool needDec = false;\r\n        if(lastRestBalance \u003e 0)\r\n        {\r\n            if(lastRestBalance \u003e poolCache)\r\n            {\r\n                if(Address.isContract(addrInvest))\r\n                {\r\n                    bytes memory payload = abi.encodeWithSignature(\"buy()\");\r\n                    (bool bSuc,) = addrInvest.call.value(lastRestBalance.sub(poolCache))(payload);\r\n                    if(bSuc)\r\n                    {\r\n                        isInvested = true;\r\n                    }\r\n                }\r\n                if(poolCache.add(1e18) \u003c= 100e18)\r\n                {\r\n                    poolCache = poolCache.add(1e18);\r\n                }\r\n            }\r\n            else if((lastRestBalance + 1e18) \u003c= poolCache)\r\n            {\r\n                needDec = true;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            needDec = true;\r\n        }\r\n        if(needDec \u0026\u0026 poolCache.sub(1e18) \u003e= 1e18)\r\n        {\r\n            poolCache = poolCache.sub(1e18);\r\n        }\r\n    }\r\n    function retrieveInvest()\r\n    internal\r\n    {\r\n        if(totalOweRewards \u003e 0 \u0026\u0026 isInvested \u0026\u0026 Address.isContract(addrInvest))\r\n        {\r\n            bytes memory payload = abi.encodeWithSignature(\"exit()\");\r\n            (bool bSuc,) = addrInvest.call(payload);\r\n            if(bSuc)\r\n            {\r\n                isInvested = false;\r\n            }\r\n        }\r\n    }\r\n    function extractPlayerRewards(uint rewards, bool all) nonReentrant() public\r\n    {\r\n        uint addrPlayer = uint(msg.sender);\r\n        uint canGetRewards = mapCanGetRewards.data[addrPlayer].value;\r\n        if(all)\r\n        {\r\n            rewards = canGetRewards;\r\n        }\r\n        require(rewards \u003e 0 \u0026\u0026 rewards \u003c= canGetRewards);\r\n        if(rewards \u003e totalCanGetRewards)\r\n        {\r\n            rewards = totalCanGetRewards;\r\n        }\r\n        mapCanGetRewards.sub(addrPlayer,rewards);\r\n        if(rewards == canGetRewards)\r\n        {\r\n            mapCanGetRewards.remove(addrPlayer);\r\n        }\r\n        totalCanGetRewards = totalCanGetRewards.sub(rewards);\r\n        msg.sender.transfer(rewards);\r\n    }\r\n    function clearGameState(bytes32 nextServerRandom) internal\r\n    {\r\n        mapBig.clear();\r\n        mapSmall.clear();\r\n        uint8 i = 0;\r\n        for(i=0; i\u003c7; i++)\r\n        {\r\n            mapTriple[i].clear();\r\n        }\r\n        for(i=0; i\u003c6; i++)\r\n        {\r\n            mapDouble[i].clear();\r\n        }\r\n        for(i=0; i\u003c14; i++)\r\n        {\r\n            mapSum[i].clear();\r\n        }\r\n        for(i=0; i\u003c6; i++)\r\n        {\r\n            mapOne[i].clear();\r\n        }\r\n        for(i=0; i\u003c15; i++)\r\n        {\r\n            mapTwo[i].clear();\r\n        }\r\n        mapPlayerRewards.clear();\r\n        totalGameBets = 0;\r\n        totalWinBets = 0;\r\n        bigBets = 0;\r\n        smallBets = 0;\r\n        serverRandomHash = nextServerRandom;\r\n        gameState = 2;\r\n        round++;\r\n    }\r\n    function startNextRound() internal\r\n    {\r\n        startBlockNum = block.number;\r\n        startTime = now;\r\n        endBlockNum = startBlockNum + gameDurationBlocks;\r\n        betLimitBlockNum = startBlockNum + gameLimitBlocks;\r\n        gameState = 0;\r\n    }\r\n    function () payable external\r\n    {\r\n        require(msg.sender == addrInvest);\r\n    }\r\n}\r\n"},"IterableMapping.sol":{"content":"pragma solidity ^0.5.8;\r\nimport \"./SafeMath.sol\";\r\n/// @dev Models a uint -\u003e uint mapping where it is possible to iterate over all keys.\r\nlibrary IterableMapping\r\n{\r\n    using SafeMath for uint;\r\n    struct itmap\r\n    {\r\n        mapping(uint =\u003e IndexValue) data;\r\n        KeyFlag[] keys;\r\n        uint size;\r\n    }\r\n    struct IndexValue { uint keyIndex; uint value; }\r\n    struct KeyFlag { uint key; bool deleted; }\r\n    function insert(itmap storage self, uint key, uint value) public returns (bool replaced)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        self.data[key].value = value;\r\n        if (keyIndex \u003e 0)\r\n            return true;\r\n        else\r\n        {\r\n            keyIndex = self.keys.length++;\r\n            self.data[key].keyIndex = keyIndex + 1;\r\n            self.keys[keyIndex].key = key;\r\n            self.size++;\r\n            return false;\r\n        }\r\n    }\r\n    function add_or_insert(itmap storage self, uint key, uint value) public returns (bool added)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n\r\n        if (keyIndex \u003e 0)\r\n        {\r\n            self.data[key].value = self.data[key].value.add(value);\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            self.data[key].value = value;\r\n            keyIndex = self.keys.length++;\r\n            self.data[key].keyIndex = keyIndex + 1;\r\n            self.keys[keyIndex].key = key;\r\n            self.size++;\r\n            return false;\r\n        }\r\n    }\r\n    function sub(itmap storage self, uint key, uint value) public returns (bool subbed)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n\r\n        if (keyIndex \u003e 0)\r\n        {\r\n            self.data[key].value = self.data[key].value.sub(value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function remove(itmap storage self, uint key) public returns (bool success)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        if (keyIndex == 0)\r\n            return false;\r\n        delete self.data[key];\r\n        self.keys[keyIndex - 1].deleted = true;\r\n        self.size --;\r\n    }\r\n\r\n    function clear(itmap storage self) public\r\n    {\r\n        uint len = self.keys.length;\r\n        for(uint i = 0; i\u003clen; i++)\r\n        {\r\n            if(!self.keys[i].deleted)\r\n            {\r\n                delete self.data[self.keys[i].key];\r\n            }\r\n        }\r\n        self.keys.length = 0;\r\n        self.size = 0;\r\n    }\r\n    function contains(itmap storage self, uint key) public view returns (bool)\r\n    {\r\n        return self.data[key].keyIndex \u003e 0;\r\n    }\r\n    function iterate_start(itmap storage self) public view returns (uint keyIndex)\r\n    {\r\n        return iterate_next(self, uint(-1));\r\n    }\r\n    function iterate_valid(itmap storage self, uint keyIndex) public view returns (bool)\r\n    {\r\n        return keyIndex \u003c self.keys.length;\r\n    }\r\n    function iterate_next(itmap storage self, uint keyIndex) public view returns (uint r_keyIndex)\r\n    {\r\n        keyIndex++;\r\n        while (keyIndex \u003c self.keys.length \u0026\u0026 self.keys[keyIndex].deleted)\r\n            keyIndex++;\r\n        return keyIndex;\r\n    }\r\n    function iterate_get(itmap storage self, uint keyIndex) public view returns (uint key, uint value)\r\n    {\r\n        key = self.keys[keyIndex].key;\r\n        value = self.data[key].value;\r\n    }\r\n}\r\n"},"ReentrancyGuard.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n * available, which can be aplied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"},"WeFairPlayInvestment.sol":{"content":"pragma solidity ^0.5.8;\r\nimport \"./SafeMath.sol\";\r\nimport \"./IterableMapping.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\ncontract WeFairPlayInvestment is ReentrancyGuard{\r\n    using SafeMath for uint;\r\n    using IterableMapping for IterableMapping.itmap;\r\n    modifier onlyBagholders() {\r\n        require(myTokens() \u003e 0);\r\n        _;\r\n    }\r\n    modifier onlyStronghands() {\r\n        require(myDividends(true) \u003e 0);\r\n        _;\r\n    }\r\n    modifier onlyOwner()\r\n    {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n    modifier onlyAdministrator(){\r\n        require(owner == msg.sender || administrators[keccak256(abi.encodePacked(msg.sender))]);\r\n        _;\r\n    }\r\n    modifier onlyOperators(){\r\n        require(mapOperatorStocks_.contains(uint(msg.sender))\r\n            \u0026\u0026 mapOperatorStocks_.data[uint(msg.sender)].value \u003e 0);\r\n        _;\r\n    }\r\n    modifier notEarlyWhale(){\r\n        require(!onlyAmbassadors);\r\n        _;\r\n    }\r\n    modifier notEndStage(){\r\n        require(!isEndStage);\r\n        _;\r\n    }\r\n    modifier antiEarlyWhale(uint256 _amountOfEthereum){\r\n        if(!onlyAmbassadors) {\r\n            _;\r\n            return;\r\n        }\r\n        address _customerAddress = msg.sender;\r\n          if( onlyAmbassadors \u0026\u0026 (totalEthereumBalance() \u003c ambassadorQuota_ )){\r\n            require(\r\n                ambassadors_[_customerAddress] == true \u0026\u0026\r\n                (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) \u003c= ambassadorMaxPurchase_);\r\n                ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);\r\n            _;\r\n        } else {\r\n            onlyAmbassadors = false;\r\n            _;\r\n        }\r\n\r\n    }\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy\r\n    );\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned\r\n    );\r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensMinted\r\n    );\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n    string public name = \"WeFairPlayCoin\";\r\n    string public symbol = \"WFP\";\r\n    uint8 constant public decimals = 18;\r\n    uint8 constant internal operatorFee_ = 10;\r\n    uint8 constant internal dividendFee_ = 10;\r\n    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\r\n    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\r\n    uint256 constant internal magnitude = 2**64;\r\n    uint256 public stakingRequirement = 100e18;\r\n    mapping(address =\u003e bool) internal ambassadors_;\r\n    uint256 constant internal ambassadorMaxPurchase_ = 1 ether;\r\n    uint256 constant internal ambassadorQuota_ = 10 ether;\r\n    mapping(address =\u003e uint256) internal tokenBalanceLedger_;\r\n    mapping(address =\u003e uint256) internal referralBalance_;\r\n    mapping(address =\u003e int256) internal payoutsTo_;\r\n    mapping(address =\u003e uint256) internal ambassadorAccumulatedQuota_;\r\n    uint256 internal tokenSupply_ = 0;\r\n    uint256 internal profitPerShare_;\r\n    mapping(bytes32 =\u003e bool) public administrators;\r\n    bool public onlyAmbassadors = true;\r\n    IterableMapping.itmap mapOperatorRewards_;\r\n    IterableMapping.itmap mapOperatorStocks_;\r\n    uint totalOperatorRewards;\r\n    uint256 constant public totalStocks_ = 10000;\r\n    uint lastActiveTime;\r\n    uint constant internal ENTER_END_DURATION = 2 * 4 weeks;//10 minutes;//2 * 4 weeks;\r\n    bool public isEndStage;\r\n    uint public enterEndTime;\r\n    uint constant internal END_STAGE_DURATION = 4 weeks;//10 minutes;//4 weeks;\r\n    address owner;\r\n    constructor()\r\n    public\r\n    {\r\n        owner = msg.sender;\r\n         administrators[0x6e87e5c3130679f898089256718f36b117cb685debd8d2511298b3f0dabadf1e] = true;\r\n        ambassadors_[0x1Fd11576EAbe588115aA47E52904C3221E4c0a95] = true;\r\n        ambassadors_[0x1DC93b1bE8b97959f5B07d6113A909F9C89D3361] = true;\r\n        ambassadors_[0x135de610Bd907e9B6aB3d93753d6E59De6ef886B] = true;\r\n        ambassadors_[0x5f5B2BB60EBDa86C9efc9a4cA01a7756554c2Fe5] = true;\r\n        ambassadors_[0x89EE32611CcFa44044cc1F0d0ECC53E53Aa3C634] = true;\r\n        ambassadors_[0x16B0e5F320Cd30028caFf791aC08dF830B52e61d] = true;\r\n        ambassadors_[0xA9d47178067568A5C84c0849A7e1b47139DA6a7c] = true;\r\n        ambassadors_[0x0d7e1a43e666714A1B7B8F4e5eD9Ac86597078A0] = true;\r\n        ambassadors_[0xc33F6Ca865D8Ec8fE00037f64B8dbe6cBD751555] = true;\r\n        ambassadors_[0x324bC683445fa86CFc85b49c1eD4d2bdDc6409aE] = true;\r\n        mapOperatorStocks_.add_or_insert(uint(owner),totalStocks_);\r\n    }\r\n    function ambassadorLeftLimit()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        if(ambassadors_[msg.sender]) {\r\n            return ambassadorMaxPurchase_.sub(ambassadorAccumulatedQuota_[msg.sender]);\r\n        }\r\n        return 0;\r\n    }\r\n    function isAmbassador()\r\n    view\r\n    public\r\n    returns(bool)\r\n    {\r\n        return ambassadors_[msg.sender];\r\n    }\r\n    function buy(address _referredBy)\r\n    public\r\n    payable\r\n    {\r\n        purchaseTokens(msg.value, _referredBy);\r\n    }\r\n    function()\r\n    payable\r\n    external\r\n    {\r\n        purchaseTokens(msg.value, address(0x0));\r\n    }\r\n    function reinvest()\r\n    onlyStronghands()\r\n    public\r\n    {\r\n        uint256 _dividends = myDividends(false); // retrieve ref. bonus later in the code\r\n        address _customerAddress = msg.sender;\r\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\r\n        _dividends += referralBalance_[_customerAddress];\r\n        referralBalance_[_customerAddress] = 0;\r\n        uint256 _tokens = purchaseTokens(_dividends, address(0x0));\r\n        emit onReinvestment(_customerAddress, _dividends, _tokens);\r\n    }\r\n    function exit()\r\n    public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\r\n        if(_tokens \u003e 0) sell(_tokens);\r\n        withdraw();\r\n    }\r\n    function withdraw()\r\n    nonReentrant()\r\n    onlyStronghands()\r\n    notEarlyWhale()\r\n    public\r\n    {\r\n        address payable _customerAddress = msg.sender;\r\n        uint256 _dividends = myDividends(false);\r\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\r\n        _dividends += referralBalance_[_customerAddress];\r\n        referralBalance_[_customerAddress] = 0;\r\n        _customerAddress.transfer(_dividends);\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    function sell(uint256 _amountOfTokens)\r\n    notEarlyWhale()\r\n    onlyBagholders()\r\n    public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        require(_amountOfTokens \u003c= tokenBalanceLedger_[_customerAddress]);\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 _ethereum = tokensToEthereum_(_tokens);\r\n        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\r\n        uint256 operatorDividends = SafeMath.div(_dividends, operatorFee_);\r\n        sendOperatorRewards_(operatorDividends);\r\n        _dividends = _dividends - operatorDividends;\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\r\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n        if (tokenSupply_ \u003e 0) {\r\n            profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\r\n        }\r\n\r\n        lastActiveTime = now;\r\n        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);\r\n    }\r\n    function _transfer(address _from, address _toAddress, uint _amountOfTokens)\r\n    notEarlyWhale()\r\n    notEndStage()\r\n    internal\r\n    {\r\n        address _customerAddress = _from;\r\n        require(_amountOfTokens \u003c= tokenBalanceLedger_[_customerAddress]);\r\n        if(myDividends(true) \u003e 0) withdraw();\r\n        uint256 _tokenFee = SafeMath.div(_amountOfTokens, dividendFee_);\r\n        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\r\n        uint256 _dividends = tokensToEthereum_(_tokenFee);\r\n        uint256 operatorDividends = SafeMath.div(_dividends, operatorFee_);\r\n        sendOperatorRewards_(operatorDividends);\r\n        _dividends = _dividends - operatorDividends;\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\r\n        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);\r\n        profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\r\n        lastActiveTime = now;\r\n        emit Transfer(_customerAddress, _toAddress, _taxedTokens);\r\n    }\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n    onlyBagholders()\r\n    public\r\n    returns(bool)\r\n    {\r\n        _transfer(msg.sender, _toAddress, _amountOfTokens);\r\n        return true;\r\n    }\r\n    function isAdministrator()\r\n    view\r\n    public\r\n    returns(bool)\r\n    {\r\n        return (owner == msg.sender || administrators[keccak256(abi.encodePacked(msg.sender))]);\r\n    }\r\n    function disableInitialStage()\r\n    onlyOwner()\r\n    public\r\n    {\r\n        onlyAmbassadors = false;\r\n    }\r\n    function setAdministrator(bytes32 _identifier, bool _status)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        administrators[_identifier] = _status;\r\n    }\r\n    function setOwner(address payable newOwner) onlyOwner public\r\n    {\r\n        owner = newOwner;\r\n    }\r\n    function canEnterEndStage() view public returns(bool)\r\n    {\r\n        return (!isEndStage \u0026\u0026 lastActiveTime \u003e 0 \u0026\u0026 now - lastActiveTime \u003e ENTER_END_DURATION);\r\n    }\r\n    function enterEndStage() onlyOwner public\r\n    {\r\n        require(!isEndStage);\r\n        require(lastActiveTime \u003e 0 \u0026\u0026 now - lastActiveTime \u003e ENTER_END_DURATION);\r\n        isEndStage = true;\r\n        enterEndTime = now;\r\n    }\r\n    function restEndTime() view public returns(int)\r\n    {\r\n        if(isEndStage \u0026\u0026 enterEndTime \u003e 0)\r\n        {\r\n            uint endTimestamp = enterEndTime.add(END_STAGE_DURATION);\r\n            if(now \u003c endTimestamp)\r\n            {\r\n                return int(endTimestamp.sub(now));\r\n            }\r\n            else\r\n            {\r\n                return 0;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n    function kill() onlyOwner public\r\n    {\r\n        require(isEndStage \u0026\u0026 enterEndTime \u003e 0 \u0026\u0026 now - enterEndTime \u003e END_STAGE_DURATION);\r\n        selfdestruct(toPayable(owner));\r\n    }\r\n    function setStakingRequirement(uint256 _amountOfTokens)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        stakingRequirement = _amountOfTokens;\r\n    }\r\n    function setName(string memory _name)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        name = _name;\r\n    }\r\n    function setSymbol(string memory _symbol)\r\n    onlyAdministrator()\r\n    public\r\n    {\r\n        symbol = _symbol;\r\n    }\r\n    function totalEthereumBalance()\r\n    public\r\n    view\r\n    returns(uint)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n    function totalSupply()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return tokenSupply_;\r\n    }\r\n    function myTokens()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n    function myDividends(bool _includeReferralBonus)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\r\n    }\r\n    function balanceOf(address _customerAddress)\r\n    view\r\n    public\r\n    returns(uint256)\r\n    {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n    function dividendsOf(address _customerAddress)\r\n    view\r\n    public\r\n    returns(uint256)\r\n    {\r\n        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\r\n    }\r\n    function sellPrice()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );\r\n            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n    function buyPrice()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = _ethereum.div( dividendFee_  );\r\n            uint256 _taxedEthereum = _ethereum.add( _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n    function calculateTokensReceived(uint256 _ethereumToSpend)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        return _amountOfTokens;\r\n    }\r\n    function calculateEthereumReceived(uint256 _tokensToSell)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        require(_tokensToSell \u003c= tokenSupply_);\r\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\r\n        uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\r\n        return _taxedEthereum;\r\n    }\r\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy)\r\n    antiEarlyWhale(_incomingEthereum)\r\n    notEndStage()\r\n    internal\r\n    returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        uint256 _undividedDividends = SafeMath.div(_incomingEthereum, dividendFee_);\r\n        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\r\n        sendOperatorRewards_(SafeMath.div(_undividedDividends, operatorFee_));\r\n        _undividedDividends = _undividedDividends - SafeMath.div(_undividedDividends, operatorFee_);\r\n        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\r\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        uint256 _fee = _dividends * magnitude;\r\n        require(_amountOfTokens \u003e 0 \u0026\u0026 (SafeMath.add(_amountOfTokens,tokenSupply_) \u003e tokenSupply_));\r\n        if(\r\n            _referredBy != address(0x0000000000000000000000000000000000000000) \u0026\u0026\r\n            _referredBy != _customerAddress \u0026\u0026\r\n        tokenBalanceLedger_[_referredBy] \u003e= stakingRequirement\r\n        ){\r\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\r\n        } else {\r\n            _dividends = SafeMath.add(_dividends, _referralBonus);\r\n            _fee = _dividends * magnitude;\r\n        }\r\n        if(tokenSupply_ \u003e 0){\r\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\r\n            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\r\n            _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\r\n        } else {\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\r\n        payoutsTo_[_customerAddress] += _updatedPayouts;\r\n        lastActiveTime = now;\r\n        emit onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);\r\n        return _amountOfTokens;\r\n    }\r\n    function ethereumToTokens_(uint256 _ethereum)\r\n    internal\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived =\r\n        (\r\n        (\r\n        SafeMath.sub(\r\n            (sqrt\r\n        (\r\n            (_tokenPriceInitial**2)\r\n            +\r\n            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\r\n            +\r\n            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\r\n            +\r\n            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\r\n        )\r\n            ), _tokenPriceInitial\r\n        )\r\n        )/(tokenPriceIncremental_)\r\n        )-(tokenSupply_)\r\n        ;\r\n        return _tokensReceived;\r\n    }\r\n    function tokensToEthereum_(uint256 _tokens)\r\n    internal\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n        (\r\n        SafeMath.sub(\r\n            (\r\n            (\r\n            (\r\n            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\r\n            )-tokenPriceIncremental_\r\n            )*(tokens_ - 1e18)\r\n            ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\r\n        )\r\n        /1e18);\r\n        return _etherReceived;\r\n    }\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z \u003c y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n    function sendOperatorRewards_(uint256 _ethereum)\r\n    internal\r\n    {\r\n        uint restRewards = _ethereum;\r\n        for(uint i = mapOperatorStocks_.iterate_start(); mapOperatorStocks_.iterate_valid(i) \u0026\u0026 restRewards\u003e0; i = mapOperatorStocks_.iterate_next(i))\r\n        {\r\n            (uint addrOperator,uint stocks) = mapOperatorStocks_.iterate_get(i);\r\n            if(stocks == 0)\r\n            {\r\n                continue;\r\n            }\r\n            uint256 rewards = _ethereum.mul(stocks).div(totalStocks_);\r\n            if(rewards \u003e restRewards)\r\n            {\r\n                rewards = restRewards;\r\n            }\r\n            restRewards = restRewards.sub(rewards);\r\n            mapOperatorRewards_.add_or_insert(addrOperator,rewards);\r\n            totalOperatorRewards = totalOperatorRewards.add(rewards);\r\n        }\r\n    }\r\n    function getOperatorStocks_()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        return mapOperatorStocks_.data[uint(msg.sender)].value;\r\n    }\r\n    function getOperatorRewards_()\r\n    view\r\n    public\r\n    returns(uint)\r\n    {\r\n        return mapOperatorRewards_.data[uint(msg.sender)].value;\r\n    }\r\n    function withDrawRewards_()\r\n    nonReentrant()\r\n    notEarlyWhale()\r\n    onlyOperators()\r\n    public\r\n    {\r\n        uint player = uint(msg.sender);\r\n        require(mapOperatorRewards_.contains(player));\r\n        uint totalRewards = mapOperatorRewards_.data[player].value;\r\n        require(totalRewards\u003e0 \u0026\u0026 totalRewards \u003c= totalOperatorRewards \u0026\u0026 totalRewards \u003c= address(this).balance);\r\n        mapOperatorRewards_.sub(player,totalRewards);\r\n        totalOperatorRewards = totalOperatorRewards.sub(totalRewards);\r\n        msg.sender.transfer(totalRewards);\r\n    }\r\n    function transferStocks_(address receiver,uint amountStock)\r\n    nonReentrant()\r\n    onlyOperators()\r\n    notEarlyWhale()\r\n    notEndStage()\r\n    public\r\n    {\r\n        uint sender = uint(msg.sender);\r\n        uint restStocks = uint(mapOperatorStocks_.data[sender].value);\r\n        require(amountStock \u003c= restStocks);\r\n        mapOperatorStocks_.add_or_insert(uint(receiver),amountStock);\r\n        mapOperatorStocks_.sub(sender,amountStock);\r\n        if(mapOperatorStocks_.data[sender].value == 0)\r\n        {\r\n            uint totalRewards = mapOperatorRewards_.data[sender].value;\r\n            mapOperatorStocks_.remove(sender);\r\n            mapOperatorRewards_.remove(sender);\r\n            if(totalRewards \u003e 0)\r\n            {\r\n                if(totalRewards \u003e totalOperatorRewards)\r\n                {\r\n                    totalRewards = totalOperatorRewards;\r\n                }\r\n                totalOperatorRewards = totalOperatorRewards.sub(totalRewards);\r\n                address(sender).transfer(totalRewards);\r\n            }\r\n        }\r\n    }\r\n}\r\n"}}
