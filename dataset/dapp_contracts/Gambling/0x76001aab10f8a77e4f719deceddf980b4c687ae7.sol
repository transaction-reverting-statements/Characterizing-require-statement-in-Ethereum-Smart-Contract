{"BlackJack.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nimport \"./CroupierRole.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract BlackJack is CroupierRole {\r\n    using SafeMath for *;\r\n\r\n    uint constant THIS_DIVISOR = 1000;\r\n    uint constant LOCK_RATIO = 2500;\r\n    uint8 constant MAX_CUT_CARD = 15;\r\n\r\n    mapping (address =\u003e uint256) private _balances;\r\n    mapping (address =\u003e uint256) private _locked;\r\n\r\n    mapping (address =\u003e uint256) private _last_apply_time;\r\n    mapping (address =\u003e uint256) private _apply_amount;\r\n\r\n    uint256 private _totalBalance = 0;\r\n\r\n    uint256 public expireBlocks = 255;\r\n    uint256 public statedPeriod = 30 minutes;\r\n    uint256 public maxBet = 1 ether;\r\n    uint256 public minBet = 0.1 ether;\r\n    uint256 public feeRatio = 10;\r\n\r\n    struct Bet {\r\n        // gambler\u0027s address, 20 bytes.\r\n        address gambler;\r\n        // cut card position, the number range is 0-15.\r\n        uint8 cutCard;\r\n        // gambler\u0027s action list, per 4-bit representing an action, push-down storage.\r\n        /**\r\n        * action encoding rules:\r\n        * 0 - reserved\r\n        * 1 - Get\r\n        * 2 - Hit\r\n        * 3 - Stand\r\n        * 4 - Double\r\n        * 5 - Split\r\n        * 6 - Insurance\r\n        * 7 - Surrender\r\n        * 8 - timeout\r\n         */\r\n        bytes11 actions;\r\n        // betting amount, 128 bits number is enough.\r\n        uint128 amount;\r\n        // block number of deal.\r\n        uint128 dealBlockNumber;\r\n    }\r\n\r\n    mapping (uint256 =\u003e Bet) public bets;\r\n\r\n    event Deposit(address indexed from, uint256 value);\r\n    event Withdraw(address indexed from, uint256 value);\r\n    event Apply(address indexed from, uint256 value);\r\n    event Deal(uint256 indexed commit);\r\n    event Settle(uint256 indexed commit);\r\n    event Refund(uint256 indexed commit, uint128 amount);\r\n    \r\n    /**\r\n     * @dev constructor\r\n     */\r\n    constructor() public payable{        \r\n    }\r\n\r\n    /**\r\n    * @dev Fallback function. It\u0027s another entry for deposit. While owner transfer ether to \r\n    *      this contract, it means increase the pot.\r\n     */\r\n    function () public payable {\r\n        if(!isOwner(msg.sender)){\r\n            _deposit(msg.sender, msg.value);\r\n        }        \r\n    }\r\n\r\n    /**\r\n    * @dev Total number of tokens deposit by gamblers.\r\n    * @return An uint256 representing the total amount owned by gamblers.\r\n    */\r\n    function totalBalance() public view returns (uint256) {\r\n        return _totalBalance;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of specified address.\r\n    * @param owner The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the locked value of specified address.\r\n    * @param owner The address to query the locked amount of.\r\n    * @return An uint256 representing the amount locked by the passed address.\r\n    */\r\n    function lockedOf(address owner) public view returns (uint256) {\r\n        return _locked[owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the last apply-withdraw time of specified address.\r\n    * @param owner The address to query the last apply time of.\r\n    * @return An uint256 representing the last apply time by the passed address.\r\n    */\r\n    function lastApplyTime(address owner) public view returns (uint256) {\r\n        return _last_apply_time[owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the apply-withdraw amount of specified address.\r\n    * @param owner The address to query the apply amount of.\r\n    * @return An uint256 representing the apply amount by the passed address.\r\n    */\r\n    function applyAmount(address owner) public view returns (uint256) {\r\n        return _apply_amount[owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Deal action to start a new game with proxy mode, submit by croupier bot.\r\n    * @param gambler gambler\u0027s address.\r\n    * @param commit generated by keccak of 2 256-bit reveals, used to unique identify a deck.\r\n    *               gambler get commit but don\u0027t know the deck, dealer can\u0027t change the deck because of keccak is one-way irreversible.\r\n    * @param amount 128-bit number of bet amount.\r\n    * @param cutCard cut card position, gambler set it after receive the commit, so this process can guarantee fairness.\r\n    * @param v \r\n    * @param r \r\n    * @param s v, r,s are components of ECDSA signature. Ensure the deck is signed by the gambler himself.\r\n     */\r\n    function deal(address gambler, uint256 commit, uint128 amount, uint8 cutCard, uint8 v, bytes32 r, bytes32 s) \r\n        public \r\n        onlyCroupier\r\n    {\r\n        // verify signature.\r\n        bytes32 signatureHash = keccak256(abi.encodePacked(amount, cutCard, commit));        \r\n        require (gambler == ecrecover(signatureHash, v, r, s), \"ECDSA signature is not valid.\");\r\n\r\n        _dealCore(gambler, commit, amount, cutCard);\r\n    }\r\n\r\n    /**\r\n    * @dev Settle a deck by croupier.\r\n    * @param reveal_1 Per byte of 1-26 bytes in reveal_1, reveal_2 representing a single card, 2 256-bit reveal combine a 52 cards deck. \r\n    * Single card coding rules:\r\n    * low 4-bit : 0001-1010 points of single card(1-10).\r\n    * 5-6 bit   : suit, 00 - spades, 01 - hearts, 10 - clubs, 11 - diamonds.\r\n    * 7-8 bit   : face cards, 00 - 10, 01 - Jack, 10 - Queen, 11 - King.\r\n    * @param reveal_2 same as reveal_1.\r\n    * @param actions gambler\u0027s actions.\r\n    * @param win true - gambler win, false - lose.\r\n    * @param amount winnings or losses amount.\r\n     */\r\n    function settle(uint256 reveal_1, uint256 reveal_2, bytes11 actions, bool win, uint128 amount) \r\n        public \r\n        onlyCroupier \r\n    {\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal_1, reveal_2)));\r\n        Bet storage bet = bets[commit];\r\n\r\n        // verify commit.\r\n        address gambler = bet.gambler;\r\n        uint256 value = uint256(bet.amount);\r\n        require(gambler != address(0) \u0026\u0026 value \u003e 0, \"Bet should be in \u0027active\u0027 state.\");\r\n\r\n        // verify bet is not expired.\r\n        require(block.number \u003e bet.dealBlockNumber, \"Settle in the same block as placeBet, or before.\");\r\n        require(block.number \u003c= uint256(bet.dealBlockNumber).add(expireBlocks), \"Bet expired.\");        \r\n\r\n        // Store actions.\r\n        bet.actions = actions;\r\n        bet.amount = 0;\r\n\r\n        // unlock.\r\n        uint256 lockValue = value.mul(LOCK_RATIO).div(THIS_DIVISOR);\r\n        _locked[gambler] = _locked[gambler].sub(lockValue);\r\n\r\n        // calculate balance.\r\n        if(win) {\r\n            _balances[gambler] = _balances[gambler].add(uint256(amount));\r\n            _totalBalance = _totalBalance.add(uint256(amount));\r\n        }\r\n        else{\r\n            _balances[gambler] = _balances[gambler].sub(uint256(amount));\r\n            _totalBalance = _totalBalance.sub(uint256(amount));\r\n        }\r\n\r\n        emit Settle(commit);\r\n    }\r\n\r\n    /**\r\n    * @dev Refund a commit while it\u0027s expired.\r\n    * @param commit which one bet been refunded.\r\n     */\r\n    function refund(uint256 commit) public onlyCroupier {\r\n        // Verify that bet is in \u0027active\u0027 state.\r\n        Bet storage bet = bets[commit];\r\n        uint256 value = uint256(bet.amount);\r\n        address gambler = bet.gambler;\r\n        require(gambler != address(0) \u0026\u0026 value \u003e 0, \"Bet should be in \u0027active\u0027 state.\");\r\n\r\n        // Verify that bet has already expired.\r\n        require (block.number \u003e uint256(bet.dealBlockNumber).add(expireBlocks), \"Bet not yet expired.\");\r\n\r\n        //unlock.\r\n        uint256 lockValue = value.mul(LOCK_RATIO).div(THIS_DIVISOR);  \r\n        _locked[gambler] = _locked[gambler].sub(lockValue);\r\n\r\n        bet.amount = 0;\r\n\r\n        emit Refund(commit, uint128(value));\r\n    }\r\n\r\n    /**\r\n    * @dev Deposit in this contract.\r\n     */\r\n    function deposit() public payable returns (bool){\r\n        _deposit(msg.sender, msg.value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev apply for withdrawal.\r\n    * @param amount the amount to apply for withdrawal, should be less than balance subtract locked.\r\n     */\r\n    function apply(uint256 amount) public returns (bool){\r\n        require(amount \u003c= _balances[msg.sender].sub(_locked[msg.sender]), \"Not enough balance.\");\r\n\r\n        _last_apply_time[msg.sender] = now;\r\n        _apply_amount[msg.sender] = amount;\r\n\r\n        emit Apply(msg.sender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw from this contract. Should apply at first, and withdraw after the stated apply period.\r\n     */\r\n    function withdraw() public returns (bool){\r\n        require(_apply_amount[msg.sender] \u003e 0, \"\");\r\n        require(now \u003e= _last_apply_time[msg.sender].add(statedPeriod), \"\");\r\n\r\n        _withdraw(msg.sender, _apply_amount[msg.sender]);\r\n\r\n        _apply_amount[msg.sender] = 0;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw all by croupier in special cases, such as contract upgrade.\r\n    * @param from The address to withdraw.\r\n     */\r\n    function withdrawProxy(address from) public onlyCroupier returns(bool) {        \r\n        uint256 amount = balanceOf(from);\r\n        _withdraw(from, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Deposit for a specified address, internal function.\r\n    * @param from The address to deposit.\r\n    * @param value The amount to be deposited. \r\n     */\r\n    function _deposit(address from, uint256 value) internal {\r\n        require(from != address(0), \"Invalid address.\");\r\n\r\n        _balances[from] = _balances[from].add(value);\r\n        _totalBalance = _totalBalance.add(value);\r\n        emit Deposit(from, value);\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw for a specified address, internal function. Due to house edge of blackjack can\u0027t cover the cost of gas, \r\n    *      platform charges 1% fee while withdraw.  \r\n    * @param from The address to withdraw.\r\n    * @param value The amount to be withdrawed, should be less than balance subtract locked, and this contract can afford. \r\n     */\r\n    function _withdraw(address from, uint256 value) internal {\r\n        require(from != address(0), \"Invalid address.\");\r\n        require(value \u003c= _balances[from].sub(_locked[from]), \"Not enough balance.\");\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _totalBalance = _totalBalance.sub(value);        \r\n        \r\n        uint256 fee = value.mul(feeRatio).div(THIS_DIVISOR);\r\n        require(value.sub(fee) \u003c= address(this).balance, \"Can\u0027t afford.\");\r\n        from.transfer(value.sub(fee));\r\n        \r\n        emit Withdraw(from, value);\r\n    }\r\n\r\n    /**\r\n    * @dev Check uint256-uint128 type conversion is safe\r\n     */\r\n    function _safeTypeConversion(uint256 a, uint128 b) internal pure returns(bool) {\r\n        require(a == uint256(b) \u0026\u0026 uint128(a) == b, \"Not safe type conversion.\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Deal action core.\r\n     */\r\n    function _dealCore(address gambler, uint256 commit, uint128 amount, uint8 cutCard) internal {\r\n        // verify commit is \"Clean\".\r\n        Bet storage bet = bets[commit];\r\n        require(bet.gambler == address(0), \"Bet should be in \u0027clean\u0027 state.\");\r\n\r\n        // verify cut card position.\r\n        require(cutCard \u003c= MAX_CUT_CARD, \"Cut card position is not valid.\");\r\n    \r\n        //verify bet amount range.\r\n        uint256 value = uint256(amount);\r\n        require(_safeTypeConversion(value, amount), \"Not safe type conversion\");\r\n\r\n        require(value \u003e= minBet \u0026\u0026 value \u003c= maxBet, \"Bet amount is out of range.\");\r\n\r\n        uint256 lockValue = value.mul(LOCK_RATIO).div(THIS_DIVISOR);        \r\n        require(lockValue \u003c= balanceOf(gambler).sub(lockedOf(gambler)), \"Balance is not enough for locked.\");\r\n\r\n        // Store bet parameters on blockchain.\r\n        _locked[gambler] = _locked[gambler].add(lockValue);\r\n\r\n        bet.gambler = gambler;\r\n        bet.cutCard = cutCard;\r\n        bet.amount = amount;\r\n        bet.dealBlockNumber = uint128(block.number);\r\n\r\n        emit Deal(commit);        \r\n    }\r\n\r\n    /**\r\n    * @dev Set max bet amount.\r\n    * @param input in wei.\r\n     */\r\n    function setMaxBet(uint256 input) public onlyOwner {\r\n        maxBet = input;\r\n    }\r\n\r\n    /**\r\n    * @dev Set min bet amount.\r\n    * @param input in wei.\r\n     */\r\n    function setMinBet(uint256 input) public onlyOwner {\r\n        minBet = input;\r\n    }\r\n\r\n    /**\r\n    * @dev Set fee ratio.\r\n    * @param input new fee ratio, div by 1000.\r\n     */\r\n    function setFeeRatio(uint256 input) public onlyOwner {\r\n        feeRatio = input;\r\n    }\r\n\r\n    /**\r\n    * @dev Set expiration blocks.\r\n    * @param input new number of expiration blocks.\r\n     */\r\n    function setExpireBlocks(uint256 input) public onlyOwner {\r\n        expireBlocks = input;\r\n    }\r\n\r\n    /**\r\n    * @dev Set stated apply period.\r\n    * @param input new number of stated apply period.\r\n     */\r\n    function setStatedPeriod(uint256 input) public onlyOwner {\r\n        statedPeriod = input;\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw funds to cover costs of operation.\r\n    * @param amount should ensure the total balances of palyers.\r\n     */\r\n    function withdrawFunds(uint256 amount) public onlyOwner {\r\n        require(amount \u003c= address(this).balance.sub(_totalBalance), \"Not enough funds.\");\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    /**\r\n    * @dev kill this contract while upgraded.\r\n     */\r\n    function kill() public onlyOwner {\r\n        require(_totalBalance == 0, \"All of gambler\u0027s balances need to be withdrawn.\");\r\n        selfdestruct(msg.sender);\r\n    }\r\n}"},"CroupierRole.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nimport \"./OwnerRole.sol\";\r\n\r\ncontract CroupierRole is OwnerRole{\r\n    using Roles for Roles.Role;\r\n\r\n    event CroupierAdded(address indexed account);\r\n    event CroupierRemoved(address indexed account);\r\n\r\n    Roles.Role private _croupiers;\r\n\r\n    constructor () internal {\r\n    }\r\n\r\n    modifier onlyCroupier() {\r\n        require(isCroupier(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isCroupier(address account) public view returns (bool) {\r\n        return _croupiers.has(account);\r\n    }\r\n\r\n    function addCroupier(address account) public onlyOwner {\r\n        _addCroupier(account);\r\n    }\r\n\r\n    function removeCroupier(address account) public onlyOwner {\r\n        _removeCroupier(account);\r\n    }\r\n\r\n    function _addCroupier(address account) internal {\r\n        _croupiers.add(account);\r\n        emit CroupierAdded(account);\r\n    }\r\n\r\n    function _removeCroupier(address account) internal {\r\n        _croupiers.remove(account);\r\n        emit CroupierRemoved(account);\r\n    }\r\n}"},"OwnerRole.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nimport \"./Roles.sol\";\r\n\r\ncontract OwnerRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event OwnerAdded(address indexed account);\r\n    event OwnerRemoved(address indexed account);\r\n\r\n    Roles.Role private _owners;\r\n\r\n    constructor () internal {\r\n        _addOwner(msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isOwner(address account) public view returns (bool) {\r\n        return _owners.has(account);\r\n    }\r\n\r\n    function addOwner(address account) public onlyOwner {\r\n        _addOwner(account);\r\n    }\r\n\r\n    function removeOwner(address account) public onlyOwner{\r\n        _removeOwner(account);\r\n    }\r\n\r\n    function _addOwner(address account) internal {\r\n        _owners.add(account);\r\n        emit OwnerAdded(account);\r\n    }\r\n\r\n    function _removeOwner(address account) internal {\r\n        _owners.remove(account);\r\n        emit OwnerRemoved(account);\r\n    }\r\n}"},"Roles.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address =\u003e bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account\u0027s access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}"}}
